/***************************************************************************
 *                                                                         *
 *  Project: ZapMJE                Purpose: Extensions to Zap              *
 *  Module: Routines.c             Purpose: C routines                     *
 *  © 1997 Martin Ebourne          Last update: 17-01-1998                 *
 *                                                                         *
 ***************************************************************************/

/*
 * 2000-10-01 checked entire file - sja
 * Some FIXME's and NOTE's still remain, and I really want to completely
 * rewrite the indenting. Most of the support routines are now okay, though.
 *
 * 2000-10-05 started fixing some of the grievious bugs - plan is to get a
 * reasonably stable version, hopefully acceptably useful, hammer out v1.45
 * and then rewrite all the indenting code for whatever comes with v1.46.
 * no guarantee this is possible, though - worst case, we fix it all now,
 * and have only incremental changes post v1.45 - sja
 *
 * 2000-10-07 fixed quite a few of the bugs. Trailing comments seem to
 * indent the following line for no terribly obvious reason /sometimes/.
 * Examples are noted with EEK in this file. - sja
 */

#include "Defns.h"

extern void wordr11(char c);
#define wordr11(c) ((void)0)
bool ischarincomment(unsigned int offset);
bool ischarinstring(unsigned int offset);
static bool lineisblank(int offset);
static int findbracketmatch(char close,unsigned int offset);
static bool lineisacomment(int offset);
bool is_label(char c, int i);
bool is_block_statement(char c, int i);

void C_test(void)
{
  zap_clearsel(); // this comment is here only to see if its colours wrap correctly :-)
}

void C_init(void)
{
  //  globalflag = 0;
}

// returns true if alphanumeric (using supposedly dodgy < and > code)...
// Strictly, returns true if it can be part of a C identifier. Because otherwise functions
// like is_break() cause immense fun by firing the break; recognition code ...
static bool alphanum(char c)
{
  if ((c >='a' && c <='z') || (c >='A' && c <='Z') || (c >='0' && c <='9') || c=='_') return true;

  return false;
}

/* -------------------------------------------------------------------------
 * Bracket matching functions
 * -------------------------------------------------------------------------
 */

/* Returns bracket type given character. Positive for open,
 * negative for close, or 0 if invalid */
static int getbrackettype(char c)
{
  switch(c)
  {
  case '(':
    return(1);
  case ')': return(-1);
  case '{': return(2);
  case '}': return(-2);
  case '[': return(3);
  case ']': return(-3);
  default: return(0);
  }
}

// Returns true if character at offset is escaped by
//   an odd number of \ characters
static bool escaped(unsigned int offset)
{
  bool escaped=false;
  while(offset && (getc(--offset)=='\\'))
  {
    escaped=!escaped;
  }

  return(escaped);
}

// Returns true if character at offset is inside a one-line comment
// Can't use isaquote() because that calls ischarincomment() ... which calls this.
static bool ischarin_oneline_comment(unsigned int offset)
{
  int i;
  char inquotes = 0; // 0, or char that quotes this region
  char c;

  if (getc(offset)==(window->cr.byte))
    offset--; // move back off end of line

  // move backwards to start of line / file
  //  for (i=offset; (getc(i)!=(window->cr.byte) && (i > 0)); i--);
  // I prefer the following formulation (sja):
  i=offset;
  while (getc(i)!=(window->cr.byte) && (i > 0)) {
    i--;
  }
  // FIXME: i either points to the cr.byte of the previous line, or to the sof?
  // Not that the mismatch is hugely problematic, but even so.

  // line to consider goes from (i) to (offset)
  // Some things to remember:
  //  * mismatched quotes are simply the quote type embedded in a quoted region
  if ((mode->shared.info)->intmode == int_asm) {
    do {
      c=getc(i);
      if ((c=='"' || c=='\'') && !escaped(i)) { // entering quoted region?
        if ((inquotes==c) || (inquotes == 0))
          inquotes ^= c;
      }
      if (c==';' && (inquotes == 0)) {
        return true;
      }
    } while (i++ < offset);
    return false;
  } else { /* C++ like */
    do {
      c=getc(i);
      // NOTE: quoting logic used to be (sja):
      // if ((c=='"' || c=='\'') && !escaped(i))
      //  inquotes=!inquotes;
      if ((c=='"' || c=='\'') && !escaped(i)) { // entering quoted region?
        if ((inquotes==c) || (inquotes == 0))
          inquotes ^= c;
      }
      if (c=='/' && !escaped(i) && (inquotes==0)) {
        if (getc(i+1) == '/') {
          return true;
        }
      }
    } while (i++ < offset);
    return false;
  }
}


// Walk back to last close brace.
// NOTE: this can probably be written better. Or at least more clearly.
int findlastclosebrace(unsigned int offset)
{
  do {
    while (offset && getc(--offset) != '}'); // walk back to last brace / sof
  } while (offset && ischarincomment(offset) || ischarinstring(offset)); // until we find one that isn't in a string or comment
  return offset;
}

// Returns true if character at offset is inside a comment
// NOTE: relies totally on how in_comment() works, which I haven't
// found documentation for / looked at in detail yet.
bool ischarincomment(unsigned int offset)
{
  int i;

  if ((offset == 0) || (offset > file->len))
    return false;
  i = in_comment(offset);
  if (!i)
    return false;
  if (i == 1)
    return true;

  return ischarin_oneline_comment(offset);
}

// Returns true if character at offset is inside a string
bool ischarinstring(unsigned int offset)
{
  return (offset == 0 || offset > file->len) ? false : in_string(offset);
}

// Returns true if character at offset is inside a comment, string or
// character literal
bool ischarinquoted(unsigned int offset)
{
  return (offset == 0 || offset > file->len) ? false : in_quoted(offset);
}

// Returns true if character at offset is a quote
static bool isaquote(unsigned int offset, char inquotes)
{
  char c = getc(offset);

  if ((inquotes == 0) && ((c=='\'' || ((c=='"'))) && !escaped(offset) && !ischarincomment(offset))) return true;
  if ((c==inquotes) && !escaped(offset) && !ischarincomment(offset)) return true;

  return false;
}


// Returns previous 'real' line start - needs improving to cope with:
// wibble int x,
//         int y {<CR>
// If anyone wants to do this, they need a sensible project to work on - sja
// It probably also ought to do:
// if (something ||
//     something_else) {
//   indent_to_here();
// by skipping back to the start of the continued expression.
//
// Currently, it just copes with lines with continuation thingumies at the end,
// ie the backslash.
static int findpreviousrealline(int offset)
{
  int i;

  if (offset <= 0) return 0;
  i=zap_basemode_e_linestart(offset);
  if (i < 1) return 0;

  while ((i > 0) && (getc(i-2) == '\\')) {
    i=zap_basemode_e_linestart(i - 1);
  }

  if (i < 0) i = 0;

  return i;
}


// Returns first 'real' char of line - ie first non-blank
static char firstcharofline(int offset)
{
  int i;
  char c;

  // NOTE. Was (sja):
  // if (offset <= 0) return 0;
  if (offset<=0) offset=0;
  i=zap_basemode_e_linestart(offset);

  c = getc(i++);
  while (((c==' ') || (c==(window->tabchar.byte))) && (i < (file->len)))
    c=getc(i++);
  if (i > (file->len)) c = (window->cr.byte);

  return c;
}


// Returns true if line is a preprocessor directive (and if we care about prepro directives)
static bool preprodirective(int offset)
{
  return ((mode->c.flags1 & M_FLAGS1_HIGHLIGHTPREPRO == 0) && firstcharofline(offset) == '#');
}


// Returns true if line is blank
static bool lineisblank(int offset)
{
  return (firstcharofline(offset) == (window->cr.byte));
}

// Find previous open bracket matching the given type
static int find_prevopen_bracketmatch(int t, unsigned int offset)
{
  signed char stack[32]; // bracket we're looking for
  unsigned int sp=0;
  stack[0]=-t;

  /* Close bracket - scan the file backwards */
  while(offset) {
    /* Get the type of bracket this character is, if any */
    char c=getc(--offset);
    t=getbrackettype(c);

    if(t<0 && !ischarincomment(offset)) {
      /* Close bracket.
      Stack the corresponding open bracket. Error on stack full */
      if(sp<31) {
        stack[++sp]=-t;
      } else {
        return(-1);
      }
    } else if(t && !ischarincomment(offset)) {
      /* Open bracket. Remove bracket off stack if present, else open
      bracket is out of sequence with close brackets so error */
      if (stack[sp]==t) {
        /* If last item on stack then found the one we want */
        if (!sp--)
          return(offset);
      } else {
        return(-1);
      }
    } else if (isaquote(offset,0) && (!ischarincomment(offset))) {
      /* Found a close quote. Search for the corresponding non-escaped
      open quote thus ignoring all the brackets (Hmm...:-<) */
      while(offset && ((getc(--offset)!=c) || (escaped(offset))));
    }
  }
  return -1;
}

// Find next close bracket matching the given type
static int find_nextclose_bracketmatch(int t, unsigned int offset)
{
  signed char stack[32];
  unsigned int sp=0;
  stack[0]=-t;

  /* Open bracket - scan the file forwards */
  while(offset<file->len) {
    /* Get the type of bracket this character is, if any */
    char c=getc(++offset);
    t=getbrackettype(c);

    if(t>0 && !ischarincomment(offset)) {
      /* Open bracket. Stack the corresponding close bracket.
      Error on stack full */
      if(sp<31) {
        stack[++sp]=-t;
      } else {
        return(-1);
      }
    } else if(t && !ischarincomment(offset)) {
      /* Close bracket.  Remove bracket off stack if present, else
      close bracket is out of sequence with open brackets so error */
      if(stack[sp]==t) {
        /* If last item on stack then found the one we want */
        if(!sp--)
          return(offset);
      } else {
        return(-1);
      }
    } else if (isaquote(offset,0)) {
      /* Found an open quote. Search for the corresponding non-escaped
      close quote thus ignoring all the brackets */
      while(offset+1<file->len && (getc(++offset)!=c || escaped(offset)));
    }
  }
  return -1;
}


// If bracket given is open, search forwards for matching close;
// if bracket given is close, search backwards for matching open.
// All errors, return -1.
static int findbracketmatch(char close,unsigned int offset)
{
  int t;
  if (ischarincomment(offset))
    return -1;
  t=getbrackettype(close);

  if (t<0) {
    return find_prevopen_bracketmatch(t, offset);
  } else if(t) {
    return find_nextclose_bracketmatch(t, offset);
  }
  return(-1);
}


// Move caret to given offset for delay time or until key pressed */
static void bounceto(unsigned int offset)
{
  if(mode->shared.matchdelay)
  {
    unsigned int start,delay;

    /* Remember old cursor position and move cursor to offset */
    unsigned int oldoff=cursor->off;
    cursor->off=offset;
    zap_reflectcaret();

    /* Wait for user specified delay, or keypress */
    start=os_readmonotonictime();
    delay=mode->shared.matchdelay;
    while(!kbhit() && os_readmonotonictime()-start<delay);

    /* Put the cursor back */
    cursor->off=oldoff;
    zap_reflectcaret();
  }
}

// returns total bracket depth on line containing the offset ...
static int getbrackdepth(unsigned int offset)
{
  char c = ' ';
  char inquotes = 0;
  int brackdepth = 0;
  unsigned int i=zap_basemode_e_linestart(offset);

  while ((c !=(window->cr.byte)) && (i < (file->len))) {
    if (!ischarincomment(i)) {
      c=getc(i);
      if (isaquote(i,inquotes))
        inquotes = inquotes ^ c;

      if (inquotes == 0) {
        if (c == '}')
          brackdepth--;
        if ((c == '{') && (brackdepth < 0)) // just in case ...
          brackdepth = 0;
        if (c == '{')
          brackdepth++;
      }
    }
    i++;
  }
  return brackdepth;
}


/* -------------------------------------------------------------------------
 * Indenting and character entering functions
 * -------------------------------------------------------------------------
 */

// Insert the spaces and tabs of the required indentation
static void performindentation(unsigned int start,indentsize size_of_indent)
{
  int i;

  while(size_of_indent.noofspaces) {
    i=size_of_indent.noofspaces;
    if(size_of_indent.noofspaces>32) {
      i=32;
    }
    size_of_indent.noofspaces-=i;
    /*                              Thirty two spaces............ */
    zap_command(zap_Insert,start,i,"                                ");
  }

  while(size_of_indent.nooftabs)
  {
    i=size_of_indent.nooftabs;
    if(size_of_indent.nooftabs>8) {
      i=8;
    }
    size_of_indent.nooftabs-=i;
    /*                              eight tabs... */
    zap_command(zap_Insert,start,i,"\t\t\t\t\t\t\t\t");
  }
}

// Add up total screen space (ie: columns) of the indent
int calctotalno(indentsize size_of_indent)
{
  return size_of_indent.noofspaces + 8 * size_of_indent.nooftabs;
}

// Given SOL what is current indent?
static indentsize indentdepth(int offset)
{
  bool notfoundend = true, problemflagged = false;
  indentsize size_of_indent;
  char c;

  size_of_indent.nooftabs = 0;
  size_of_indent.noofspaces = 0;

  while(notfoundend) {
    if ((offset + size_of_indent.noofspaces + size_of_indent.nooftabs) < file->len) {
      c=getc(offset + size_of_indent.noofspaces + size_of_indent.nooftabs);
      if (c==' ') {
        (size_of_indent.noofspaces)++;
      } else if (c==window->tabchar.byte) {
        (size_of_indent.nooftabs)++;
        if ((size_of_indent.noofspaces) > 0) // spaces exist on line before tabs
          problemflagged = true;
      } else {
        notfoundend = false;
      }
      if ((offset + size_of_indent.noofspaces + size_of_indent.nooftabs) > file->len)
        notfoundend = false;
    } else {
      notfoundend = false;
    }
  }

  // Stuff the column of the end of the indent into totalno
  size_of_indent.totalno = zap_basemode_e_lineoff(offset,offset + size_of_indent.noofspaces +
  size_of_indent.nooftabs);

  // if a bad mixture of tabs and spaces then use spaces...
  if (problemflagged == true)
  {
    size_of_indent.nooftabs = 0;
    size_of_indent.noofspaces = size_of_indent.totalno;
  }

  return size_of_indent;
}


// given an offset find the previous non-blank line start not in a comment/preprocessor
static int findprevnocommentline(int offset)
{
  unsigned int start;
  char c;
  int i,ipo;
  bool fin=false;

  // a fudge
  if (offset >= file->len)
    offset=(zap_basemode_e_linestart(offset)) - 1;

  if (offset <= 0)
    return 0;

  start=zap_basemode_e_linestart(offset);

  do {
    if (start > 0) {
      i = start;
      c = getc(i);
      while (((c==' ') || (c==(window->tabchar.byte))) && (i <= (file->len)))
        c=getc(i++); // skip blanks

      // sigh - do we /have/ to consider both cases? ;-(
      ipo = i + 1;
      if (ipo > file->len)
        ipo = file->len;
      if (i > file->len)
        i = file->len;

      if ((i <= (file->len)) &&
        (c == window->cr.byte || (c == '#' && mode->c.flags1 & M_FLAGS1_HIGHLIGHTPREPRO)) ||
        (ischarincomment(i) && (ischarincomment(ipo))))
        {
          start=zap_basemode_e_linestart(start - 1);
        } else {
          fin=true;
        }
    } else {
      fin=true;
    }
  } while (!fin);

  return start;
}


// Returns true if the line starts with a comment (not counting blanks).
// Does this by checking the character /after/ the first non-blank, but
// of course that shouldn't matter for C/C++/Java-like languages ...
static bool lineisacomment(int offset)
{
  unsigned int i = zap_basemode_e_linestart(offset);
  char c;
  int ipo;

  c = getc(i);
  while (((c==' ') || (c==(window->tabchar.byte))) && (i < (file->len)))
    c=getc(i++);
  ipo = i + 1;
  if (ipo > file->len)
    ipo = file->len;
  if ((ischarincomment(ipo)))
    return true;
  else
    return false;
}


// Returns true if offset is in blanks at start of line.
static bool beforestartofline(int offset)
{
  unsigned int i = zap_basemode_e_linestart(offset);
  char c;

  c = getc(i);
  while ((c==' ' || c==(window->tabchar.byte)) && i<(file->len))
    c=getc(i++);
  if (i >= (offset - 1))
    return true;
  else
    return false;
}


// Augment the indent by 'num' entries, remembering that c.indent
// is negative to indicate an indent size in tabs (# of the absolute value)
static indentsize changeindentby(indentsize size_of_indent,int num)
{
  if (mode->c.indent > 0) {
    size_of_indent.noofspaces += (mode->c.indent) * num;
  } else {
    size_of_indent.nooftabs -= (mode->c.indent) * num;
  }

  if (size_of_indent.noofspaces < 0)
    size_of_indent.noofspaces = 0;
  if (size_of_indent.nooftabs < 0)
    size_of_indent.nooftabs = 0;

  size_of_indent.totalno = calctotalno(size_of_indent);

  return size_of_indent;
}


/* break */
bool is_break(char c, int i)
{
  if (((c=='b') && (getc(i+1)=='r') && (getc(i+2)=='e') && (getc(i+3)=='a') && (getc(i+4)=='k') && (!alphanum(getc(i+5))))) return true;
  return false;
}

/* case or default */
bool is_label(char c, int i)
{
  if (((c=='c') && (getc(i+1)=='a') && (getc(i+2)=='s') && (getc(i+3)=='e') && (!alphanum(getc(i+4)))) ||
    ((c=='d') && (getc(i+1)=='e') && (getc(i+2)=='f') && (getc(i+3)=='a') && (getc(i+4)=='u') && (getc(i+5)=='l') && (getc(i+6)=='t') && (!alphanum(getc(i+7))))) return true;
  return false;
}

/* if, else, for or while */
bool is_block_statement(char c, int i)
{
  if ((((c=='i') && (getc(i+1)=='f') && (!alphanum(getc(i+2)))) ||
    ((c=='e') && (getc(i+1)=='l') && (getc(i+2)=='s') && (getc(i+3)=='e') && (!alphanum(getc(i+4)))) ||
    ((c=='f') && (getc(i+1)=='o') && (getc(i+2)=='r') && (!alphanum(getc(i+3)))) ||
    ((c=='w') && (getc(i+1)=='h') && (getc(i+2)=='i') && (getc(i+3)=='l') && (getc(i+4)=='e')) && (!alphanum(getc(i+5))))) return true;
  return false;
}

/* private, public or protected (for ':' indent) */
bool is_visibility_modifier_simple(char c, int i)
{
  if (((c=='p') && (getc(i+1)=='r') && (getc(i+2)=='i') && (getc(i+3)=='v') && (getc(i+4)=='a') && (getc(i+5)=='t') && (getc(i+6)=='e') && (!alphanum(getc(i+7)))) ||
    ((c=='p') && (getc(i+1)=='u') && (getc(i+2)=='b') && (getc(i+3)=='l') && (getc(i+4)=='i') && (getc(i+5)=='c') && (!alphanum(getc(i+6)))) ||
    ((c=='p') && (getc(i+1)=='r') && (getc(i+2)=='o') && (getc(i+3)=='t') && (getc(i+4)=='e') && (getc(i+5)=='c') && (getc(i+6)=='t') && (getc(i+7)=='e') && (getc(i+8)=='d') && (!alphanum(getc(i+9))))) return true;

  return false;
}

/* private:, public: or protected: */
bool is_visibility_modifier(char c, int i)
{
  if (((c=='p') && (getc(i+1)=='r') && (getc(i+2)=='i') && (getc(i+3)=='v') && (getc(i+4)=='a') && (getc(i+5)=='t') && (getc(i+6)=='e') && (getc(i+7)==':')) ||
    ((c=='p') && (getc(i+1)=='u') && (getc(i+2)=='b') && (getc(i+3)=='l') && (getc(i+4)=='i') && (getc(i+5)=='c') && (getc(i+6)==':')) ||
    ((c=='p') && (getc(i+1)=='r') && (getc(i+2)=='o') && (getc(i+3)=='t') && (getc(i+4)=='e') && (getc(i+5)=='c') && (getc(i+6)=='t') && (getc(i+7)=='e') && (getc(i+8)=='d') && (getc(i+9)==':'))) return true;

  return false;
}

// Re-indent current line according to requirements
// brack can be '{', ':', '}' or cr.byte
void reindentline(char brack)
{
  int start2, i;
  char c;
  indentsize original_size_of_indent,size_of_indent2;
  int oomb = -1, casedef = 1, visibilitydef = 1;
  unsigned int oldflags=file->flags;
  unsigned int start=zap_basemode_e_linestart(cursor->off);

  if (brack == '}') { // use indent from line the bracket matches
    oomb = findbracketmatch('}',cursor->off);
    if (oomb >= 0) {
      start2 = findpreviousrealline(zap_basemode_e_linestart(oomb));
      size_of_indent2 = indentdepth(start2);
    }
  }

  if ((brack != '}') || (oomb == -1)) { // not bracket matching (or it failed) - use indent from previous useful line
    start2 = findpreviousrealline(findprevnocommentline(start - 1));
    size_of_indent2 = indentdepth(start2);
  }

  /* Calculate number of whitespace chars at start of that line */
  if (brack != '}') {
    i=getbrackdepth(start2);
    if (i>0) { // unmatched on that line: '{'
      size_of_indent2 = changeindentby(size_of_indent2,i);
    } else if (i<0) { // unmatched on that line: '}'
      oomb = findbracketmatch('}',findlastclosebrace(cursor->off));
      if (oomb == -1) // before the start of the file?
        oomb = 0;
      // use indent from previous useful line to bracket matching line
      // (we went back to previous useful line looking for an indent, but that
      // line had unmatched cbraces, so we go back to find a match for that --
      // this isn't recursive, however, so it's probably possible to confuse it).
      start2 = findpreviousrealline(zap_basemode_e_linestart(oomb));
      size_of_indent2 = indentdepth(start2);
    }

    // NOTE: I've moved this outside the previous conditional, because it should
    // (surely?) always be fired unless we're dealing with a cbrace -- sja.
    // skip blank space
    for (; ((c=getc(start2))==' ' || c==window->tabchar.byte) && start2 < file->len; start2++);
    casedef = !is_label(c, start2);
    visibilitydef = !is_visibility_modifier(c, start2);
    // does this line NOT begin with 'case' / 'default' / visibility modifier?
  }

  /* Calculate number of whitespace chars at start of line */
  for (i=start;(((c=getc(i))==' ' || c==window->tabchar.byte) && (i < file->len));i++);

  // Check for 'case' or 'default'; unindent a little if found
  // Do this only if the previous useful line didn't have case/default starting it.
  if (casedef && !ischarincomment(i) && is_label(c, i))
    size_of_indent2 = changeindentby(size_of_indent2, -1);
  // Similarly for visibility modifiers
  if (visibilitydef && !ischarincomment(i) && is_visibility_modifier_simple(c, i))
    size_of_indent2 = changeindentby(size_of_indent2, -1);

  // Huh? If we've scanned past the cursor. This routine is /always/ called from
  // within a character insertion routine, so the cursor will /always/ be where the
  // appropriate character is inserted. I can't see how we can scan to the cursor
  // or beyond unless the cursor was at the first non-blank space on the line.
  // And I don't think that's the point, so ... umm ...
  if (i > (cursor->off) - 1) {
    /* Replace all of current whitespace with required number of
       whatever characters the line was originally indented with as the
       new indent */
    original_size_of_indent = indentdepth(start);

    // following /causes/ failure sometimes...
    if (original_size_of_indent.totalno != size_of_indent2.totalno) {
      file->flags|=1<<14;
      zap_command(zap_Delete,start,i-start,NULL);
      performindentation(start,size_of_indent2);
      file->flags=oldflags;
    }
  }
}

/*
 * If this line contains a block statement without block or statement,
 * or case/default, we have to reindent following lines on entering '{'.
 * A /similar/ function is performed by adjustbrackdepthforifs() ... I
 * /think/.
 */
static bool needtochkprev(int offset)
{
  int realstartofline = zap_basemode_e_linestart(offset);
  int realendofline = zap_basemode_e_lineend(offset);
  int i;
  int iflevel = 0;
  char c,b;

  char inquotes = 0;
  bool foundlevelchanger = false;
  bool foundsemicolon = false;
  bool caseordefault = false;

  if (offset <= 0) return false;
  i=realstartofline;

  if (preprodirective(i)) return false;

  do {
    c=getc(i);
    if (inquotes==0) {
      if (is_block_statement(c,i) || is_label(c,i)) {
        if (i>0) b = getc(i-1); else b = 0;
        if (!ischarincomment(i) && !escaped(i) && !alphanum(b)) {
          iflevel = true;
          if (is_label(c,i)) // case, default
            caseordefault=true;
        }
      }

      if (((c=='{') || (c=='}') || (c==';')) && (!(escaped(i-1))) && (!(ischarincomment(i-1)))) {
        if (c==';')
          foundsemicolon = true;
        else
          foundlevelchanger = true;
      }

      if (foundsemicolon && (c>32) && (c!=';') &&
          (c!='/') && (c!='*') && (!ischarincomment(i)))
        foundsemicolon = false; // deals with 'for (x;y;z)' ... amongst others
    }

    if (isaquote(i,inquotes))// something
      inquotes = inquotes ^ c;

  } while ((i++ <= realendofline) && (c!=(window->cr.byte))); // offset);

  // Bits of blocks, or statements not following case/default mean we don't have
  // to check this line when considering those after it.
  if ((foundsemicolon && !caseordefault) || foundlevelchanger) iflevel = false;
  // Otherwise, if we found a block statement or case/default, then we do.
  return iflevel;
}

/*
 * Adjusts indents for any unfinished block keyword found on this line.
 * By 'unfinished', we mean where the block or statement isn't completed
 * on this line. Except it also checks the start of a block.
 * If it fails a condition that I don't think /can/ fail, then it scans
 * further backwards trying to figure out what to do. This is very wooly,
 * and quite probably wrong most of the time. I've removed my lame attempts
 * to get break; to knock off, since that's not the domain of this function
 * at all, and in any case we don't do things like that any more -- sja
 */
static indentsize adjustbrackdepthforifs(int offset,indentsize size_of_indent)
{
  int realstartofline = zap_basemode_e_linestart(offset);
  int realendofline = zap_basemode_e_lineend(offset);
  int newstartofline;
  int i;
  int iflevel = 0, caselevel = 0;
  char c,b;

  char inquotes = 0;
  bool foundlevelchanger = false;
  bool foundsemicolon = false;
  bool foundopening = false;

  i=realstartofline;

  if (preprodirective(i)) return size_of_indent; // don't work :-(

  // Scan the line for interesting things.
  do {
    c=getc(i);
    if (inquotes==0 && !ischarincomment(i) && !escaped(i)) {
      if (i>0)
        b = getc(i-1);
      else
        b = 0;

      // Indent after if/else/for/while/visibility:
      if (is_block_statement(c,i) || is_visibility_modifier(c,i)) {
        // normal check: not part of an identifier that just
        // happens to have the appropriate characters in it
        if (!alphanum(b)) {
          iflevel = 1; // only indent once for one if ...
        }
      }

      // EEK: first example of comments indenting ...
      if (is_label(c,i)) { // Indent after case/default
        if (!alphanum(b)) {
          caselevel = 1; // only indent once for one case ...
        }
      }

      // Need to check that this doesn't immediately follow a comment
      // or string. (NOTE: but what about char* c="this"; ? Ofc, that
      // doesn't have any bearing on if (something) statement; ...)
      if (((c=='{') || (c=='}') || (c==';')) &&
        (!(escaped(i-1))) && (!(ischarincomment(i-1)))) {
          if (c==';')
            foundsemicolon = true;
          else
          {
            if (c=='{')
              foundopening = true;
            foundlevelchanger = true;
          }
        }

        // Huh? If we previously found a semicolon, but this isn't it
        // and we're not leading into something that might be a comment
        // (BUT: what about '/' and '*' as arithmetic operators?), then it
        // wasn't a 'real' semicolon, but part of a 'for' statement.
        // Surely this fails on wibble(); x = y * t[\n]; ?
        // AH! Perhaps it's _supposed_ to only catch the last semicolon
        // on the line. The 'for' comment is misleading ... ?
        if (foundsemicolon && (c>32) && (c!=';') &&
          (c!='/') && (c!='*') && (!ischarincomment(i)))
          foundsemicolon = false; // deals with 'for (x;y;z)'
    }

    if (isaquote(i,inquotes))
      inquotes = inquotes ^ c;
  } while ((i++ <= realendofline) && (c!=(window->cr.byte)));

  // This tries to clear up if/else/for/while followed by their statement
  // on the same line, and also copes with finding their block starting on
  // the same line. In neither case does the following line indent due to
  // the block keyword.
  //
  // We can cope with:
  //
  // if (something)
  // { ...
  // } else
  //
  // except that the extra indent from the else doesn't subsequently
  // get knocked off, presumably because the other code to cope with that
  // doesn't understand about a level changer followed by a keyword.
  // To get old behaviour (not coping with the above at all) use foundlevelchanger.
  // To get new, use foundopening.
  if (foundsemicolon || foundlevelchanger)
    iflevel = 0;

  iflevel += caselevel;

  size_of_indent = changeindentby(size_of_indent,iflevel);

  // If we found a brace (2nd condition), or there was a block keyword without
  // its statement/block (3rd condition), or there was no block keyword at all
  // and no brace and no semicolon (1st condition) -- then we're done.
  if (!foundsemicolon ||
    foundlevelchanger ||
    (iflevel > 0)) return size_of_indent; // ||

  // My analysis of the above is definitely wrong (since the code /CAN/ fire) - sja

  // So: no braces, so we didn't find a block at all. No block keywords without
  // statements/blocks at all. Might have been a keyword, but then it would have
  // had to have had a block (fails - 2nd condition), a statement (fails - 1st
  // condition) or neither (fils - 3rd condition). So I'm confused; my
  // analysis of the above is wrong (or this code never fires).

  // Otherwise, we need to consider earlier lines, because this line looks like
  // it didn't contain a complete statement for us to use. (Or something like that.)
  // We keep going backwards until we find one with '}' or ';' on ... ie the end of
  // a statement or block.
  do {
    foundlevelchanger = false; // overkill...
    foundsemicolon = false;
    foundopening = false;
    //    inquotes = false;
    inquotes = 0;

    // Find the previous useful line. If we're at the start of the
    // file, reset the indent to nothing.
    if (realstartofline == 0)
      return changeindentby(size_of_indent,-99); // !
    newstartofline = findprevnocommentline(realstartofline - 1);
    if (newstartofline == 0)
      return changeindentby(size_of_indent,-99); // !

    // Okay, let's consider from here forward to the line we've
    // already done.
    i=newstartofline;
    do {
      c=getc(i);
      // EEK: second example of comments indenting
      if (inquotes==0) {// anything interesting on this line?
        if (((c=='{') || (c=='}') || (c==';')) && (!escaped(i)) && (!ischarincomment(i))) {
          if (c=='{')
            foundopening = true;
          if (c==';')
            foundsemicolon = true;
          else
            foundlevelchanger = true;
        }
        if (foundsemicolon && (c>32) && (c!=';') && (c!='/') &&
            (c!='*') && (!ischarincomment(i)))
          foundsemicolon = false; // deals with 'for (x;y;z)' again (and similar)
      }
      if (isaquote(i,inquotes))
        inquotes = inquotes ^ c;

    } while ((i++ < realstartofline) && (c!=(window->cr.byte))); // offset); was <=

    // If we found nothing useful ('{', '}' or ultimate ';'), loop to try another line.
    if ((!foundlevelchanger) && (!foundsemicolon)) {
      realstartofline = newstartofline;
      //      activity_reqd = true;
    }
  } while ((!foundlevelchanger) && (!foundsemicolon));

  // If the final line we checked was a preprocessor line, stop here.
  if (preprodirective(realstartofline))
    return size_of_indent; // doesn't work?

  inquotes=0;
  i=realstartofline;
  realendofline = zap_basemode_e_lineend(i);
  //  foundsemicolon = false;
  //  flag = false;

  // Let's reconsider this line we found (the one with the end of the block/statement
  // on it).
  // FIXME: not the one /after/ that? It looks like that to me ...
  do {
    c=getc(i);
    // If it's a break, visibility: or label, give up.
    if (i>0)
      b = getc(i-1);
    else
      b = 0;
    if (!alphanum(b) && !ischarincomment(i) && inquotes==0 && (is_break(c, i) || is_visibility_modifier(c,i) || is_label(c,i)))
      return size_of_indent;

    if (isaquote(i,inquotes))
      inquotes = inquotes ^ c;
  } while ((i++ <= realendofline) && (c!=(window->cr.byte))); // offset);

  // If we've got to here, just count the brackets and add that to the current indent.
  // (This is still the earliest line we considered.)
  size_of_indent = indentdepth(realstartofline);
  i = getbrackdepth(realstartofline); // was newsol...
  size_of_indent = changeindentby(size_of_indent,i);

  return size_of_indent;
}


// deal with pressing return
// cases to deal with include: if, case, default, { and }, visibility modifiers
static void returnindent(void)
{
  indentsize size_of_indent,oldsize_of_indent,original_size_of_indent;
  int i, start2;
  char c;
  unsigned int oldflags = file->flags;
  unsigned int start = zap_basemode_e_linestart(cursor->off); // this line...

  if (start == 0) // deal with start of file
    return;

  start2 = findprevnocommentline(start - 1); // previous 'useful' line start
  size_of_indent = indentdepth(findpreviousrealline(start));
  oldsize_of_indent = size_of_indent; // last useful line's indent
  size_of_indent = adjustbrackdepthforifs(start2,size_of_indent); // deal with un-blocked if's and similar
  if ((size_of_indent.noofspaces == oldsize_of_indent.noofspaces) &&
    (size_of_indent.nooftabs == oldsize_of_indent.nooftabs))
    return;
  // Calculate number of whitespace chars at start of /this/ line
  for(i=start; ((c=getc(i))==' ' || c==window->tabchar.byte) && (i < file->len); i++);
  // NOTE: not positive following is correct, but it seems to work ...
  if (is_label(c, i) || is_visibility_modifier(c, i)) { // if we start with a label, knock off an indent level
    size_of_indent = changeindentby (size_of_indent, -1);
  }
  // Replace old indent characters with new ones
  original_size_of_indent = indentdepth(start);
  if (original_size_of_indent.totalno != size_of_indent.totalno) {
    file->flags|=1<<14;
    zap_command(zap_Delete,start,i-start,NULL);
    performindentation(start,size_of_indent);
    file->flags=oldflags;
  }
}

// Moves bracket marks around during insertions/deletions in Zap_Command
// so that we still know where the brackets are.
void move_markers_around(unsigned int cno,unsigned int offset,unsigned int num)
{
  int i = (cno & 7);

  // move markers around...
  if(ws->bracketoff1!=-1) {
    if (ws->bracketoff1 > offset) {
      if ((i == 1) || (i == 6)) {
        ws->bracketoff1 += num;
      } else if ((i == 2) || (i == 5)) {
        ws->bracketoff1 -= num;
      }
    }
    if(ws->bracketoff2!=-1) {
      if (ws->bracketoff2 > offset) {
        if ((i == 1) || (i == 6)) {
          ws->bracketoff2 += num;
        } else if ((i == 2) || (i == 5)) {
          ws->bracketoff2 -= num;
        }
      }
    }
  }
}


// Next level of C_char: After bracket matching, now indent line if required
// Some rather dubious and scatty code here.
static void charwithindent(unsigned int wflags, unsigned int len,
unsigned int wformat, const char  *data)
{
  unsigned int i;
  int tempbo1 = ws->bracketoff1, tempbo2 = ws->bracketoff2;
  int before = cursor->off, truelen = len;
  char a, t='@';

  zap_startop();

  for(i=0; i<len; i++) { // check for anything that needs the indentation depth altering
    a = data[i];
    switch(a)
    {
      // EEK: example of comments indenting
    case ':': // label
      if (zap_readvar(v_carmode) != 2) { // not during split cursor
        ++i;
        data+=i;
        len-=i;

        {
          int cur = cursor->off;
          int flen = file->len;
          int i, j;
          // NOTE: firstcharofline() contains almost exactly the same code. Needs
          // factoring into a shared function.
          i = j = zap_basemode_e_linestart(cur);
          while (i < file->len && ((a = getc(i)) == ' ' || a == window->tabchar.byte))
            i++; /* skip white space */

          if (is_label(a, i) || is_visibility_modifier_simple(a, i)) {
            cursor->off = j;
            reindentline(':');
            cursor->off = cur + file->len - flen;
          }
        }

        data-=i;
        len+=i;
        zap_basemode_e_char(wflags,i,wformat,data); // insert up to here
        data+=i; // We've done this bit
        len-=i;
      }
      break;
      // EEK: example of comments indenting
    case '{':   // C & C++. cc-mode also does ';' & ',' - why?
      // EEK: example of comments indenting
    case '}':   // probably because emacs likes to revalidate its indentation after every statement? (sja)
      if (a != '}' || zap_readvar(v_carmode) != 2) { // either '{' or not split cursor mode (FIXME: huh?)
        ++i;
        data+=i;
        len-=i;

        if (a != '}') { // '{' (may be split cursor mode?)
          if ((needtochkprev(findprevnocommentline(cursor->off))) || (window->addr == -1))
          {
            // follows something like if/for/else/case/default/while/whatever that might
            // have indented this line in anticipation of a simple statement (no braces)
            // We need to reindent the line again telling it about the '{' to correct this.
            reindentline(a);
          }
        } else {
          // '}' -- insert it, force a reindent to get the match, then delete it again
          // (it'll be /re/inserted in the next zap_basemode_e_char() call ...)
          zap_basemode_e_char(wflags,1,wformat,&t);
          unlearntzap_commandstring("LEFT");
          reindentline(a);
          unlearntzap_commandstring("DELETENEXT");
        }

        data-=i;
        len+=i;
        zap_basemode_e_char(wflags,i,wformat,data); // insert up to here
        data+=i; // We've done this bit
        len-=i;
      }
      break;
    }
  }

  if (len) { // do anything remaining
    zap_basemode_e_char(wflags,len,wformat,data);
  }

  zap_stopop();

  // Restore
  ws->bracketoff1 = tempbo1;
  ws->bracketoff2 = tempbo2;

  // is this necessary...?
  // NOTE: was '|' not '||'!
  if ((!(window->flags & 2)) ||
    (getc(cursor->off) == (window->cr.byte)))
    move_markers_around(1, before, truelen); // - before);
}

// Handle the default e_char entry point so we get bracket matching
// If we're inserting a close bracket, match on that one.
// If we're inserting a ':' and it closes a label, reindent that.
// Don't bother if we're in a comment or string ...
void C_char(unsigned int wflags,
unsigned int len,
unsigned int wformat,
const char *data)
{
  if(len && (getbrackettype(data[len-1])<0) && !ischarincomment(cursor->off) && !ischarinstring(cursor->off)) {
    int offset;
    // Last character is a close bracket.
    if(len>1) // Insert all the characters before it
      charwithindent(wflags,len-1,wformat,data);
    if (window->addr != -1) { // Bounce to the corresponding open bracket
      if ((offset=findbracketmatch(data[len-1],cursor->off))>=0)
        bounceto(offset);
    }
    data+=len-1;
    len=1; // just do closing bracket
  }
  charwithindent(wflags,len,wformat,data);
  ws->oldcoff=-1;
}

// Handle the default e_return entry point so we get auto-indent
//
// A couple of weird things: what does w_addr==-1 indicate?
// More nastiness with inserting, deleting, reinserting to get
// indent, then deleting again. Again, need a native way of doing
// this.
void C_return(unsigned int wflags,
unsigned int wformat,
int type)
{
  int tempdelay, before = cursor->off;
  char a, c='B';
  int tempbo1 = ws->bracketoff1, tempbo2 = ws->bracketoff2;
  bool blank = false;

  if ((lineisacomment(before)) && (beforestartofline(before)))
    type = 1; // Return No Indent
  if (((window->format)&0x10000) == 0)
    type = 1; // if no auto-indent offset, Return No Indent
  if (window->addr == -1) {
    type = 0; /* erm ... start address is -1 (?) => Return With Indent */
  }
  // NB: I /think/ that the RNI stuff relies on using the basemode's e_return
  // and just assuming it does the Right Thing based on the options. ie: set
  // the indent width to 0, use RETURN, and you'll get the very basic indent
  // preservation of Text mode.

  if (type != 1) {
    blank = lineisblank(before);
    zap_startop();
    // EEK: comment causes indenting
    zap_basemode_e_return(type,wflags,wformat); // with appropriate indent
    if ((!blank) || (window->addr == -1)) { /* non-blank line / start address is -1 (?) */
      if (!ischarincomment(cursor->off)) { // not a comment
        reindentline((window->cr.byte));
        returnindent(); // get the indent for the return ...
        a = getc(cursor->off);
        if ((a == '}')) { // force a re-indent if we're sitting on a cbrace, to match indentation
          tempdelay = mode->shared.matchdelay;
          mode->shared.matchdelay = 0;
          unlearntzap_commandstring("RIGHT");
          C_char(0,1,wformat,&c); // INSERT "B"
          unlearntzap_commandstring("LEFT");
          unlearntzap_commandstring("DELETE"); // Delete the '}'
          C_char(0,1,wformat,&a); // put the '}' back in (with autoindent)
          unlearntzap_commandstring("RIGHT");
          unlearntzap_commandstring("DELETE"); // Delete the 'B'
          unlearntzap_commandstring("LEFT"); // Back to where we started
          mode->shared.matchdelay = tempdelay;
        }
      }
    }
    zap_stopop();
  } else { // Return No Indent
    zap_basemode_e_return(type,wflags,wformat);
  }
  ws->bracketoff1 = tempbo1;
  ws->bracketoff2 = tempbo2;
  move_markers_around(1,before,cursor->off - before);
  ws->oldcoff=-1;
}

// Reindent the current line, and move to the next.
// Notes (sja)
//  1. I'd like this not to move to the next line -- we have gotoline #(@line + 1)
//  2. This really should just strip the indent, figure out the indent
//     depth, and reinsert the indent itself, rather than using lots of
//     nasty command strings. However it'll do for the moment.
void C_reindent(const char *data,   /* Pointer to string parameter (except MJE_REINDENT takes none ...) */
unsigned int count,   /* Number of times pressed (unused) */
unsigned int reason,  /* Reason code for call (unused) */
unsigned int wformat,
unsigned int wflags /* (unused) */)
{
  char a;
  char c='A';
  unsigned int atemp;

  if (ischarinstring(zap_basemode_e_linestart(cursor->off))) {
    /* start of line is in a long string - just move to the next line */
    unlearntzap_commandstring("CRIGHT");
    unlearntzap_commandstring("DOWN");
    unlearntzap_commandstring("CLEFT");
    return;
  }

  if (lineisacomment(cursor->off) && (mode->c.flags1 & M_FLAGS1_INDENTCOMMENTS))
  {
    unlearntzap_commandstring("CRIGHT");
    unlearntzap_commandstring("DOWN");
    unlearntzap_commandstring("CLEFT");
  } else {
    zap_startop();
    atemp = window->addr;
    window->addr = -1;
    unlearntzap_commandstring("CLEFT");
    unlearntzap_commandstring("UNSPACE"); // kill lead tabs
    unlearntzap_commandstring("UNSPACE"); // kill lead spaces
    unlearntzap_commandstring("DELETE"); // kill NL
    if (cursor->off)
      unlearntzap_commandstring("RETURN"); // if not at sof, return to get indent correct
    a = getc(cursor->off);
    if (a=='}' || a=='{') { // if the char at left of line causes additional reindentation ...
      unlearntzap_commandstring("RIGHT");
      unlearntzap_commandstring("DELETE");
      C_char(0,1,wformat,&c); // insert a dummy char instead of it ('A')
      unlearntzap_commandstring("LEFT");
      C_char(0,1,wformat,&a); // put the character back again in front of it (forces reindentation)
      unlearntzap_commandstring("RIGHT");
      unlearntzap_commandstring("DELETE"); // get rid of the dummy char
    }
    unlearntzap_commandstring("CRIGHT");
    unlearntzap_commandstring("DOWN");
    unlearntzap_commandstring("CLEFT");
    window->addr = atemp;
    zap_stopop();
  }
}


/* -------------------------------------------------------------------------
 * Parenthesis functions - highlighted bracket matching
 * -------------------------------------------------------------------------
 */

/* Force redraw of a given character offset to (un)highlight it */
static void highlightchar(int offset)
{
  wordr11('h');
  if(offset>=0) {
    zap_offlinecol_ret xy;
    zap_update_coords rect;

    window->txtn=0;
    xy=zap_offlinecol(offset);
    rect.windowhandle=window->handle;
    rect.maxx=(rect.minx=xy.column)+1;
    rect.maxy=(rect.miny=xy.row)+1;
    if (rect.windowhandle!=-1)
      zap_updatearea(&rect);
  }
}


// Un-highlight any brackets currently highlighted.
// NB. Destroys window/file pointers
static void unhighlight()
{
  /* If there was a previous window */
  if(ws->oldcwind!=-1) {
    zap_convwindoff(ws->oldcwind);
    if(window) {
      if(ws->bracketoff1!=-1) {
        int old=ws->bracketoff1;
        ws->bracketoff1=-1;
        highlightchar(old);
      }

      {
        int old=ws->bracketoff2;
        ws->bracketoff2=-1;
        highlightchar(old);
      }
    }
  }
}

// update all highlighted areas on e_command
void C_command(unsigned int cno,unsigned int offset,unsigned int num,char *data)
{
  /* If there was a previous window */
  if(ws->oldcwind!=-1) {
    zap_convwindoff(ws->oldcwind);
    if(window)
      move_markers_around(cno,offset,num);
  }
}

// Handler for paren call backs
void C_parencallback(int handle)
{
  /* Get current cursor mode. Check for being normal cursor */
  if(zap_readvar(v_carmode)==1) {
    int offset1=-1,offset2=-1,coff;

    cursor=(c_block *)zap_readvar(v_carcursor);
    coff=cursor->off;
    zap_convwindoff(cursor->wind);

    /* Check to see if anything has changed */
    if(cursor->wind!=ws->oldcwind || (window->format&255)!=(ws->oldwformat&255)
       || coff!=ws->oldcoff)
    {
      /* It has, so if in one of our modes scan for bracket matches */
      if(C_checkmode() && coff && (offset1=findbracketmatch(getc(coff-1),coff-1))>=0) {
        offset2=coff-1;
        ws->bracketclr=mode->shared.info->bracketclr;
      }

      unhighlight();

      /* Remember new values */
      ws->oldcwind=cursor->wind;
      ws->oldwformat=window->format;
      ws->oldcoff=coff;
      ws->bracketoff1=offset1;
      ws->bracketoff2=offset2;

      /* Re-convert window/file blocks after unhighlight, and highlight new characters */
      zap_convwindoff(cursor->wind);
      if(offset1!=-1) {
        highlightchar(offset1);
      }
      if(offset2!=-1) {
        highlightchar(offset2);
      }
    }
  } else if(ws->oldcwind!=-1) {
    unhighlight();
    ws->oldcwind=-1;
  }
}
