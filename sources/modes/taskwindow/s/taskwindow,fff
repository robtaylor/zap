; Contains mode entry points for Taskwindow mode.
; $Id: taskwindow,fff,v 1.9 2002-11-18 13:13:52 christian Exp $
; -*- armasm -*-

 GET h.ZapBasHdr
 GET h.ZapBASIC
 GET h.BASIC
 GET h.Buttons

 IMPORT charchar
 IMPORT bas_execute

 EXPORT twmode_table_start
 EXPORT TaskWindow
 EXPORT create_task_window
 EXPORT Cmdtaskwindowflagstoggle
 EXPORT TaskWindow_Control

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Taskwindow block						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The taskwindow block pointed to by f_source has the following format:
;
; #0 Task handle of child task
; #4 Cursor x coordinate
; #8 Cursor y coordinate
; #12 Height of emulated screen in characters
; #16 Emulated text window (VDU 28) min x
; #20 Emulated text window (VDU 28) min y
; #24 Emulated text window (VDU 28) max x
; #28 Emulated text window (VDU 28) max y
; #32 Number of bytes in the VDU queue
; #36 12 byte vdu queue
; #48 Reserved
; #52 Flags b0 Task suspended
;	    b1 Ignore start/end
;	    b2 Task unlinked
;	    b3 Task killed
;	    b4 Output suspended (VDU 21)
; #56 Line offset in window of start of emulated screen.
; #60 Reserved
;
; R8,#w_bpl = width of emulated screen in characters
;
; Window layout:
;
;		0                           w_bpl
;	      0 ---------------------------------
;		|				|
;		|				|
;		|				|
;	    #56 |-------------------------------| }
;		|				| }
;		|		#16	#24	| }
;		|	#20+#56 ---------	| }
;		|		|	|	| } Emulated screen
;		|		|	|	| }
;		|	#28+#56 ---------	| }
;		|				| }
;	#56+#12	|-------------------------------| }
;		|				|
;      w_height	|-------------------------------|
;
; Scrolling causes the emulated screen to move down the buffer unless a
; text window is set when the contents of the window is physically moved!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Taskwindows							;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

twmode_table_start
 DCD twmode_table_start
 DCD twmode_title
 DCD basic_author
 DCD 0
 DCD 12+&200			; want mode 12+taskwindow input
 DCD twmode_init
 DCD 0
 DCD twmode_table_end-twmode_table_start

 DCD 0				;postload
 DCD 0				;presave
 DCD 0				;loading
 DCD twmode_start
 DCD twmode_end
 DCD twmode_width
 DCD 0				;bastxt_linecol
 DCD 0				;mode11_lineoff
 DCD 0				;bastxt_clnlog
 DCD 0				;bastxt_clnphy
 DCD 0				;bastxt_clnoff
 DCD 0				;bastxt_nextline
 DCD 0				;mode11_minus
 DCD 0				;mode11_minus
 DCD 0				;mode11_minus
 DCD 0				;mode11_minus
 DCD 0				;mode11_minus
 DCD 0				;mode11_minus
 DCD twmode_redrawline		;bastxt_redrawline
 DCD 0				;bastxt_redrawlnum
 DCD twmode_char
 DCD 0				;mode11_delete
 DCD 0				;tab
 DCD 0				;mode11_return
 DCD 0				;bastxt_renumber
 DCD 0				;basic_saveandrun
 DCD 0				;bastxt_linestart
 DCD 0				;bastxt_lineend
 DCD 0				;bastxt_linenext
 DCD 0				;bastxt_lineprev
 DCD twmode_copy
 DCD 0				;bastxt_joinline
 DCD 0				;bastxt_splitline
 DCD 0				;mode11_aligncaret
 DCD twmode_command
 DCD 0				;basic_compile
 DCD 0				;format text
 DCD 0				;basic_run
 DCD 0				;basic_runandquit
 DCD 0				;basic_basic
 DCD 0				;bastxt_search
 DCD 0				;bastxt_replace
 DCD 0				;bastxt_selection
 DCD mode12_click		;mode11_click
 DCD twmode_message
 DCD twmode_setwidth
 DCD 0
 DCD 0
 DCD 0
 DCD twmode_interrogate
twmode_table_end

twmode_title
 FNS ("Taskwindow")

 LOCAL

twmode_init
	CMP	R1,#8
	ADDLO	PC,PC,R1,LSL #2
	B	other$l
	B	dying$l
	B	starting$l
	B	started$l
	B	taskwindow_kill
	MOV	PC,R14
	B	taskwindow_diesilently
	B	cols$l
	B	taskwindow_menu ; OK
other$l
	TEQ	R1,#15
	MOVNE	PC,R14
	TEQ	R9,#0
	MOVEQ	PC,R14
	LDR	R0,[R9,#f_source]
	LDR	R0,[R0,#2]
	MOV	R0,R0,LSR #16 ; lower 16 bits of task handle
	SWI	&6258A ; DDEUtils_ 10
	MOVVS	R0,#0
	MOVS	PC,R14
cols$l
	ADR	R1,twmode_cols
	MOV	PC,R14

taskwindow_menu
 FNJSR
 BL loadmenuifrequired
 FNcall Zap_ReadMenu
 LDRVC R1,[R0,#8]
 FNRTS

taskwindow_diesilently
 FNJSR	"R0,R2-R11"
 LDR	R1,localcopyof_mode_taskwindow
 FNcall Zap_GetModeWord
 ANDS	R1,R0,#1 << 30			; die silently bit...
 MOVNE  R1,#-1
 FNRTS

started$l
 FNJSR "R3"
 ADR R0,s6$l
 ADR R3,s5$l
 BLVC alias_general		; preserve the old one...
 ADR R0,t$l			; use ZapBasic_Taskwindow in future
 ADR R3,s4$l
 BLVC alias_general
 BLVC init_mode_word		; set up mode words if needed
 FNRTS

dying$l
 FNJSR "R1,R2,R3,R4"
 ADR R0,s7$l
 ADR R3,s4$l
 BL alias_general
 MOVVC R0,#-1			; don't kill the module yet
 FNRTS

localcopyof_mode_taskwindow
 DCD 0

starting$l
 FNSTR R0,mode_taskwindow	; mode used by taskwindow
 STR R0,localcopyof_mode_taskwindow
 MOV PC,R14

s4$l = "Alias$Taskwindow",0
s5$l = |zap$|,"$Taskwindow",0
s6$l = "<Alias$Taskwindow>",0
s7$l = "<",|zap$|,"$Taskwindow>",0
t$l = |zap$|,"BASIC_TaskWindow ",0
 ALIGN

twmode_cols
 = "*"
 = 0
 = ">"
 = 0
 = 0
 ALIGN

 LOCAL

;E R0=string to alias taskwindow command to
;  R3 = name of os_var to be set
;X command aliased #

alias_general
 FNJSR "R1-R4"
 MOV R1,R0			; var value
 BL str_len
 MOV R2,R0			; var length
 MOV R0,R3
 MOV R3,#0
 MOV R4,#0			; macro string
 SWI XOS_SetVarVal
 FNRTS

 LOCAL

twmode_start
 FNJSR "R1-R3,R7"
 PUSH "R0-R12"			; BUG!!!!!!!!!!!!!!!!!!!
 BL loadlineeditor
 PULL "R0-R12"
 STR R11,local_stored_areeleven
 FNLDR R1,mode_taskwindow	; mode number of taskwindow mode
 MOV R0,R1
 BL restore_mode_word
 FNRTS VS
 LDR R0,[R9,#f_cmode]
 TEQ R0,R1
 FNRTS NE			; this is not an active taskwindow
 LDR R7,[R9,#f_source]		; data buffer
 LDR R0,[R7,#52]		; flags
 TST R0,#2			; ignore? - never used...?
 FNRTS NE
 TST R0,#1			; task suspended?
 FNRTS EQ
 BIC R0,R0,#1
 STR R0,[R7,#52]		; resume task
 FNLDR R1,buf_detoken
 MOV R0,#20
 STR R0,[R1]			; length
 MOV R0,#0
 STR R0,[R1,#12]		; your ref
 LDR R0,resume$l
 STR R0,[R1,#16]		; action
 MOV R0,#17
 LDR R2,[R7]
 SWI XWimp_SendMessage		; resume task
 FNRTS

twmode_end
 FNJSR "R1-R3,R7"
 FNLDR R1,mode_taskwindow	; mode used by taskwindows
 MOV R0,R1
 BL save_mode_word
 FNRTS VS
 LDR R0,[R9,#f_cmode]
 TEQ R0,R1
 FNRTS NE
 LDR R7,[R9,#f_source]
 LDR R0,[R7,#52]		; flags
 TST R0,#2			; ignore?
 FNRTS NE
 TST R0,#1			; already suspended?
 FNRTS NE
 ORR R0,R0,#1
 STR R0,[R7,#52]
 FNLDR R1,buf_detoken
 MOV R0,#20
 STR R0,[R1]			; length
 MOV R0,#0
 STR R0,[R1,#12]		; your ref
 LDR R0,suspend$l
 STR R0,[R1,#16]		; action
 MOV R0,#17
 LDR R2,[R7]
 SWI XWimp_SendMessage		; suspend task
 FNRTS

 DCD 7+(2<<3)+(1<<15)
TaskWindow_Control
 CMP R8,#0
 BEQ tickq0$l
 CMP R9,#0
 BEQ tickq0$l
 CMP R0,#0
 MOVLE PC,R14
 FNJSR "R7,R10,R11" ; must match with later on pre_kill...!
 LDRB R7,[R8,#w_format]
 LDR R10,localcopyof_mode_taskwindow
 CMP R10,R7
 BNE tickq0a$l
 LDR R10,[R0]
 LDR R7,[R9,#f_source]
 CMP R7,#0
 BLE tickq6$l
 CMP R10,#0
 BEQ TaskWindowSuspend$l
 CMP R10,#2
 BEQ TaskWindowUnlink$l
 CMP R10,#3
 BEQ TaskWindowLink$l
 CMP R10,#4
 BEQ TaskWindowKill
 CMP R10,#5
 BEQ TaskWindowResurrect
 LDR R14,[R7,#52]		; flags
 TEQ R2,#15
 BEQ tickq1$l
 TST R14,#1			; task suspended?
 FNRTS EQ
 BIC R14,R14,#1
 STR R14,[R7,#52]		; resume task

 ADR R1,local_twmsgbuffer
 MOV R0,#20
 STR R0,[R1]			; length
 MOV R0,#0
 STR R0,[R1,#12]		; your ref
 LDR R0,resume$l
 STR R0,[R1,#16]		; action
 MOV R0,#17
 LDR R2,[R7]
 SWI XWimp_SendMessage		; resume task
 FNRTS

tickq0$l
 MOV R0,#2
 MOV PC,R14
tickq0a$l
 MOV R0,#2
 FNRTS

tickq1$l
 TST R14,#1			; task suspended?
 MOVEQ R0,#2
 MOVNE R0,#0
 TST R14,#8			; task dead?
 MOVNE R0,#2
 FNRTS

tickq2$l
 TST R14,#9			; task suspended?
 MOVNE R0,#2
 MOVEQ R0,#0
 FNRTS

tickq3$l
 TST R14,#4			; task linked?
 MOVEQ R0,#2
 MOVNE R0,#0
 TST R14,#8			; task dead?
 MOVNE R0,#2
 FNRTS

tickq4$l
 TST R14,#12			; task linked?
 MOVNE R0,#2
 MOVEQ R0,#0
 FNRTS

tickq5$l
 TST R14,#8			; task killed?
 MOVNE R0,#2
 MOVEQ R0,#0
 FNRTS

tickq6$l
 TST R14,#8			; task killed?
 MOVEQ R0,#2
 MOVNE R0,#0
 FNRTS

local_twmsgbuffer
 DCD 0
 DCD 0
 DCD 0
 DCD 0
 DCD 0

TaskWindowSuspend$l
 LDR R14,[R7,#52]		; flags
 TEQ R2,#15
 BEQ tickq2$l
 TST R14,#1			; already suspended?
 FNRTS NE
 ORR R14,R14,#1
 STR R14,[R7,#52]

 ADR R1,local_twmsgbuffer
 MOV R0,#20
 STR R0,[R1]			; length
 MOV R0,#0
 STR R0,[R1,#12]		; your ref
 LDR R0,suspend$l
 STR R0,[R1,#16]		; action
 MOV R0,#17
 LDR R2,[R7]
 SWI XWimp_SendMessage		; suspend task
 FNRTS

suspend$l DCD &808C6		; TaskWindow_Suspend
morite$l DCD &808C4		; TaskWindow_Morite
resume$l DCD &808C7		; TaskWindow_Resume

TaskWindowLink$l
 LDR R14,[R7,#52]		; flags
 TEQ R2,#15
 BEQ tickq3$l
 BIC R14,R14,#6			; and ignore bit.
 STR R14,[R7,#52]
 FNRTS

TaskWindowUnlink$l
 LDR R14,[R7,#52]		; flags
 TEQ R2,#15
 BEQ tickq4$l
 ORR R14,R14,#6			; and ignore bit.
 STR R14,[R7,#52]
 FNRTS

TaskWindowResurrect
 LDR R14,[R7,#52]		; flags
 TEQ R2,#15
 BEQ tickq6$l
 BIC R14,R14,#15
 STR R14,[R7,#52]		; flags
 LDR R11,local_stored_areeleven ; [R12]	; this module's workspace...?
 BL resurrect_task_window
 LDR R0,[R8,#w_bpl]
 BL twmode_setwidth ; clear screen...?
 FNRTS

pre_TaskWindowKill
 FNJSR "R7,R10,R11" ; must match...!
TaskWindowKill
 LDR R14,[R7,#52]		; flags
 TEQ R2,#15
 BEQ tickq5$l
 PUSH "R0-R2"
 ORR R14,R14,#8
 STR R14,[R7,#52]		; killed flag.
 ADR R1,local_twmsgbuffer
 MOV R0,#20
 STR R0,[R1]			; length - no data.
 MOV R0,#0
 STR R0,[R1,#12]		; my ref
 LDR R0,morite$l
 STR R0,[R1,#16]		; message
 MOV R0,#17
 LDR R2,[R9,#f_source]		; buffer pointer
 LDR R2,[R2]			; task handle
 SWI XWimp_SendMessage		; kill the task
 PULL "R0-R2"
 FNRTS

 LOCAL

;;;;;;;;;;;;;;;;;;;
; Kill TaskWindow ;
;;;;;;;;;;;;;;;;;;;

taskwindow_kill
 FNJSR "R0-R12"
 MOV R2,#0			; /could/ be important...!?
 LDR R7,[R9,#f_source]
 LDR R14,[R7,#52]		; flags
 TST R14,#4			; unlinked

 BLEQ pre_TaskWindowKill
 MVN R14,#0
 STR R14,[R9,#f_cmode]		; disown file
 FNRTS VS
 MOV R0,R7
 FNcall Zap_Free,R10		; free the buffer
 FNRTS

local_stored_areeleven
 DCD 0

twmode_redrawline
 FNJSR "R4,R12"
 STR R4,twmode_locstsp5
 LDR R0,twmode_locstsp1
 CMP R0,R7
 LDREQ R0,twmode_locstsp8
 CMPEQ R0,R8
 LDREQ R2,twmode_locstsp2
 BNE twmode_getr2atstartofline
twmode_redraw_reentry
 LDR R4,[R8,#w_txtw]
 MOV R3,#0
twmode_redrawloop1
 CMP R7,R10
 BLCS red_overflow
 BVS twmode_redraw_overflow
 LDRB R0,[R7],#1
 CMP R0,#10
 BEQ twmode_redraw_endoftheline
 CMP R0,#09
 BEQ twmode_redraw_tabchar

twmode_redraw_aftertabchar
 STRB R2,[R6,R4]		; put fg colour
 ADD R1,R4,R4
 MOV R14,#1
 STRB R14,[R6,R1]		; put bg colour
 STRB R0,[R6],#1		; put character
twmode_redraw_AfterColour
 ADD R3,R3,#1			; counter
twmode_redraw_BeginOfEnd
 LDR R1,[R8,#w_bpl]
 CMP R3,R1
 BLT twmode_redrawloop1		; loop
; new code to fix Richard's bug as proposed by sja...
 CMP R7,R10
 BLCS red_overflow
 BVS twmode_redraw_overflow
; end of new code...
 LDRB R0,[R7]
 CMP R0,#10
 BEQ twmode_redraw_addonetoavoidCR
twmode_redraw_overflow
twmode_redraw_juststoreandret
 STR R8,twmode_locstsp8
 STR R7,twmode_locstsp1
 STR R2,twmode_locstsp2
 ADD R11,R11,#1			; logical line counter
 FNRTVC 			; ret without error

twmode_redraw_addonetoavoidCR
 ADD R7,R7,#1
twmode_redraw_endoftheline
 MVN R0,#0
 STR R0,twmode_locstsp1
 ADD R11,R11,#1			; logical line counter
 FNRTVC 			; ret without error

twmode_locstsp1
 & 0
twmode_locstsp2
 & 0
twmode_locstsp3
 & 0
twmode_locstsp4
 & 0
twmode_locstsp5
 & 0
twmode_locstsp8
 & 0

; /E R5, R7 setup
; /X R2 for the start of the current line.

twmode_getr2atstartofline
 STR R6,twmode_locstsp3
 STR R7,twmode_locstsp4
 SUB R7,R7,R5			; get file offset of line start
 MOVS R0,R7
 BMI twmode_rtatstartofline
 BEQ twmode_rtatstartofline ; really?
 LDR R1,[R9,#f_len]
 CMP R0,R1
 BLCC cln_readc
 MOV R3,#0
twmode_redr_startoflineloop
 MOV R2,R7
 SUB R7,R7,#1
 ADD R3,R3,#1
 MOVS R0,R7
 BMI twmode_rtatstartofline
 LDR R1,[R9,#f_len]
 CMP R0,R1
 BLCC cln_readc
 CMP R0,#10
 BNE twmode_redr_startoflineloop
 MOV R7,R2
 MOV R2,#2
 CMP R3,#2
 BCS twmode_rtatstartofline2
 ;...
twmode_rtatstartofline
 MOV R2,#2
twmode_rtatstartofline2
 MOVS R0,R7
 MOVMI R0,#0			; needed?
 LDR R1,[R9,#f_len]
 CMP R0,R1
 BLCC cln_readc
 CMP R0,#'>'
 MOVEQ R2,#&0A
 CMP R0,#'*'
 MOVEQ R2,#&09
 LDR R6,twmode_locstsp3
 LDR R7,twmode_locstsp4
 B twmode_redraw_reentry

; TabbingSub
twmode_redraw_tabchar
 LDR	 R1,twmode_locstsp5
 AND     R1,R1,#&3000
 TEQ     R1,#0
 BEQ     twmode_redraw_aftertabchar
 CMP     R6,#0
 BLT     twmode_redraw_BeginOfEnd

 MOV     R0,#9			; REM tab!
 TEQ     R1,#&1000
 MOVEQ   R0,#' '		; REM " "!!!!
 TEQ     R1,#&3000
 MOVEQ   R0,#'-'		; REM "-"!!!!
twmode_redraw_TabLoop
 MOV     R1,#8       		; REM = COL control Character...
 STRB    R1,[R6,R4]		;@@@@
 MOV     R1,#1
 STRB    R1,[R6,R4,LSL #1]	; REM wrong?
 STRB    R0,[R6],#1		; REM @@@@@@
 ADD     R3,R3,#1
 LDR	 R1,twmode_locstsp5
 AND     R1,R1,#&3000
 TEQ     R1,#&2000
 MOVEQ   R0,#' '
 CMP     R1,#0
 TSTNE   R3,#7
 BNE     twmode_redraw_TabLoop
 MOV     R0,#' '
 TEQ     R1,#&3000
 MOVEQ   R0,#9			; Tab
 STREQB  R0,[R6,#-1]		; Colour
 B       twmode_redraw_BeginOfEnd

twmode_width
 FNJSR "R1"
 FNLDR R0,mode_taskwindow
 MOV R1,#&0A
 BL calc_mode_width
 FNRTS

twmode_setwidth
 FNJSR "R1,R10"
 FNLDR R10,mode_taskwindow
 MOV R1,R0
 BL set_width
 FNRTS VS
 TEQ R8,#0
 FNRTS EQ
 CMP R1,#0
 STRPL R1,[R8,#w_bpl]
 BLPL tw_newwidth
 FNRTS

 LOCAL

twmode_copy
 TEQ R0,#2
 MOVEQ PC,R14			; please call my e_chars
 TEQ R0,#1
 MOVNE PC,R14			; not collecting data
 FNJSR "R1,R4-R7"		; R2 and R3 returned
 MOV R6,R1			; R6=number of characters to get (saved)
 LDR R0,[R9,#f_cmode]
 FNLDR R7,mode_taskwindow
 TEQ R0,R7
 MOVNE R3,#0
 MOVNE R2,#0
 FNRTS NE			; not in a proper task window
 LDR R7,[R9,#f_source]		; buffer
 FNLDR R0,buf_insert
 FNcall Zap_Ensure
 FNRTS VS
 FNSTR R0,buf_insert
 MOV R5,R0			; R5=buffer
 LDR R2,[R10,#c_col]		; cursor x
 LDR R3,[R10,#c_line]		; cursor y
 LDR R0,[R8,#w_margin]
 SUBS R2,R2,R0
 MOVMI R2,#0
 LDR R0,[R7,#56]
 SUBS R3,R3,R0
 MOVMI R3,#0			; cursor x y on screen
 MOV R4,R6			; width to get counter
loop$l
 CMP R4,#0
 BLE end$l			; finished
 BL tw_getchar
 STRVCB R0,[R5],#1
 BLVC tw_increment
 SUBVC R4,R4,#1			; done one more
 BVC loop$l
 FNRTS
end$l
 BL twc_to_xy_nopad
 STR R2,[R10,#c_col]
 STR R3,[R10,#c_line]		; cursor posn
 FNcall Zap_FindOffset
 STRVC R0,[R10,#c_off]
 STRVC R1,[R10,#c_loff]
 FNLDR R3,buf_insert,VC		; buffer
 MOVVC R2,R6			; number of characters
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Vet the taskwindow command!				    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E As for a command. NB TaskWindow -Display is used by CTRL-F12
;  Uses .taskw_str to store the command

TaskWindow
 FNJSR "R1-R12"
 LDR R11,[R12]			; this module's workspace
 MOV R3,R0			; save tail
 ADD R1,R11,#taskw_str
 ADR R2,ta_s0
 BL strcpy			; copy in unaliased command
 MOV R4,R1			; save start of arguments
 MOV R2,R3
 BL strcopy			; copy string accross
 SUB R5,R1,#1			; save end of arguments
 LDRB R0,[R4]
 CMP R0,#'0'
 BCC tota2
 CMP R0,#'9'
 BCC ta1
tota2
 MOV R1,#0			; replying to startup message
ta2
 LDRB R0,[R4],#1
 CMP R0,#&20
 BCC ta3			; -ctrl not found
 CMP R0,#34			; "
 EOREQ R1,R1,#1
 TST R1,#1
 BNE ta2
 TEQ R0,#'-'
 BNE ta2			; not the start of an option
 SUB R2,R4,#1
 ADR R1,ta_s1
 BL strcmpstr
 BNE ta2			; doesn't match
 B ta1				; found a -ctrl
ta3
 MOV R0,#&20
 STRB R0,[R5]			; add space
 ADD R1,R5,#1
 ADR R2,ta_s1
 BL strcopy			; copy in -CTRL option
ta1
 ADD R0,R11,#taskw_str
 SWI XOS_CLI
 FNRTS

ta_s0 FNS ("%TaskWindow ")
ta_s1 FNS ("-ctrl")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Taskwindow messages					     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

twmode_message
 TEQ R3,#17
 MOVNE PC,R14
 SUB R0,R2,#&80000
 SUB R0,R0,#&008C0
 CMP R0,#6
 ADDLO PC,PC,R0,LSL#2
 MOV PC,R14			; unrecognised
 B TaskWindow_Open		; sent by Zap to open task window
 B TaskWindow_Output
 B TaskWindow_Ego
 B TaskWindow_Morio
 MOV PC,R14
 B TaskWindow_NewTask

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Taskwindow code					 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TaskWindow_Open
 FNJSR "R10"
 MOV R10,#0
 BL create_task_window		; open the task window
 FNRTS

TaskWindow_NewTask
 FNJSR "R1-R2,R10"	; please open a task window
 MOV R10,R1			; wimp message
 LDR R0,[R10,#8]
 STR R0,[R10,#12]		; copy my ref
 MOV R0,#19			; acknowledge
 MOV R1,R10			; message
 LDR R2,[R10,#4]		; task
 SWI XWimp_SendMessage		; acknowledge
 ADDVC R10,R10,#20		; command to use
 BLVC create_task_window	; start up a task window
 FNRTS

;E R8/R9=0 for normal startup/address of command to use
;X Taskwindow file created DB #

resurrect_task_window
 FNJSR "R1-R9"
 ADR R0,tw_s0
 SWI XOS_CLI			; check task window module ok
 MOVVC R10,#0
 BVC rude_tw_entry
 FNRTS

;E R10=0 for normal startup/address of command to use
;X Taskwindow file created DB #

create_task_window
 FNJSR "R1-R9"
 ADR R0,tw_s0
 SWI XOS_CLI			; check task window module ok
 FNRTS VS
 MOV R0,#&F00
 ORR R0,R0,#&FF
 MOV R1,#1
 MOV R2,#0			; no undo
 MOV R3,#&FF
 ORR R3,R3,#1<<31
 FNLDR R4,mode_taskwindow	; taskwindow mode
 ORR R4,R4,#1<<31
 FNcall Zap_CreateFile		; create an empty R8/R9
 MOVVC R0,#0
 FNcallc Zap_PutCaret,VC	; bung cursor in there
 FNRTS VS
rude_tw_entry
 MOV R6,#&20			; space
 FNLDR R1,buf_detoken		; place to put start command
 MOVS R2,R10
 ADREQ R2,tw_s1			; use default
 MOV R0,#'%'
 STRB R0,[R1],#1		; unaliased version
 BL strcpy
 TEQ R10,#0
 STRNEB R6,[R1],#1		; add space
 PUSH "R1"		; save string pointer
 MOV R1,#4
 FNcall Zap_ReadVar		; get zap's task handle
 PULL "R1"
 FNRTS VS
 MOV R2,#16
 SWI XOS_ConvertHex8		; insert task handle
 FNRTS VS
 ADR R2,tw_s2
 TEQ R10,#0
 STRNEB R6,[R1],#1		; add space
 BLEQ strcpy			; add -txt
 FNcall Zap_GetWindOff
 MOV R2,#16
 SWI XOS_ConvertHex8		; add in as my unique handle
 FNRTS VS
 TEQ R10,#0
 STRNEB R6,[R1],#1		; add extra space on the end
 MOV R0,#0
 STRB R0,[R1]			; terminator
 FNLDR R0,buf_detoken
 SWI XWimp_StartTask		; try and start up task
 FNRTS

tw_s0 FNS ("RMEnsure TaskWindow 0.29 RMLoad System:Modules.Task")
tw_s1 FNS ("TaskWindow -task &")
tw_s2 FNS (" -ctrl -txt &")

 LOCAL

; Taskwindow is telling me its handle. I use its task handle to find out
; its name. Uses buf_detoken.

TaskWindow_Ego
 FNJSR "R1-R11"
 MOV R10,R1
 LDR R0,[R10,#20]		; my -txt handle for this
 FNcall Zap_ConvWindOff		; R8/R9=file
 LDR R0,[R9,#f_ptr]
 CMP R0,#0
 FNRTS LE			; problems!
 MOV R0,#64
 FNcall Zap_Claim		; claim buffer for taskwindow
 FNRTS VS
 STR R0,[R9,#f_source]
 MOV R7,R0			; buffer
 FNLDR R0,mode_taskwindow
 STR R0,[R9,#f_cmode]		; a task window owned file
 LDR R0,[R10,#4]		; tasks id
 STR R0,[R7]			; fill it in
 MOV R0,#0
 STR R0,[R7,#32]		; zero queue
 STR R0,[R7,#52]		; zero flags
 STR R0,[R7,#56]		; screen image offset
 MOV R0,#-1
 BL taskwindow_mode		; find mode x,y
 STRVC R3,[R7,#12]		; screen height
 BLVC tw_restore_window
 FNRTS VS
 FNcall Zap_GetFileOff		; R0=file offset
 MOV R6,R0			; save as the private word
 LDR R0,mess$l			; Task Name Request Message + want reply
 FNLDR R1,buf_detoken		; message
 LDR R14,[R7]			; task id
 STR R14,[R1,#20]
 MOV R2,#0			; broadcast
 MOV R3,#24			; message length
 ADR R5,sub$l			; reply sub
 FNcall Zap_SendMessage		; ask for the task name
 FNRTS
mess$l DCD &400C6+(1<<28)+(2<<30)
sub$l				; R1=message block R11=file offset
 FNJSR
 LDR R0,mess2$l
 TEQ R0,R2
 FNRTS NE			; not the correct message
 MOV R0,R11
 FNcall Zap_ConvFileOff		; set up R9
 ADDVC R0,R1,#28
 FNcallc Zap_NewFileName,VC	; change the file name to the task name
 FNcallc Zap_NewFileTitle,VC	; update the titlebars
 FNRTS
mess2$l DCD &400C7		; Name is reply message

TaskWindow_Morio
 FNJSR "R1-R11"

 LDR R0,[R1,#4]			; child handle
 BL find_task_window		; R9=taskwindow
 FNRTS VS
 TEQ R9,#0
 FNRTS EQ	; not found

 LDR R7,[R9,#f_source]		; data buffer
 LDR R14,[R7,#52]		; flags
 ORR R14,R14,#8			; killed flag.
 STR R14,[R7,#52]

 LDR R0,[R9,#f_flags]
 BIC R0,R0,#1<<3		; modified...?
 STR R0,[R9,#f_flags]
 FNcall Zap_NewFileTitle
 FNRTS

 LOCAL

; I have been sent some data to print

TaskWindow_Output
 FNJSR "R1-R11"
 LDR R0,[R1,#4]			; child handle
 BL find_task_window		; R9=taskwindow
 FNRTS VS
 TEQ R9,#0			; found?
 FNRTS EQ
 BL tw_getinputcur
 FNRTS VS
 PUSH "R9"
 LDR R0,[R10,#c_wind]
 FNcall Zap_ConvWindOff		; get R8/R9 of input cursor
 MOV R0,R9
 PULL "R9"
 TEQ R0,R9
 BEQ window$l			; cursor is in a window onto this file
 FNcall Zap_FindWindow		; find first window on this file
 FNRTS VS
window$l			; found the correct window in R8
 LDR R7,[R9,#f_source]		; pointer to buffer
 ADD R4,R1,#24			; data
 LDR R5,[R1,#20]		; data len
 LDR R0,[R7,#32]		; number of bytes queued
 TEQ R0,#0
 BEQ start$l			; none queued
 CMP R0,#9
 BHI start$l			; ridiculous buffer
 SUB R4,R4,R0
 ADD R5,R5,R0
 ADD R1,R7,#36			; queue
 MOV R2,R4
 MOV R3,R0
 FNcall Zap_MoveBytes		; copy queue in over message
 MOV R0,#0
 STR R0,[R7,#32]		; zero queue
start$l				; R4=data R5=data len
 FNcall Zap_StartOp		; do all in one go
 FNRTS VS
 MOV R1,#10
 FNcall Zap_ReadVar		; read caret mode
 MOVVC R10,R0			; save caret mode
 MOVVC R0,#-2
 FNcallc Zap_WriteVar,VC	; pretend there are no carets
 BVS end$l
loop$l				; R4=data R5=data len
 CMP R5,#0
 BLE end$l			; finished
 MOV R3,R4			; save data start
 LDRB R0,[R4],#1		; get next char
 SUB R5,R5,#1
 BL test_ctrl_char
 CMP R1,#0
 BPL ctrl$l			; control char
collect$l			; collect longest string of normal chars
 CMP R5,#0			; before a ctrl char
 BLE collected$l
 LDRB R0,[R4]
 BL test_ctrl_char
 CMP R1,#0
 SUBMI R5,R5,#1
 ADDMI R4,R4,#1
 BMI collect$l
collected$l
 SUB R2,R4,R3			; num chars collected
 BL taskwindow_output_char
 BVC loop$l
 B end$l
ctrl$l
 CMP R5,R1
 BLT tw16			; need to queue the data
 TEQ R1,#0
 BNE tw14			; don't try and buffer
tw17
 CMP R5,#0
 BLE tw14			; no more data
 LDRB R14,[R4]
 TEQ R0,R14
 ADDEQ R4,R4,#1
 SUBEQ R5,R5,#1
 BEQ tw17			; absorb repetitions
tw14
 SUB R2,R4,R3			; number of times
 BL taskwindow_output_ctrl
 ADDVC R4,R4,R1			; skip the params
 SUBVC R5,R5,R1
 BVC loop$l
 B end$l
tw16
 MOV R1,R3			; source
 ADD R2,R7,#36			; queue
 ADD R3,R5,#1			; number
 STR R3,[R7,#32]		; number queued
 FNcall Zap_MoveBytes		; fill queue
end$l				; end / error
 BL tw_restore_car
 FNcall Zap_StopOp		; finish the op
 BLVC tw_showcursor		; make sure cursor visible etc
 FNRTS

tw_restore_car
 FNJSR "R0-R1"
 MOV R0,R10
 MOV R1,#10
 FNcall Zap_WriteVar		; restore the caret mode
 FNRTS

;X R10=cursor block of the input cursor

tw_getinputcur
 FNJSR "R1"
 MOV R1,#10
 FNcall Zap_ReadVar		; get caret mode
 FNRTS VS
 TEQ R0,#2
 MOVNE R1,#5			; cursor
 MOVEQ R1,#6			; input
 FNcall Zap_ReadVar		; find cursor posn
 MOVVC R10,R0			; save cursor
 FNRTS

 LOCAL

;E R7=block R8/R9
;X If got cursor then posn updated and plotted
;  If not got cursor then pseudo posn made visable BD #

tw_showcursor
 FNJSR "R1-R5,R10"
 BL tw_getinputcur		; R10=input cursor
 FNRTS VS
 FNcall Zap_GetWindOff
 LDR R1,[R10,#c_wind]
 TEQ R0,R1
 BNE nocur$l			; we haven't got the cursor
 BL twc_buf_xy_nopad		; get cursor posn
 STRVC R2,[R10,#c_col]
 STRVC R3,[R10,#c_line]		; update cursor posn!?!?!
 FNcallc Zap_FindOffset,VC
 STRVC R0,[R10,#c_off]
 STRVC R1,[R10,#c_loff]
 FNcallc Zap_PlotCaret,VC
 FNcallc Zap_ShowCursor,VC
 FNRTS
nocur$l
 FNLDR R10,buf_retoken		; simulate cursor
 FNcall Zap_GetWindOff
 STRVC R0,[R10,#c_wind]
 STRVC R0,[R10,#c_owind]
 MOVVC R0,#0
 STRVC R0,[R10,#c_off]
 STRVC R0,[R10,#c_loff]
 MOVVC R0,#1
 STRVC R0,[R10,#c_width]
 STRVC R0,[R10,#c_owidth]
 BLVC twc_buf_xy_nopad		; get cursor posn
 STRVC R2,[R10,#c_col]		; may use buf_detoken if adding y's
 STRVC R2,[R10,#c_ocol]
 STRVC R3,[R10,#c_line]		; update cursor posn
 STRVC R3,[R10,#c_oline]
 FNcallc Zap_GetWindState,VC
 FNcallc Zap_ShowCursor,VC
 FNRTS

 LOCAL

;E R0=vdu character
;X If R0 a normal printable character then R0 saved R1=-1
;  If R0 a ctrl char then R0 saved and R1=number of param bytes

test_ctrl_char
 TEQ R0,#&7F
 MOVEQ R1,#0
 MOVEQ PC,R14
 CMP R0,#&20
 MVNCS R1,#0
 MOVCS PC,R14
 ADR R1,table$l
 LDRB R1,[R1,R0]
 MOV PC,R14
table$l
 DCD &00000100			; VDU 0-7
 DCD &00000000
 DCD &00000000			; VDU 8-15
 DCD &00000000
 DCD &05020100			; VDU 16-23
 DCD &09010000
 DCD &00000508			; VDU 24-31
 DCD &02000404

 LOCAL

;E R0=task handle of task window task
;X R9=pointer to associated file /0 if not found |

find_task_window
 FNJSR "R1-R4"
 FNLDR R4,mode_taskwindow
 MOV R3,R0			; save task handle
 MOV R1,#9
 FNcall Zap_ReadVar
 FNRTS VS
 MOV R1,R0			; number of files
 MOV R2,#0			; current file
loop$l
 CMP R2,R1
 MOVCS R9,#0			; run out of files so not found
 FNRTS CS
 MOV R0,R2
 FNcall Zap_ConvFileOff		; find address of file block
 LDR R14,[R9,#f_ptr]
 CMP R14,#0
 BLE next$l			; this file is empty/invalid
 LDR R14,[R9,#f_cmode]
 TEQ R14,R4
 BNE next$l			; not a task window
 LDR R14,[R9,#f_source]		; buffer pointer
 LDR R14,[R14]			; task handle
 TEQ R14,R3			; is it the correct one?
 FNRTS EQ
next$l
 ADD R2,R2,#1			; try next file
 B loop$l

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Input to a taskwindow					  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

twmode_command
 FNJSR "R1"
 AND R0,R0,#7			; basic command number
 TEQ R0,#1			; an insert?
 BNE actively_ignore_input	; digit '1' to ctrl-1 etc. Taskwindow
 LDR R14,[R9,#f_source]
 LDR R14,[R14,#52]		; flags
 TST R14,#15			; ignore / suspended / killed
 BNE actively_ignore_input
a$l				; wait 'till ctrl key not pressed or
 BL test_shiftctrl		; taskwindow module starts converting
 BVS actively_ignore_input	; digit '1' to ctrl-1 etc. Taskwindow
 TST R1,#2			; module is *BADLY* written. Beware!
 BNE a$l			; control still pressed ; no multi-task :(
 MOV R0,R3			; data address
 MOV R1,R2			; data length
 BL taskwindow_input
actively_ignore_input
 MOV R2,#0
 FNRTS

twmode_char
 FNJSR
 LDR R14,[R9,#f_source]
 LDR R14,[R14,#52]		; flags
 TST R14,#7			; ignore or suspended
 FNRTS NE
 FNLDR R1,mode_taskwindow
 BL charchar
 MOV R0,R7
 MOV R1,R5
 BL taskwindow_input
 FNRTS

 LOCAL

;E R0=data R1=length R8/R9=taskwindow (with valid source)
;X key data sent to taskwindow BD #

taskwindow_input
 FNJSR "R1-R11"
 MOV R7,R0			; save data
 MOV R6,R1			; save len
 LDR R0,local_claimed_wkspace	; is a paste-style op happening already?
 CMP R0,#0
 FNRTS NE
 LDR R0,[R9,#f_cmode]
 FNLDR R14,mode_taskwindow
 TEQ R0,R14
 FNRTS NE			; not an intiated task window
 MOV R4,R6
 CMP R4,#&3C
 BGT large$l
 ADD R5,R4,#24+3		; header size
 BIC R5,R5,#3			; and word align for message size
 FNLDR R0,buf_detoken		; message buffer
 MOV R1,R7
 ADD R2,R0,#24
 MOV R3,R4
 FNcall Zap_MoveBytes		; copy data into message buffer
 FNLDR R1,buf_detoken
 STR R5,[R1,#0]			; message size
 MOV R0,#0
 STR R0,[R1,#12]		; my ref
 LDR R0,input$l
 STR R0,[R1,#16]		; message
 STR R4,[R1,#20]		; size of input data
 MOV R0,#17
 LDR R2,[R9,#f_source]		; buffer pointer
 LDR R2,[R2]
 SWI XWimp_SendMessage		; send the data
 FNRTS
input$l DCD &808C0		; TaskWindow_Input
large$l				; R7=data R6=len (but not valid across
 FNcall Zap_GetFileOff		; calls so can't be relied on)
 MOV R3,R0
 ADD R0,R4,#28
 FNcall Zap_Claim
 FNRTS VS
 STR R0,local_claimed_wkspace
 STR R6,[R0],#4
 MOV R14,#20
 STR R14,[R0],#4
 STR R3,[R0],#4 ; store file offset.
 STR R11,[R0],#4 ; store my wkspace ptr
 STR R12,[R0],#4 ; store zap's wkspace ptr
 MOV R2,R0
 MOV R1,R7
 MOV R3,R6
 FNcall Zap_MoveBytes		; copy data into the buffer
 MOV R1,#-2
 ADR R2,callback_tw_insert
 FNcall Zap_CallBack
 FNRTS
local_claimed_wkspace
 DCD 0

callback_tw_insert
 FNJSR "R0-R12"
 MOV R0,#&70 ; escape
 BL test_forkey
 BCS escaped$l
 LDR R0,local_claimed_wkspace
 LDR R6,[R0]
 CMP R6,#0
 BLE notagain$l
 LDR R5,[R0,#4]
oninthere$l
 ADD R7,R0,R5
 LDR R11,[R0,#12] ; load my wkspace ptr
 LDR R12,[R0,#16] ; load zap's wkspace ptr
 CMP R6,#&3C
 MOVCS R4,#&3C
 MOVCC R4,R6
 SUB R6,R6,R4
 STR R6,[R0]			; new length.
 ADD R5,R5,R4
 STR R5,[R0,#4]			; remaining pointer...
 LDR R0,[R0,#8]
 FNcall Zap_ConvFileOff
 CMP R9,#0
 BEQ notagain$l
 ADD R5,R4,#24+3		; header size
 BIC R5,R5,#3			; and word align for message size
 FNLDR R0,buf_detoken		; message buffer
 MOV R1,R7
 ADD R2,R0,#24
 MOV R3,R4
 FNcall Zap_MoveBytes		; copy data into message buffer
 FNLDR R1,buf_detoken
 STR R5,[R1,#0]			; message size
 MOV R0,#0
 STR R0,[R1,#12]		; my ref
 LDR R0,input$l
 STR R0,[R1,#16]		; message
 STR R4,[R1,#20]		; size of input data
 MOV R0,#17

 LDR R2,[R9,#f_source]		; buffer pointer
 LDR R2,[R2]
 SWI XWimp_SendMessage		; send the data
 CMP R6,#0
 BLE notagain$l
 MOV R1,#-2
 ADR R2,callback_tw_insert
 FNcall Zap_CallBack
 FNRTS
notagain$l
 LDR R0,local_claimed_wkspace
 FNcall Zap_Free
 MOV R0,#0
 STR R0,local_claimed_wkspace
 FNRTS

escaped$l
 LDR R0,local_claimed_wkspace
 MOV R6,#1
 MOV R5,#20
 MOV R14,#27
 STRB R14,[R0,R5]
 B oninthere$l

;E R9=task window file
;X file task killed DB #

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Output to a taskwindow screen				     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Internal R1=current line width		R2=cursor x
;	  R3=cursor y			R4=data
;	  R5=number of data bytes	R6=current offset
;	  R7=taskwindow buffer

;E R2=num R3=data R7=taskwidow buffer R8/R9
;X characters entered into file #

taskwindow_output_char
 LDR R0,[R9,#f_source]
 LDR R0,[R0,#52]
 TST R0,#1<<4
 MOVNE PC,R14
 FNJSR "R1-R6"
 MOV R4,R3			; save data
 MOV R5,R2			; save num
 LDR R2,[R7,#4]			; 'scn' cursor x
 LDR R3,[R7,#8]			; 'scn' cursor y
ta10
 STR R2,[R7,#4]
 STR R3,[R7,#8]			; save cursor posn
 BL twc_buf_xy_maybepad		; R2/R3=work x,y
 BLVC tw_findoffset		; R6=start off R1=line len
 FNRTS VS
 LDR R2,[R7,#4]			; 'scn' cursor x
 LDR R3,[R7,#8]			; 'scn' cursor y
 CMP R1,R2
 BLLT tw_padd_x			; add spaces to get column here
 FNRTS VS
 CMP R1,R2
 BLGT tw_overwrite		; overwrite some chars
 BLVC tw_add			; add remaining chars
 FNRTS VS	; 'till reach txt window max
 CMP R5,#0			; finished?
 BLE ta11
 ADD R3,R3,#1			; move to next line
 LDR R2,[R7,#16]		; move to left hand edge
 LDR R1,[R7,#28]		; y max
 CMP R3,R1
 BLT ta10			; still in window
 MOV R0,#1
 BL tw_scroll_up		; scroll the window up one line
 FNRTS VS
 SUB R3,R1,#1
 B ta10				; carry on
ta11
 STR R2,[R7,#4]
 STR R3,[R7,#8]			; save cursor posn
 FNRTS

 LOCAL

;E R2/R3=work area x,y
;X R6=line offset start R1=line width #

tw_findoffset
 FNJSR "R2-R3"
 LDR R14,[R8,#w_height]
 CMP R3,R14
 BCS beyondend$l
 FNcall Zap_FindOffset
 FNRTS VS
 MOV R6,R1			; line start
 MOV R2,R0			; current offset
 LDR R3,[R9,#f_len]
loop$l
 CMP R2,R3
 SUBCS R1,R2,R6
 FNRTS CS
 MOV R0,R2
 BL cln_readc
 TEQ R0,#&0A
 ADDNE R2,R2,#1
 BNE loop$l
 SUB R1,R2,R6
 FNRTS

beyondend$l
 LDR R6,[R9,#f_len]
 MOV R1,#0
 FNRTS


;E R0=current window height R3=cusor y
;X file length padded #

tw_padd_y
 FNJSR "R1-R3"
 SUB R2,R3,R0
 ADD R2,R2,#1			; number of lines to add in
 MOV R0,#&0A			; char to add
 BL tw_getblanks
 MOVVC R0,#1			; insert
 LDRVC R1,[R9,#f_len]		; at end
 FNcallc Zap_DoCommand,VC	; insert extra lines
 FNRTS

tw_padd_x
 FNJSR "R1-R3"
 SUB R2,R2,R1			; number of spaces to add in
 ADD R1,R6,R1			; offset to add it at
 MOV R0,#&20			; char to add
 BL tw_getblanks
 FNRTS VS
 MOV R0,#1			; insert
 FNcall Zap_DoCommand		; insert extra spaces
 FNRTS VS
 FNPULL
 MOV R1,R2			; now cursors matched
 MOV PC,R14

;E R0=char R2=num
;X R3=buf_detoken containg R2*char in R0 #

tw_getblanks
 FNJSR "R1-R2"
 MOV R3,R0			; save char
 FNLDR R0,buf_detoken
 MOV R1,R2
 FNcall Zap_Ensure
 FNRTS VS
 FNSTR R0,buf_detoken
 MOV R1,R0			; buffer
 MOV R0,R3			; char
 MOV R3,R1			; save buffer pointer
 BL strstr
 FNRTS

tw_overwrite
 FNJSR "R1-R3"
 SUB R1,R1,R2			; num could be overwitten (>0)
 LDR R0,[R7,#24]
 SUB R0,R0,R2			; num cols left in text window
 CMP R0,R1
 MOVGT R0,R1			; num could print
 CMP R0,R5
 MOVGT R0,R5			; num can overwrite
 CMP R0,#0			; any left?
 FNRTS LE
 ADD R1,R6,R2			; offset
 MOV R2,R0			; number
 MOV R3,R4			; data
 MOV R0,#3			; replace
 FNcall Zap_DoCommand
 FNRTS VS
 MOV R0,R2			; save number done
 FNPULL
 ADD R4,R4,R0
 SUB R5,R5,R0
 ADD R2,R2,R0			; update vals
 MOV PC,R14

tw_add
 FNJSR "R1-R3"
 LDR R0,[R7,#24]
 SUB R0,R0,R2			; num cols left
 CMP R0,R5
 MOVGT R0,R5			; num can insert
 CMP R0,#0
 FNRTS LE
 ADD R1,R6,R2			; offset
 MOV R2,R0			; number
 MOV R3,R4			; data
 MOV R0,#1			; insert
 FNcall Zap_DoCommand
 FNRTS VS
 MOV R0,R2			; save number done
 FNPULL
 ADD R4,R4,R0
 SUB R5,R5,R0
 ADD R2,R2,R0
 MOV PC,R14

;E R0=num of lines R7=buf R8/R9
;X window scrolled up by R0 lines #

tw_scroll_up
 FNJSR "R1-R5"
 MOV R1,R0			; save number of lines
 LDR R14,[R7,#16]
 TEQ R14,#0
 LDR R14,[R7,#20]
 TEQEQ R14,#0
 LDR R14,[R7,#24]
 LDR R0,[R8,#w_bpl]
 TEQEQ R0,R14
 LDR R14,[R7,#28]
 LDR R0,[R7,#12]
 TEQEQ R0,R14
 BNE tw18			; window not full size
 LDR R0,[R7,#56]
 ADD R0,R0,R1
 STR R0,[R7,#56]		; scroll whole screen
 FNRTS
tw18
 LDR R2,[R7,#16]		; min x
 LDR R3,[R7,#20]		; top line of window
 LDR R4,[R7,#24]		; max x
 LDR R5,[R7,#28]		; bottom
 SUB R4,R4,R2			; width
tw27
 CMP R3,R5			; finished?
 FNRTS CS
 ADD R3,R3,R1			; line to get from
 BL tw_getline			; read line data
 SUBVC R3,R3,R1			; line to write to
 BLVC tw_putline		; write
 ADDVC R3,R3,#1			; move to next line
 BVC tw27
 FNRTS

;E R2=x off R3=y off R7=buffer R8/R9
;X R0=char at this posn

tw_getchar
 FNJSR "R1-R6"
 MOV R5,R2			; save x value
 BL twc_to_xy_nopad		; get work xy
 BLVC tw_findoffset		; R6=line start R1=line width
 FNRTS VS
 CMP R5,R1
 MOVCS R0,#&20
 ADDCC R0,R6,R5
 BLCC cln_readc
 FNRTS

;E R2=x off R3=y off R7=buffer R8/R9
;X cursor incremented by 1 character with wrap

tw_increment
 ADD R2,R2,#1
 LDR R0,[R7,#24]
 CMP R2,R0
 MOVCC PC,R14
 LDR R2,[R7,#16]
 ADD R3,R3,#1
 LDR R0,[R7,#28]
 CMP R3,R0
 LDRCS R3,[R7,#20]
 MOV PC,R14

;E R2=x off R3=y off R4=width R7=buffer R8/R9
;X line data read to buf_detoken ; blanks if outside window #

tw_getline
 LDR R0,[R7,#20]		; min y
 CMP R3,R0
 BLT tw32
 LDR R0,[R7,#28]		; max y
 CMP R3,R0
 BGE tw32
 FNJSR "R1-R6"
 FNLDR R0,buf_detoken
 MOV R1,R4
 FNcall Zap_Ensure
 FNRTS VS
 FNSTR R0,buf_detoken
 MOV R5,R2			; save x val
 BL twc_to_xy_nopad		; get work xy
 FNRTS VS
 BL tw_findoffset		; R6=line start R1=line width
 FNRTS VS
 MOV R2,R1			; save line width
 FNLDR R3,buf_detoken		; buffer
tw29
 CMP R4,#0			; finished ?
 FNRTS LE
 CMP R5,R2
 MOVCS R0,#&20
 ADDCC R0,R6,R5
 BLCC cln_readc
 STRB R0,[R3],#1
 ADD R5,R5,#1
 SUB R4,R4,#1
 B tw29
tw32
 FNJSR "R1-R3"
 MOV R0,#&20
 MOV R2,R4
 BL tw_getblanks		; fill buf with blanks -> R3
 FNRTS

;E R2=x off R3=y off R4=width R7=buffer R8/R9
;X line data written from buf_detoken #

tw_putline
 FNJSR "R1-R6"
 MOV R5,R2			; save x val
 BL twc_to_xy_nopad		; get work xy
 FNRTS VS
 BL tw_findoffset		; R6=line start R1=line width
 FNRTS VS
 MOV R2,R5			; restore x val
 MOV R5,R4			; save length
 FNLDR R4,buf_detoken		; get data
 CMP R1,R2
 BLLT tw_padd_x
 FNRTS VS
 CMP R1,R2
 BLGT tw_overwrite
 BLVC tw_add
 FNRTS

;E R0=num of lines R7=buf R8/R9
;X window scrolled down by R0 lines #

tw_scroll_down
 FNJSR "R1-R5"
 MOV R1,R0			; save number of lines
 LDR R14,[R7,#16]
 TEQ R14,#0
 LDR R14,[R7,#20]
 TEQEQ R14,#0
 LDR R14,[R7,#24]
 LDR R0,[R8,#w_bpl]
 TEQEQ R0,R14
 LDR R14,[R7,#28]
 LDR R0,[R7,#12]
 TEQEQ R0,R14
 BNE tw22			; window not full size
 LDR R0,[R7,#56]
 SUBS R0,R0,R1
 MOVMI R0,#0
 STR R0,[R7,#56]		; scroll whole screen
 FNRTS
tw22
 LDR R2,[R7,#16]		; min x
 LDR R5,[R7,#20]		; top line of window
 LDR R4,[R7,#24]		; max x
 LDR R3,[R7,#28]		; bottom
 SUB R4,R4,R2			; width
 SUB R3,R3,#1			; first line to write
tw28
 CMP R3,R5			; finished?
 FNRTS LT
 SUB R3,R3,R1			; line to get from
 BL tw_getline			; read line data
 ADDVC R3,R3,R1			; line to write to
 BLVC tw_putline		; write
 SUBVC R3,R3,#1			; move to next line
 BVC tw28
 FNRTS

;E R7=taskwindow buffer R8/R9
;X R2=work x R3=work y of cursor with file padded #

twc_buf_xy_maybepad
 FNJSR
 LDR R3,[R7,#56]		; screen image offset
 LDR R0,[R7,#8]			; cursor y
 ADD R3,R3,R0			; work area y
 LDR R2,[R7,#4]			; cursor x
 LDR R0,[R8,#w_margin]
 ADD R2,R2,R0
 LDR R0,[R8,#w_height]		; height in lines
 CMP R3,R0
 FNRTS CC
 BL seeifneedpad$l
 BEQ notneeded$l
 BL tw_padd_y			; CS
 FNRTS

notneeded$l
 PUSH "R1-R3"
; SWI &107
 BL tw_padd_y			; CS
 LDR R1,[R9,#f_len]		; at end
 SUB R1,R1,#1
 MOV R0,#2			; delete
 MOV R2,#1
 FNcall Zap_DoCommand
 PULL "R1-R3"
 ADD R3,R3,#1
 MOV R2,#0
 FNRTS

specialcase2$l
 LDR R0,[R8,#w_margin]
 ADD R2,R2,R0
 LDR R0,[R8,#w_height]		; height in lines
 SUB R0,R0,#1
 FNRTS

specialcase3$l
 LDR R0,[R8,#w_margin]
 ADD R2,R2,R0
 FNRTS

seeifneedpad$l
 FNJSR "R0-R3"
 LDR R0,[R9,#f_len]		; at end
 SUB R0,R0,#1
 FNcall Zap_OffLineCol		; R2 = col inc margin...
 LDR R14,[R8,#w_bpl]
 SUB R14,R14,#1
 LDR R0,[R8,#w_margin]
 ADD R14,R14,R0
 CMP R2,R14
 FNRTS CC
 MOVS R14,#0
 FNRTS

;E R7=taskwindow buffer R8/R9
;X R2=work x R3=work y of cursor with file padded #

twc_buf_xy_nopad
 FNJSR
 LDR R3,[R7,#56]		; screen image offset
 LDR R0,[R7,#8]			; cursor y
 ADD R3,R3,R0			; work area y
 LDR R2,[R7,#4]			; cursor x
 LDR R14,[R8,#w_bpl]
 CMP R2,R14
 LDR R0,[R8,#w_margin]
 ADD R2,R2,R0
 FNRTS

;E R2/R3=posn on screen R7=buffer R8/R9
;X R2=work x R3=work y of cursor with file padded #

twc_to_xy_nopad
 FNJSR
 LDR R0,[R7,#56]		; screen image offset
 ADD R3,R3,R0
 LDR R0,[R8,#w_margin]
 ADD R2,R2,R0
 FNRTS

;E R0=char R1=num params R2=num R4=params R7=buffer R8/R9
;X ctrl action taken #

taskwindow_output_ctrl
	TEQ	R0,#6
	BEQ	skip_suspend_test
	PUSH	"R0"
	LDR	R0,[R9,#f_source]
	LDR	R0,[R0,#52]
	TST	R0,#1<<4
	PULL	"R0"
	MOVNE	PC,R14
skip_suspend_test
	TEQ	R0,#&7F
	BEQ	tw_delete
	SUB	R0,R0,#6
	CMP	R0,#32-6
	ADDLO	PC,PC,R0,LSL #2
	MOV	PC,R14	; unrecognised
	B	tw_show_output
	B	tw_bell
	B	tw_backspace
	B	tw_forspace
	B	tw_lf
	B	tw_upline
	B	tw_cls
	B	tw_cr
	MOV	PC,R14 ; 14
	MOV	PC,R14 ; 15
	MOV	PC,R14 ; 16
	MOV	PC,R14 ; 17
	MOV	PC,R14 ; 18
	MOV	PC,R14 ; 19
	MOV	PC,R14 ; 20
	B	tw_hide_output
	B	tw_mode
	B	tw_vdu23
	MOV	PC,R14 ; 24
	MOV	PC,R14 ; 25
	B	tw_restore_window
	MOV	PC,R14 ; 27
	B	tw_define
	MOV	PC,R14 ; 29
	MOV	PC,R14 ; 30
	B	tw_tab
	MOV	PC,R14			; not recognised

tw_hide_output
	FNJSR
	LDR	R14,[R9,#f_source]
	LDR	R0,[R14,#52]
	ORR	R0,R0,#1<<4
	STR	R0,[R14,#52]
	FNRTS

tw_show_output
	FNJSR
	LDR	R14,[R9,#f_source]
	LDR	R0,[R14,#52]
	BIC	R0,R0,#1<<4
	STR	R0,[R14,#52]
	FNRTS

tw_vdu23
 FNJSR "R1-R11"
 LDRB R0,[R4],#1		; get reason code
 TEQ R0,#7
 FNRTS NE

tw_scrollwindow
 LDRB R0,[R4],#1		; extent (window/screen)
 LDRB R0,[R4],#1		; direction
 CMP R0,#4
 SUBCS R0,R0,#4
 TEQ R0,#3
 BEQ tws_up
 TEQ R0,#2
 FNRTS NE
tws_down
 MOV R0,#1
 BL tw_scroll_down
 FNRTS
tws_up
 MOV R0,#1
 BL tw_scroll_up
 FNRTS

tw_mode
 FNJSR "R1-R3"
 MOV R0,#&12			; delete
 MOV R1,#0
 LDR R2,[R9,#f_len]
 FNcall Zap_DoCommand		; whole file
 FNcallc Zap_StopOp,VC		; stop operation
 FNRTS VS
 LDRB R0,[R4]			; proposed mode
 BL taskwindow_mode		; R2/R3=x,y
 STRVC R3,[R7,#12]		; new screen height
 FNcallc Zap_SaveWinStatus,VC	; NOT NOW IN AN OP
 FNRTS VS
 FNLDR R0,mode_taskwindow
 ADD R14,R8,#w_mode0
 LDR R0,[R14,R0,LSL#2]!
 MOV R0,R0,LSR#16
 ADD R0,R2,R0,LSL#16
 STR R0,[R14]			; bung in new width
 FNcall Zap_NewWinStatus	; reopen the window
 BLVC tw_restore_window
 FNcallc Zap_StartOp,VC		; restart operations
 FNRTS

;E R8,#w_bpl is new proposed width R9
;X Screen cleared and taskwindow block initialised for new width #

tw_newwidth
 FNJSR "R1-R11"
 FNLDR R14,mode_taskwindow
 LDR R0,[R9,#f_cmode]
 TEQ R0,R14
 FNRTS NE
 LDR R7,[R9,#f_source]
 MOV R0,#0
 STR R0,[R7,#56]		; emul screen offset
 MOV R0,#&12			; delete
 MOV R1,#0
 LDR R2,[R9,#f_len]
 FNcall Zap_DoCommand		; whole file
 BLVC tw_restore_window
 FNRTS

tw_define
 FNJSR "R1-R3"
 LDRB R2,[R4]			; min x
 LDRB R3,[R4,#3]		; min y
 LDRB R0,[R4,#2]
 ADD R0,R0,#1			; max x
 LDRB R1,[R4,#1]
 ADD R1,R1,#1			; max y
 CMP R2,R0
 CMPLT R3,R1
 FNRTS GE
 LDR R14,[R7,#12]		; screen height
 CMP R1,R14
 FNRTS GT
 LDR R14,[R8,#w_bpl]
 CMP R0,R14
 FNRTS GT
 STR R2,[R7,#16]
 STR R3,[R7,#20]
 STR R0,[R7,#24]
 STR R1,[R7,#28]		; set window defn
 STR R2,[R7,#4]
 STR R3,[R7,#8]			; and put cursor at top left
 FNRTS

tw_tab
 FNJSR "R2-R3"
 LDRB R0,[R4]			; tab x
 LDR R2,[R7,#16]		; min x
 LDR R14,[R7,#24]
 SUB R14,R14,R2			; width x
 CMP R0,R14
 FNRTS CS
 ADD R2,R2,R0
 LDRB R0,[R4,#1]
 LDR R3,[R7,#20]		; min y
 LDR R14,[R7,#28]
 SUB R14,R14,R3			; height y
 CMP R0,R14
 FNRTS CS
 ADD R3,R3,R0
 STR R2,[R7,#4]
 STR R3,[R7,#8]			; cursor x,y
 FNRTS

tw_cls
 FNJSR "R1-R4"
 LDR R1,[R7,#16]		; min x
 LDR R2,[R7,#24]		; max x
 SUB R2,R2,R1			; width
 MOV R4,R2			; save width
 MOV R0,#&20			; char
 BL tw_getblanks		; R3=buf detoken
 FNRTS VS
 MOV R2,R1			; min x
 LDR R3,[R7,#20]		; min y
 STR R2,[R7,#4]
 STR R3,[R7,#8]			; reset cursor
 LDR R1,[R7,#28]		; max y
tw30
 CMP R3,R1
 FNRTS CS	; finished
 BL tw_putline			; blank that line
 ADDVC R3,R3,#1
 BVC tw30
 FNRTS

tw_cr
 LDR R0,[R7,#16]		; window minx
 STR R0,[R7,#4]			; cursor x
 MOV PC,R14

tw_forspace
 FNJSR "R1-R2"
 LDR R1,[R7,#4]			; x coord
 ADD R1,R1,R2			; new column
 MOV R2,#0			; num lines to move down
 LDR R0,[R7,#24]		; maxx
 LDR R14,[R7,#16]		; minx
 SUB R14,R0,R14			; width
tw20
 CMP R1,R0
 ADDGE R2,R2,#1
 SUBGE R1,R1,R14		; move down a line
 BGE tw20
 STR R1,[R7,#4]			; new column
 CMP R2,#0
 BLGT tw_lf			; move down some rows
 FNRTS

tw_lf
 FNJSR "R1"
 BL tw_insertlinefeeds		; insert some LFs...
 LDR R0,[R7,#8]
 ADD R0,R0,R2			; move down R2 lines
 LDR R1,[R7,#28]		; max y
 CMP R0,R1
 STRLT R0,[R7,#8]
 BLT noscrollupneeded$l
 SUB R0,R0,R1
 ADD R0,R0,#1			; number of lines to scroll
 BL tw_scroll_up
 SUBVC R0,R1,#1
 STRVC R0,[R7,#8]		; new y
noscrollupneeded$l
 BLVC tw_showcursor		; make sure cursor visible etc....????
 FNRTS

tw_backspace
 FNJSR "R1-R2"
 LDR R1,[R7,#4]			; x coord
 SUB R1,R1,R2			; new column
 MOV R2,#0			; num lines to move up
 LDR R14,[R7,#24]		; maxx
 LDR R0,[R7,#16]		; minx
 SUB R14,R14,R0			; width
tw23
 CMP R1,R0
 ADDLT R2,R2,#1
 ADDLT R1,R1,R14		; move down a line
 BLT tw23
 STR R1,[R7,#4]			; new column
 CMP R2,#0
 BLGT tw_upline			; move up some rows
 FNRTS

tw_upline
 FNJSR "R1"
 LDR R0,[R7,#8]
 SUB R0,R0,R2			; move down R2 lines
 LDR R1,[R7,#20]		; min y
 CMP R0,R1
 STRGE R0,[R7,#8]
 FNRTS GE
 SUB R0,R1,R0			; num lines to scroll down
 BL tw_scroll_down
 FNRTS VS
 MOV R0,R1
 STR R0,[R7,#8]			; new y
 FNRTS

tw_bell
 FNJSR
 SWI &20107
 FNRTS

tw_restore_window
 FNJSR
 MOV R0,#0
 STR R0,[R7,#4]			; cursor x
 STR R0,[R7,#8]			; cursor y
 STR R0,[R7,#16]		; min x
 STR R0,[R7,#20]		; min y
 LDR R0,[R8,#w_bpl]
 STR R0,[R7,#24]		; max x
 LDR R0,[R7,#12]
 STR R0,[R7,#28]		; max y
 FNRTS

tw_delete
 FNJSR "R1-R6"
 MOV R5,R2			; save num
 LDR R2,[R7,#4]
 LDR R3,[R7,#8]
tw19
 STR R2,[R7,#4]
 STR R3,[R7,#8]
 BL twc_buf_xy_nopad		; R2/R3=work x,y
 BLVC tw_findoffset		; R6=start off R1=line len
 FNRTS VS
 LDR R2,[R7,#4]			; scn x
 LDR R3,[R7,#8]			; scn y
 CMP R1,R2
 BLLT tw_unpadd_x
 FNRTS VS
 CMP R1,R2
 BLGT tw_blank
 FNRTS VS
 CMP R1,R2
 BLEQ tw_delchar
 FNRTS VS
 CMP R5,#0			; finished
 BLE tw21			; yes
 SUB R3,R3,#1			; move to previous line
 LDR R2,[R7,#24]		; move to rhs edge
 LDR R1,[R7,#20]		; y min
 CMP R3,R1
 BGE tw19			; do next line
 MOV R0,#1
 BL tw_scroll_down
 MOVVC R3,R1
 BVC tw19
 FNRTS
tw21
 STR R2,[R7,#4]
 STR R3,[R7,#8]			; save cursor posn
 FNRTS

tw_unpadd_x
 FNJSR
 SUB R0,R2,R1			; num chars to unpadd>0
 LDR R14,[R7,#16]		; window lhs
 SUB R14,R2,R14
 CMP R0,R14
 MOVGT R0,R14			; num could unpadd
 CMP R0,R5
 MOVGT R0,R5			; num want to unpadd
 CMP R0,#0
 SUBGT R5,R5,R0
 SUBGT R2,R2,R0
 FNRTS

tw_blank
 FNJSR "R1-R3"
 LDR R14,[R7,#16]		; window lhs
 SUB R0,R2,R14			; number could blank
 CMP R0,R5
 MOVGT R0,R5			; num want to blank
 CMP R0,#0
 FNRTS LE
 ADD R1,R6,R2			; current offset
 MOV R2,R0			; num
 SUB R1,R1,R2			; offset to blank at
 MOV R0,#&20			; blank with spaces
 BL tw_getblanks
 MOVVC R0,#3			; replace
 FNcallc Zap_DoCommand,VC
 MOVVC R0,R2			; save number blanked
 FNPULL
 SUBVC R2,R2,R0
 SUBVC R5,R5,R0
 MOV PC,R14

;\E R2 = column?
;   R5 = max value which could be deleted?
tw_delchar
 FNJSR "R1-R5"
 LDR R14,[R7,#16]		; window lhs
 SUB R0,R2,R14			; number could delete
 CMP R0,R5
 MOVGT R0,R5			; num want to delete
 CMP R0,#0
 FNRTS LE	; um error...?
 ADD R1,R6,R2			; current offset
 MOV R2,R0			; num
 SUB R1,R1,R2			; offset to delete at
 MOV R0,#2			; delete
 FNcall Zap_DoCommand
 MOVVC R0,R2			; save number deleted
 FNPULL
 SUBVC R2,R2,R0
 SUBVC R5,R5,R0
 SUBVC R1,R1,R0
 MOV PC,R14

tw_insertlinefeeds
 FNJSR "R1-R11"
 FNcall Zap_FindInput
 FNRTS VS
 MOV R7,R0
 LDR R0,[R9,#f_len]
 PUSH "R9"
 FNLDR R9,mode_taskwindow
 MOV R11,#e_linestart
 FNcall Zap_BaseMode
 PULL "R9"
 FNRTS VS
 CMP R7,R0
 FNRTS CC
; SWI &107
 CMP R2,#7
 MOVCS R2,#7
 LDR R1,[R9,#f_len]
 ADR R3,eighttens$l
 MOV R0,#1
 FNcall Zap_DoCommand
 FNRTS
eighttens$l
 DCD &0A0A0A0A
 DCD &0A0A0A0A

;E R0=mode number/-1 for current
;X R2=screen width R3=screen height in chars #

taskwindow_mode
 FNJSR "R1,R4"
 MOV R4,R0			; save mode
 MOV R1,#2
 SWI XOS_ReadModeVariable
 ADDVC R3,R2,#1			; height
 MOVVC R0,R4
 MOVVC R1,#1
 SWIVC XOS_ReadModeVariable
 ADDVC R2,R2,#1			; width
 FNRTS

 DCD	&8017
Cmdtaskwindowflagstoggle
 CMP	 R0,#0
 MOVLE	 PC,R14
 LDR	 R10,[R0]		; REM gets word argument...

 ADRL	 R1,localcopyof_mode_taskwindow
 LDR	 R1,[R1]
 CMP	 R1,#0
 MOVLE	 PC,R14

 FNJSR
 PUSH	 "R1-R11"
 FNcall  Zap_GetModeWord
 PULL	 "R1-R11"
 MOV	 R7,R0

 CMP	 R2,#15
 BEQ	 but_tickquery		; REM bit 15 of R2 indicates a 'tickquery'

 MOV	 R5,#0

 AND	 R1,R10,#&FF
 BL	 bas_execute
 MOV	 R1,R10,LSR #8
 AND	 R1,R1,#&FF
 TST	 R1,#&80
 BLNE	 bas_execute
 MOV	 R1,R10,LSR #16
 AND	 R1,R1,#&FF
 TST	 R1,#&80
 BLNE	 bas_execute
 MOV	 R1,R10,LSR #24
 AND	 R1,R1,#&FF
 TST	 R1,#&80
 BLNE	 bas_execute

 MOV	 R0,R7
 ADRL	 R1,localcopyof_mode_taskwindow
 LDR	 R1,[R1]
 FNcall  Zap_PutModeWord
 FNRTS

 LOCAL

local_stored_cur_posn
 DCD -1
 DCD 0
 DCD 0
 DCD 0
 DCD 0
 DCD 0
 DCD 0

mode12_click
 FNJSR "R1-R7"
 TST R4,#9			; Adjust or drag?
 MOVNE R0,#0
 BNE adjordrag$l

 PUSH "R1-R10"
 MOV R1,#10
 FNcall Zap_ReadVar
 TEQ R0,#1			; cursor mode not 1?
 MOVNE R0,#21			; if so, force Ctrl and callback
 BNE store$l
 ; test to see if on previous logical line...
 MOV R1,#6			; car_input
 FNcall Zap_ReadVar		; get Zap's R10 cursor pointer
 MOV R1,R0
 FNcall Zap_GetWindOff
 LDR R14,[R1,#c_wind]
 TEQ R0,R14			; cursor in different window?
 MOVNE R0,#0;1<<31		; if so, no forced Ctrl but call back
 BNE store$l
 LDR R4,[R1,#c_col]
 LDR R5,[R1,#c_line]
 BL chkvalidity$l
 MOVEQ R0,#21+(1<<31)
 MOVNE R0,#0
store$l
 PULL "R1-R10"
adjordrag$l
 STR R0,local_stored_cur_posn + 24

 LDR R14,local_stored_cur_posn
 CMP R14,#-1
 BNE in_progress_clk
 BL z_d_clk
 MOV R1,#10 ; car_mode
 FNcall Zap_ReadVar
 CMP R0,#1
 FNRTS NE
 LDR R1,[R9,#f_source]
 LDR R2,[R1,#4]			; #4 Cursor x coordinate
 LDR R3,[R1,#8]			; #8 Cursor y coordinate
 LDR R14,[R1,#56]		; #8 y coordinate start of screen
 ADD R3,R3,R14

 ADR R14,local_stored_cur_posn
 LDR R4,[R14,#24]
 BICS R4,R4,#&FF
 STMEQIA R14,{R2,R3,R8,R9,R11,R12}
; set up a callback to reposition the cursor when buttons are released :-/
 BLEQ callback_cur_posn

 FNRTS

in_progress_clk
 BL z_d_clk
 FNRTS

z_d_clk
 FNJSR "R9,R10,R11"
 FNLDR R9,mode_taskwindow
 MOV R11,#e_click
 FNcall Zap_BaseMode
 FNRTS

callback_cur_posn
 FNJSR "R0-R12"
 LDR R11,local_stored_cur_posn + 16
 LDR R12,local_stored_cur_posn + 20
 FNLDR R1,buf_detoken		; scrap... :/
 SWI XWimp_GetPointerInfo
 LDR R1,[R1,#8]
 CMP R1,#0
 BEQ at_the_end_so_pos
 MOV R1,#-2
 ADR R2,callback_cur_posn
 FNcall Zap_CallBack
 FNRTS

at_the_end_so_pos
 ;LDR R0,local_stored_cur_posn
 LDR R8,local_stored_cur_posn + 8
 LDR R9,local_stored_cur_posn + 12
 MOV R1,#5			; car_cursor
 FNcall Zap_ReadVar		; get Zap's R10 cursor pointer
 MOV R10,R0
 LDR R4,[R10,#c_col]
 LDR R5,[R10,#c_line]
 LDR R2,local_stored_cur_posn + 0
 LDR R3,local_stored_cur_posn + 4
 MOV R14,#-1
 STR R14,local_stored_cur_posn
 BL maybe_adjust		; returns EQ of done everything.
 FNRTS EQ			; all ok and done: some movement happened...
 FNcall Zap_FindOffset
 FNcall Zap_JumptoOffset
 FNRTS

; this needs to be done in a callback to prevent TW module messups!

;E R2,R3,R4,R5,R8,R9
maybe_adjust
 FNJSR ; not needed "R2,R3,R6"
 BL chkvalidity$l
 BLEQ in_maybe_adjust
 FNRTS

in_maybe_adjust
 FNJSR "R0-R11"
 LDR R7,[R9,#f_source]
 LDR R6,[R7,#16]		; #16 Emulated text window (VDU 28) min x
 LDR R14,[R7,#24]		; #24 Emulated text window (VDU 28) max x
 SUB R6,R14,R6			; 'real' width
 SUB R5,R3,R5
 MUL R5,R6,R5
 ; r5 now used :/
 SUBS R6,R2,R4
 ADDS R5,R5,R6
 BEQ endnoteq$l

 BLPL checktoseeifinprompt
 BPL endnoteq$l ; endeq$l

 CMP R5,#0
 MOVPL R3,#&8C00
 MOVMI R3,#&8D00
 RSBMI R5,R5,#0

 ORR R3,R3,R3,LSL #16
 MOV R0,R5,LSL#1		; total length
 ADD R0,R0,#12
 FNcall Zap_Claim		; reserve memory
 FNRTS VS
 MOV R7,R0
 MOV R5,R5,LSL #1
 ADD R2,R5,#7
 BIC R2,R2,#3
loop$l
 STR R3,[R7,R2]
 SUBS R2,R2,#4
 BPL loop$l
 BL twmode_char
 MOV R0,R7
 FNcall Zap_Free
endeq$l
 MOVS R0,#0			; EQ...
 FNRTS

endnoteq$l
 MVNS R0,#0			; NE...
 FNRTS

; returns PL if in prompt
checktoseeifinprompt
 FNJSR "R0,R1"
 LDR R0,[R7]			; #16 Task handle
 SWI XLineEditor_ReadInfo	; R0 LL - R1 cur pos.
 BVS unklineedit$l
 CMP R0,#0
 BMI unklineedit$l
 CMP R5,R1
 BGT inprompt$l
unklineedit$l
 MOVS R14,#-1
 FNRTS
inprompt$l
 SUBS R14,R14,R14
 FNRTS

;E 2,3 /4,5
;X NE if not on same logical line.
chkvalidity$l
 FNJSR "R0-R3,R7"
 BL foandretr0
 MOV R7,R0			; one...
 MOV R2,R4
 MOV R3,R5
 BL foandretr0
 CMP R0,R7
 FNRTS

foandretr0
 FNJSR "R1,R4"			; ???
 FNcall Zap_FindOffset
 FNcall Zap_OffsetLine
 MOV R0,R2
 FNRTS

twmode_interrogate
 CMP R0,#11
 MOVEQ PC,R14
 CMP R0,#1
 CMPNE R0,#2
 CMPNE R0,#7
 CMPNE R0,#13		; sayt
 CMPNE R0,#22		; confine?
 CMPNE R0,#23		; confine?
 CMPNE R0,#24		; confine?
 MOVEQ R0,#0
 MOVEQ PC,R14
 CMP R0,#21			; drags are ctrl-drags...?
 LDREQB R0,local_stored_cur_posn + 24
 MOVEQ PC,R14
 CMP R0,#14		; what mode type?
 MOVEQ R0,#3		; TW
 MOVEQ PC,R14
 CMP R0,#0
 CMPNE R0,#3
 MOVNE PC,R14
 MOV R0,R1
 MOV PC,R14

 END
