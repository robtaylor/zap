/*
 * $Id: cshow,fff,v 1.1 1999-06-21 17:41:53 james Exp $
 * cshow.c
 * (c) James Aylett 1999
 *
 * display/edit contents of a Zap config file
 * won't work with blocks on non-integer numbers of words (but this should never happen anyway)
 * the bit which actually deals with the config file is fairly horrible, frankly. Don't go
 * investigating it assuming it'll help you figure out how to access Zap's config files ...
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "coopt.h"

#define MAX_MODENAME_LENGTH 10
#define VERSION_STRING "cshow v0.01 (c) James Aylett 1999"

/* eek, global variable ... */
int writing=1;

void do_error(char *);
int do_fill_byte(void *, FILE *, FILE *);
int do_fill_word(void *, FILE *, FILE *);

#define fill_byte(a, b) do_fill_byte(a, b, out);
#define fill_word(a, b) do_fill_word(a, b, out);

int main(int argc, char const * const * argv)
{
  FILE *in=NULL, *out=NULL;
  int type;

  struct coopt_option option[10];
  struct coopt_state state;
  struct coopt_return ret;
  int verboseflag=0, terseflag=0, pruneflag=0, deleteflag=0;
  int usagemode=0;

#define use_listmodes usagemode==1
#define use_dumpfile usagemode==2
#define use_deletemode deleteflag==1

  char const * infile=NULL;
  char const * outfile=NULL;
  char const * deletemode=NULL;

  option[0].short_option='i';
  option[0].has_param=COOPT_REQUIRED_PARAM;
  option[0].long_option="input";

  option[1].short_option='v';
  option[1].has_param=COOPT_NO_PARAM;
  option[1].long_option="verbose";

  option[2].short_option='l';
  option[2].has_param=COOPT_NO_PARAM;
  option[2].long_option="listmodes";

  option[3].short_option='d';
  option[3].has_param=COOPT_NO_PARAM;
  option[3].long_option="dumpfile";

  option[4].short_option='r';
  option[4].has_param=COOPT_REQUIRED_PARAM;
  option[4].long_option="deletemode";

  option[5].short_option='o';
  option[5].has_param=COOPT_REQUIRED_PARAM;
  option[5].long_option="output";

  option[6].short_option='t';
  option[6].has_param=COOPT_NO_PARAM;
  option[6].long_option="terse";

  option[7].short_option='p';
  option[7].has_param=COOPT_NO_PARAM;
  option[7].long_option="pruneunknown";

  option[8].short_option='h';
  option[8].has_param=COOPT_NO_PARAM;
  option[8].long_option="help";

  option[9].short_option='V';
  option[9].has_param=COOPT_NO_PARAM;
  option[9].long_option="version";

  coopt_init(&state, option, 10, argc-1, argv+1);

  do
  {
    ret = coopt(&state);
    if (!coopt_is_error(ret.result))
    {
      if (ret.opt!=NULL)
      {
        switch (ret.opt->short_option)
        {
          case 'i':
            if (infile!=NULL)
              do_error("you can't specify more than one input file\n");
            infile = ret.param;
            break;
          case 'o':
            if (outfile!=NULL)
              do_error("you can't specify more than one output file\n");
            outfile = ret.param;
            break;
          case 'l':
            usagemode=1;
            break;
          case 'd':
            usagemode=2;
            break;
          case 'r':
            if (deletemode!=NULL)
              do_error("you may only specify --deletemode once\n");
            deleteflag=1;
            if ((deletemode = ret.param)==NULL)
              do_error("you must specify the mode to delete!\n");
            break;
          case 'v':
            verboseflag=1;
            break;
          case 't':
            terseflag=1;
            break;
          case 'p':
            pruneflag=1;
            break;
          case 'V':
            fprintf(stderr,"%s\n", VERSION_STRING);
            exit(0);
          case 'h':
            fprintf(stderr,"%s\n", VERSION_STRING);
            fprintf(stderr,"usage: %s [options] [--output <file] [--input] <file>\n\n", argv[0]);
            fprintf(stderr,"-i, --input <file>\tconfig file read from <file>; stdin used if not given\n\t\t\tif -i not given, a single argument will be used\n");
            fprintf(stderr,"-o, --output <file>\tfinal config file written to <file>\n\n");
            fprintf(stderr,"-l, --listmodes\t\tlist modes only (no dump, no editing)\n");
            fprintf(stderr,"-d, --dumpfile\t\ttextual file dump to stderr\n");
            fprintf(stderr,"-r, --deletemode <mode>\tdelete given mode from file\n");
            fprintf(stderr,"-p, --pruneunknown\tprune unknown blocks in file\n\n");
            fprintf(stderr,"-v, --verbose\t\tincrease verbosity of output\n");
            fprintf(stderr,"-t, --terse\t\tdecrease verbosity of output\n\t\t\t(both -v and -t gives somewhere between the two)\n");
            fprintf(stderr,"-h, --help\t\tdisplay this help message and quit\n");
            fprintf(stderr,"-V, --version\t\tdisplay version string and quit\n\n");
            exit(0);
            break;
        }
      }
      else if (coopt_is_okay(ret.result)) /* ie: it's a parameter */
      {
        if (infile==NULL)
          infile=ret.param;
        else
          do_error("you can't specify more than one input file\n");
      }
    }
  } while (coopt_is_okay(ret.result));

  if (coopt_is_error(ret.result) || ret.result==COOPT_RESULT_MISSINGPARAM)
    do_error("error in options processing\n");

  /* processing */
  if (infile==NULL || strcmp(infile, "-")==0)
    in=stdin;
  else
    in=fopen(infile, "rb");

  if (outfile!=NULL)
  {
    if (strcmp(outfile, "-")==0)
      out=stdout;
    else
      out=fopen(outfile, "wb");
  }

  if (in==NULL)
  {
    if (out!=stdout && out!=NULL)
      fclose(out);
    do_error("couldn't open input file\n");
  }

  if (out==NULL)
  {
    if (use_deletemode)
    {
      if (in!=stdin)
        fclose(in);
      do_error("couldn't open output file; REQUIRED for --deletemode\n");
    }
    else
      writing=-1; /* so the ++ and -- don't bring it up to 1, at which point we'd write */
  }

  fill_word(&type, in);
  if (strncmp((char *)&type, "Conf", 4)!=0)
    do_error("wasn't a conf file\n");

  while (!feof(in) && !ferror(in))
  {
    int done_data=0;
    int block_len;
    int which;

    if (fread(&type, 4, 1, in)!=1)
      do_error("terminated without EOF block marker\n");
    if (fread(&block_len, 4, 1, in)!=1)
      block_len=0;
    if (verboseflag)
      fprintf(stderr, "found a block of type #%i length %i\n", type, block_len);

    switch (type)
    {
      case 0: /* end */
        if (writing==1)
          fwrite(&type, 4, 1, out);
        if (use_dumpfile)
          fprintf(stderr, "end of options\n");
        break;

      case 1: /* global */
        if (writing==1)
        {
          fwrite(&type, 4, 1, out);
          fwrite(&block_len, 4, 1, out);
        }
        if (use_dumpfile)
          fprintf(stderr, "global options block\n");
        which=0;
        while (block_len>8)
        {
          int do_write=1;
          writing--;
          fill_word(&type, in);
          writing++;
          switch (which)
          {
            case 0:case 1:case 2:case 3:
              if (type!=0 && terseflag==0)
                fprintf(stderr, "\tin global options, reserved word at 0x%x wasn't zero (was 0x%8.8x)\n",
                       4*which, (unsigned int)type);
              break;
            case 4:
              if (use_dumpfile)
                fprintf(stderr, "\topt_info = 0x%8.8x\n", (unsigned int)type);
              break;
            case 5: /* char set? 0x14 */
              if (type!=0 && use_dumpfile)
                fprintf(stderr, "\told-style (pre v1.30) char set = %i\n", type);
              break;
            case 6:
              if (use_dumpfile)
                fprintf(stderr, "\tcolumn tab width = %i\n", type);
              break;
            case 7:
              if (use_dumpfile)
                fprintf(stderr, "\topt_flags = 0x%8.8x\n", (unsigned int)type);
              break;
            case 8:
              if (use_dumpfile)
                fprintf(stderr, "\topt_format = 0x%8.8x\n", (unsigned int)type);
              break;
            case 9:
              if (use_dumpfile)
                fprintf(stderr, "\tstart address = %i\n", type);
              break;
            case 10:
              if (use_dumpfile)
                fprintf(stderr, "\tstart line = %i\n", type);
              break;
            case 11:
              if (use_dumpfile)
                fprintf(stderr, "\tline spacing = %i\n", type);
              break;
            case 12:
              if (use_dumpfile)
                fprintf(stderr, "\tmargin width = %i\n", type);
              break;
            case 13:
              if (use_dumpfile)
                fprintf(stderr, "\tcursor types = %i, %i, %i, %i\n", type & 0xff, (type >> 8) & 0xff, (type >> 16) & 0xff,
                       (type >> 24) & 0xff);
              break;
            case 14:
              if (use_dumpfile)
                fprintf(stderr, "\teol mask uses %i\n", type & 0xff);
              break;
            case 15:
              if (use_dumpfile)
                fprintf(stderr, "\ttab mask uses %i\n", type & 0xff);
              break;
            case 16:
              if (use_dumpfile)
                fprintf(stderr, "\twordwrap width = %i\n", type);
              break;
            case 17:
              if (type!=0 && use_dumpfile)
                fprintf(stderr, "\told-style (pre v1.20) minibuffer colours = 0x%8.8x\n", (unsigned int)type);
              break;
            case 18:
              if (use_dumpfile)
                fprintf(stderr, "\tswitches = 0x%8.8x\n", (unsigned int)type);
              break;
            case 19:
              if (use_dumpfile)
                fprintf(stderr, "\tminibuffer bg = 0x%8.8x\n", (unsigned int)type);
              break;
            case 20:
              if (use_dumpfile)
                fprintf(stderr, "\tminibuffer fg = 0x%8.8x\n", (unsigned int)type);
              break;
            default:
              if (use_dumpfile)
                fprintf(stderr, "\teek! a word I don't understand = 0x%8.8x\n", (unsigned int)type);
              if (pruneflag==1)
              {
                fprintf(stderr, "[stripping unknown global options word]\n");
                do_write=0;
              }
              break;
          }
          if (do_write && writing==1)
            fwrite(&type, 4, 1, out);
          which++;
          block_len-=4;
        }

        done_data=1;
        break;

      case 2: /* old-style mode */
      case 3: /* new-style mode */
        writing--; /* may well not write this block ... ? */
        if (use_dumpfile)
          fprintf(stderr, "%s-style %smode block\n", (type==2)?("old"):("new"), (type==2)?("(pre v1.41) "):(""));
        { /* just a block to give us space for some more variables */
          char modename[255];
          int modelen=0;
          int done=0;
          if (use_dumpfile)
            fprintf(stderr, "\tmode name ");

          if (type==3)
          {
            modelen=0;
            do
            {
              done+=fill_byte(modename+modelen, in);
              if (modelen++>=255)
                do_error("internal overflow on mode name\n");
            } while (modename[modelen-1]!=0);

            if (modelen-1 > MAX_MODENAME_LENGTH)
              fprintf(stderr, "\tillegal length mode name (%i)\n", modelen-1);

            if (use_dumpfile || use_listmodes)
              fprintf(stderr, "%s%s", modename, (use_dumpfile)?("; "):(""));

            if (use_deletemode && strcmp(modename, deletemode)==0)
              fprintf(stderr, "[found and deleting new-style mode %s]\n", modename);
            else
            {
              /* want to write this block after all */
              if (writing==0)
              {
                fwrite(&type, 4, 1, out);
                fwrite(&block_len, 4, 1, out);
                fwrite(modename, 1, modelen, out); /* the mode name */
                writing++;
              }
            }

            if (use_dumpfile)
              fprintf(stderr, "clone base ");
            if (use_listmodes)
            {
              if (terseflag==0)
                fprintf(stderr, "\n");
              else
                fprintf(stderr, " ");
            }
          }

          modelen=0;
          do
          {
            done+=fill_byte(modename+modelen, in);
            if (modelen++>=255)
              do_error("internal overflow on mode name\n");
          } while (modename[modelen-1]!=0);

          if (modelen-1 > MAX_MODENAME_LENGTH)
              fprintf(stderr, "\tillegal length %s name (%i)\n", (type==2)?("mode"):("clone base"), modelen-1);

          if (use_dumpfile || (type==2 && use_listmodes))
            fprintf(stderr, "%s%c", modename, (use_listmodes && type==2 && terseflag==1)?(' '):('\n'));

          if (type==2)
          {
            if (use_deletemode && strcmp(modename, deletemode)==0)
              fprintf(stderr, "[found and deleting old-style mode %s]\n", modename);
            else
            {
              /* want to write this block after all */
              if (writing==0)
              {
                fwrite(&type, 4, 1, out);
                fwrite(&block_len, 4, 1, out);
                fwrite(modename, 1, modelen, out); /* the mode name */
                writing++;
              }
            }
          }

          while (done & 3)
            done+=fill_byte(&type, in);
        }

        fill_word(&block_len, in);
        if ((verboseflag || terseflag) && use_dumpfile)
          fprintf(stderr, "\tZap handled data of length %i\n", block_len);
        if (block_len==12)
        {
          if (use_dumpfile && terseflag==0)
            fprintf(stderr, "\tpre-v1.20 style\n");
          fill_word(&type, in);
          if (use_dumpfile && terseflag==0)
            fprintf(stderr, "\tmodedata #0 = 0x%8.8x\n", (unsigned int)type);
          fill_word(&type, in);
          if (use_dumpfile && terseflag==0)
            fprintf(stderr, "\twimp palette part 1 = 0x%8.8x\n", (unsigned int)type);
          fill_word(&type, in);
          if (use_dumpfile && terseflag==0)
            fprintf(stderr, "\twimp palette part 2 = 0x%8.8x\n", (unsigned int)type);
        }
        else
        {
          which=0;
          do
          {
            fill_word(&type, in);
            if (type!=-1 && use_dumpfile && terseflag==0)
              fprintf(stderr, "\tmodedata #%i = %8.8x\n", which, (unsigned int)type);
            which++;
            block_len-=4;
          } while (type!=-1);
          which=0;
          while (block_len>0)
          {
            fill_word(&type, in);
            if (use_dumpfile && terseflag==0)
              fprintf(stderr, "\tcolour #%i = 0x%8.8x\n", which, (unsigned int)type);
            which++;
            block_len-=4;
          }
        }

        fill_word(&block_len, in);
        if (use_dumpfile)
          fprintf(stderr, "\tMode handled data of length %i\n", block_len);
        if (verboseflag && use_dumpfile)
          fprintf(stderr, "\t\t");
        while (block_len--)
        {
          fill_byte(&type, in);
          if (verboseflag && use_dumpfile)
            fprintf(stderr, "[%2.2x]", type & 0xff);
        }
        if (verboseflag && use_dumpfile)
          fprintf(stderr, "\n");

        done_data=1;
        break;

      case -1: /* verbose block */
        if (writing==1)
        {
          fwrite(&type, 4, 1, out);
          fwrite(&block_len, 4, 1, out);
        }
        if (use_dumpfile)
          fprintf(stderr, "version block\n");
        if (block_len!=20 && use_dumpfile)
          fprintf(stderr, "\teek! block is wrong length!\n");
        fill_word(&type, in);
        if (use_dumpfile)
          fprintf(stderr, "\tsaved by Zap v%i.", type);
        fill_word(&type, in);
        if (use_dumpfile)
          fprintf(stderr, "%i; ", type);
        fill_word(&type, in);
        if (use_dumpfile)
          fprintf(stderr, "config format rev %i\n", type);
        done_data=1;
        break;

      default: /* error! */
        fprintf(stderr, "eek! illegal options block, type #%i length %i\n", type, block_len);
        if (writing==1)
        {
          if (pruneflag==0)
          {
            fwrite(&type, 4, 1, out);
            fwrite(&block_len, 4, 1, out);
          }
          else
          {
            writing--;
            fprintf(stderr, "[stripping unknown options block]\n");
          }
        }
        break;
    }

    if (done_data==0 && block_len>8)
    {
      if (verboseflag && use_dumpfile)
        fprintf(stderr, "\t\t");
      while (block_len-->8)
      {
        fill_byte(&type, in);
        if (verboseflag && use_dumpfile)
          fprintf(stderr, "[%2.2x]", ((char *)&type)[0]);
      }
      if (verboseflag && use_dumpfile)
        fprintf(stderr, "\n");
    }

    if (writing==0)
      writing++; /* back to normal for next block */
  }

  if (use_listmodes && terseflag==1)
    fprintf(stderr, "\n");

  if (in!=stdin)
    fclose(in);
  if (out!=NULL && out!=stdout)
    fclose(out);

  return 0;
}

int do_fill(void *ptr, size_t s, FILE *in, FILE *out)
{
  int r;
  if (feof(in) || ferror(in))
    do_error("feof() or ferror()\n");
  r = fread(ptr, s, 1, in);
  if (r==1)
  {
    if (writing==1)
      fwrite(ptr, s, 1, out);
    return 1;
  }
  else
  {
    do_error("error on read");
  }
  return 0;
}

int do_fill_byte(void *ptr, FILE *fp, FILE *out)
{
  return do_fill(ptr, 1, fp, out);
}

int do_fill_word(void *ptr, FILE *fp, FILE *out)
{
  return do_fill(ptr, 4, fp, out);
}

void do_error(char *mess)
{
  fprintf(stderr, mess);
  exit(1);
}
