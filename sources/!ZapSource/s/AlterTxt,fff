; Contains code to alter the text in the buffer.
; $Id: AlterTxt,fff,v 2.9 2002-11-28 15:17:02 christian Exp $
; -*- armasm -*-

 GET h.ZapHeader
 GET h.Heap
 GET h.Strings
 GET h.Cursors
 GET h.ModeBits
 GET h.CreateFile
 GET h.CreateWind
 GET h.Redraw
 GET h.Mode0
 GET h.MiniBuff
 GET h.SoftWrap
 GET h.StartCode
 GET h.TMTVars
 GET h.Undo
 GET h.Update

 IMPORT  err12

 EXPORT split_buffer
 EXPORT change_extent
 EXPORT cln_readc
 EXPORT cln_readw
 EXPORT cln_writew
 EXPORT copy_text
 EXPORT insert_tab
 EXPORT execute_command
 EXPORT command_primative
 EXPORT save_txt_status
 EXPORT new_txt_status
 EXPORT clip_cache
 EXPORT update_linenos
 EXPORT start_operation
 EXPORT stop_operation
 EXPORT undo_start_operation
 EXPORT undo_stop_operation
 EXPORT swap_case
 EXPORT insert_date
 EXPORT insert_string
 EXPORT insert_returns
 EXPORT pre_input
 EXPORT do_command
 EXPORT insert_chars_at
 EXPORT do_replace_area
 EXPORT replace_area
 EXPORT read_date
 EXPORT strip_spaces


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SPLITTING BUFFER FOR TEXT ENTRY			       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=file offset for new split
;  R1=minimum size of split
;  R9=file
;X file split at this offset #
	FNAME	split_buffer
split_buffer
	FNJSR	"R1-R10"
	LDR	R7,[R9,#f_len]
	CMP	R0,R7
	MOVCS	R0,R7			; clip file offset to end
	LDR	R5,[R9,#f_splits]	; current size of split
	MOV	R10,R0			; new split offset
	SUBS	R1,R1,R5		; amount to enlarge buffer by
	ADDGE	R0,R1,#file_size
	BLGE	enlarge_buffer		; make sure split large enough
	FNRTS	VS
	LDR	R4,[R9,#f_splito]
	LDR	R5,[R9,#f_splits]
	LDR	R6,[R9,#f_ptr]
	CMP	R10,R4			; compare split offsets
	FNRTS	EQ			; already split here
	BHI	down$l			; required split offset greater
	ADD	R1,R6,R10		; source
	ADD	R2,R1,R5		; dest
	SUB	R3,R4,R10		; amount to move
	B	move$l

down$l	ADD	R2,R6,R4		; dest
	ADD	R1,R2,R5		; source
	SUB	R3,R10,R4		; amount to move

move$l	SWI	XZapRedraw_MoveBytes	; BL move_bytes
	STR	R10,[R9,#f_splito]	; new offset
	ADD	R10,R10,R5
	STR	R10,[R9,#f_splite]	; new end of split
	FNRTS


	LOCAL

;E R0=signed size change (must not be < -split free)
;  R9=file
;X file buffer size changed by this amount (preserving split etc) #
;  (Affects f_bufl and f_blklen - undo stuff at the end shifted)
	FNAME	enlarge_buffer
enlarge_buffer
	FNJSR	"R1-R11"
	FNLDR	R10,file_list
	SUB	R10,R9,R10
	MOV	R10,R10,LSR#f_shift	; file offset in list
	LDR	R7,[R9,#f_blklen]	; total length of file block
	LDR	R6,[R9,#f_ptr]
	LDR	R5,[R9,#f_splite]
	LDR	R4,[R9,#f_splits]
	MOVS	R11,R0			; signed size change
	FNRTS	EQ			; no change in size
	BMI	shrink$l
	MOV	R0,R10
	ADD	R1,R7,R11
	BL	set_block_size		; enlarge the block the file sits in
	LDRVC	R0,[R9,#f_blklen]
	SUBVC	R11,R0,R7		; actual size change (word aligned!)
	LDRVC	R1,[R9,#f_ptr]		; file start
	ADDVC	R1,R1,R5		; start of second half of split
	ADDVC	R2,R1,R11		; new position
	SUBVC	R3,R7,R5		; size of second half + undo data
	SWIVC	XZapRedraw_MoveBytes	; move second half up + undo data
	B	tidy$l

shrink$l
	RSB	R11,R11,#0		; negate R11 now +ve amount to shrink by
	BIC	R11,R11,#3		; amount to shrink by word aligned
	ADD	R1,R6,R5
	SUB	R2,R1,R11
	SUB	R3,R7,R5
	SWI	XZapRedraw_MoveBytes	; move second half of split down + undo data
	MOV	R0,R10
	SUB	R1,R7,R11
	BL	set_block_size
	RSBVC	R11,R11,#0		; size change

tidy$l	ADDVC	R5,R5,R11		; set new split offsets and length
	ADDVC	R4,R4,R11
	STRVC	R5,[R9,#f_splite]
	STRVC	R4,[R9,#f_splits]	; update split end and size
	LDRVC	R0,[R9,#f_bufl]
	ADDVC	R0,R0,R11
	STRVC	R0,[R9,#f_bufl]		; update the buffer length
	FNRTS

;E R0=file off R9
;X R0=character at this offset R1 corrupted (no checking) |
	FNAME	cln_readc
cln_readc
	LDR	R1,[R9,#f_splito]
	CMP	R0,R1
	LDRCS	R1,[R9,#f_splits]
	ADDCS	R0,R0,R1
	LDR	R1,[R9,#f_ptr]
	LDRB	R0,[R1,R0]
	MOV	PC,R14


	LOCAL

;E R0=file off R8/R9
;X R0=word at this address (not nec aligned)
;  Zero bytes inserted into word if word goes off end of file
;  Endianness of work taken from R8,#w_format |
	FNAME	cln_readw
cln_readw
	FNJSR	"R1-R5"
	MOV	R3,R0			; offset
	MOV	R4,#4			; count
	LDR	R5,[R9,#f_len]		; end of file

in16	MOV	R0,R3
	CMP	R0,R5
	MOVCS	R0,#0
	BLCC	cln_readc		; read the next byte
	MOV	R2,R2,LSR #8
	ORR	R2,R2,R0,LSL #24
	ADD	R3,R3,#1
	SUBS	R4,R4,#1
	BHI	in16
	MOV	R0,R2
	LDR	R1,[R8,#w_format]
	TST	R1,#1<<17
	BLNE	reverse_word		; change to big endian
	FNRTS


;E R0=word R1=offset R8/R9
;X word replaced/inserted if at end via replace_area #
	FNAME	cln_writew
cln_writew
	FNJSR	"R1-R3"
	LDR	R2,[R8,#w_format]
	TST	R2,#1<<17
	BLNE	reverse_word
	PUSH	"R0"
	MOV	R3,R13
	LDR	R2,[R9,#f_len]
	SUBS	R2,R2,R1
	MOVMI	R2,#0
	CMP	R2,#4
	MOVCS	R2,#4
	MOV	R4,#4
	BL	replace_area
	ADD	R13,R13,#4
	FNRTS


	LOCAL

;E R0=coltab width/0 for edit tab
;  R1=num tabs R2=xcol(em) R3=yline R8/R9
;X R0=new column position after tab (exc margin) #
	FNAME	cln_tabcol
cln_tabcol
	FNJSR	"R1-R7,R10,R11"
	MOV	R4,R1			; tab count
	MOV	R6,R2			; current column
	MOV	R11,R3
	MOV	R5,R0			; tab width
	BL	offset_for_tabs
	SUBS	R10,R0,#&400
	MOVMI	R10,#0
trytabagain
	CMP	R5,#0
	BGT	cl10
	MOV	R2,R6
	MOV	R3,R11
	BL	offset_for_tabs
	FNRTS	VS			; a problem
	CMP	R0,R10
	MOVLE	R5,#8
	BLE	cl14			; no previous line so resort to coltab8
	MOV	R7,R0			; save file offset
cl11					; edit tab
	MOV	R0,R7			; file offset
	BL	cln_txt_splus
	MOVVC	R7,R0			; new offset
	BLVC	offset_line_column	; get new posn R2,R3
	FNRTS	VS
	LDR	R0,[R8,#w_margin]
	SUB	R2,R2,R0		; new col exc margin
	CMP	R2,R6
	SUBLE	R11,R11,#1
	BLE	trytabagain		; column may only increase
	MOV	R6,R2			; new column

cl12	SUBS	R4,R4,#1
	BHI	cl10			; do next tab

cl13	MOV	R0,R6			; new column
	FNRTS

cl10	CMP	R5,#0			; next tab...
	BEQ	cl11			; edit tab

cl14	MOV	R0,R6			; current col
	MOV	R1,R5			; tab width
	SWI	XZapRedraw_Divide	; BL div_mod	; R0=div
	ADD	R0,R0,#1		; next tab column
	MUL	R6,R0,R5		; new col
	B	cl12

; should returns file offset in previous logical line which is long enough
; or -1 if this doesn't exist.
; in fact returns file offset in previous physical line :(
	FNAME	offset_for_tabs
offset_for_tabs
	SUBS	R3,R3,#1		; previous /physical/(?) line
	MVNMI	R0,#0
	MOVMI	PC,R14
	LDR	R0,[R8,#w_margin]
	ADD	R2,R2,R0		; add margin for find_offset
	B	find_offset		; find file offset in R0 (from x,y)


	LOCAL

;E R0=number of chars to copy
;X That number of chars copied from cursor to input #
	FNAME	copy_text
copy_text
	FNJSR	"R1-R11"
	MOV	R1,R0			; number of bytes to copy
	BL	get_cursor_caret	; get copy caret
	MOVVC	R11,#e_aligncaret
	BLVC	call_mode		; align for the mode
	MOVVC	R0,#1			; fetch
	MOVVC	R11,#e_copy
	BLVC	call_mode		; find out what to copy
	BLVC	make_cursor_visible	; show the (input) cursor

	BLVC	get_input_caret		; find dest
	MOVVC	R0,#2
	MOVVC	R11,#e_copy
	BLVC	call_mode		; see how to enter it
	FNRTS	VS
	TEQ	R0,#0
	FNRTS	EQ			; the mode's done it all
	TEQ	R0,#2
	BEQ	co12			; it wants me to enter as if typed
	MOV	R0,#1
	LDR	R1,[R10,#c_off]
	BL	execute_command		; insert the data
	BLVC	make_cursor_visible	; highlight input caret
	FNRTS

co12	MOV	R7,R3			; data address
	MOV	R5,R2			; len
	LDR	R6,[R8,#w_format]
	LDR	R4,[R8,#w_flags]
	MOV	R11,#e_char
	BL	call_mode		; insert the chars
	FNRTS

	LOCAL


; sub for Tab command (with R0=tab mode<<9 and R5=w_flags)
	FNAME	insert_tab
insert_tab
	FNJSR
	AND	R0,R0,#3<<9		; tab mode
	CMP	R0,#2<<9
	MOVLT	R0,#0			; edit tab
	LDREQ	R0,[R8,#w_tab]		; coltab of width R0
	MVNGT	R0,#0			; auto indent tab
	LDR	R2,[R10,#c_col]
	LDR	R3,[R10,#c_line]
	LDR	R14,[R8,#w_margin]
	SUB	R2,R2,R14		; R2=col exculding margin
	BL	cln_tabcol		; get new col in R0
	FNRTS	VS
	MOV	R4,#0			; num of tabs to insert
	MOV	R3,R0			; dest column
	TST	R5,#1<<11
	BNE	ta2			; don't insert tab chars

ta3	ADD	R0,R2,#8		; into next col
	BIC	R0,R0,#7		; start of next col
	CMP	R0,R3
	ADDLE	R4,R4,#1		; add unix tab
	MOVLE	R2,R0			; new col
	BLE	ta3			; next

ta2	SUB	R5,R3,R2		; number of spaces to insert
	FNLDR	R0,wimp_kbdbuf
	ADD	R1,R4,R5		; total num of chars
	BL	heap_ensure
	FNRTS	VS
	FNSTR	R0,wimp_kbdbuf		; kbd buf now big enough
	LDRB	R2,[R8,#w_tabc]
	MOV	R3,R0			; buffer

ta4	SUBS	R4,R4,#1
	STRPLB  R2,[R3],#1
	BPL	ta4
	MOV	R2,#32

ta5	SUBS	R5,R5,#1
	STRPLB  R2,[R3],#1
	BPL	ta5

ta6	LDR	R4,[R8,#w_flags]
	MOV	R5,R1
	LDR	R6,[R8,#w_format]
	MOV	R7,R0
	MOV	R11,#e_char
	BL	call_mode
	FNRTS


	LOCAL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; E X E C U T E	  C O M M A N D				     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=command R1-R5=data R8/R9 (R8=0 if don't know which window)
;   1 Insert text		R1=off R2=num R3=data
;   2 Delete text		R1=off R2=num
;   3 Replace text forward	R1=off R2=num R3=data
;   4 Replace text backward	R1=off R2=num R3=data
;   5 Delete text backward	R1=off R2=num
;   6 Insert text backward	R1=off R2=num R3=data
;  Add &10 if you do not wish the data to be concatonated.
;  Add &20 if you do not wish the input caret to be updated to the change
;  Add &40 if the region is/was/should be selected
;X Command executed, placed in input buffer, and input caret updated to
;  the end of the block and made visible. #
;  if R0=1/5 then on exit R3=pointer to snipped text (may == wimp_data)...
	FNAME	execute_command
execute_command
	TEQ	R2,#0
	MOVEQ	PC,R14			; nothing to do
	FNJSR	"R10-R11"
	LDR	R10,[R9,#f_flags]
	MOV	R14,R10
	TST	R0,#command_DontUpdateInputCaret
	ORRNE	R14,R14,#flags_UnlinkCursor
	AND	R0,R0,#&5F		; get the primative command
	STR	R14,[R9,#f_flags]	; temporary flag format
	TEQ	R8,#0
	BEQ	ex10			; no window given
	MOV	R11,#e_command		; should preserve R10!
	BL	call_mode		; do the command (via the mode)

ex11	LDR	R14,[R9,#f_flags]
	BIC	R14,R14,#flags_UnlinkCursor
	AND	R10,R10,#flags_UnlinkCursor
	ORR	R14,R14,R10
	STR	R14,[R9,#f_flags]	; restore cursor linkage
	FNRTS				; return (possibly with error)

ex10	BL	command_primative	; no window given so use primative
	B	ex11


;E As for execute_command except called by the mode and don't need R8 #
	FNAME	command_primative
command_primative
	FNJSR	"R1-R11"
	MOV	R10,R0			; save command num
	FNLDR	R0,yank_len
	FNSTR	R0,yank_off		; null yank pointer
	BL	pre_input		; prepare for insertions (add spaces here?)
	MOVVC	R0,R10			; command num
	BLVC	do_command		; do command and get buffer data
	FNRTS	VS
	MOV	R11,R1
	MOV	R6,R2			; save length
	LDR	R7,[R9,#f_uptr]
	LDR	R14,[R9,#f_ulen]
	LDR	R1,[R9,#f_undo]
	LDR	R2,[R9,#f_undop]
	TEQ	R2,#0
	TEQEQ	R1,R14			; is undo pointer at current offset?
	MOV	R0,#0
	BLNE	buffer_command		; set up fast undo pointer
	FNRTS	VS
	LDR	R0,[R9,#f_flags]
	TST	R0,#flags_UndoSupported
	BEQ	un14
	MOV	R0,R10
	MOV	R1,R11			; command buffered if undo on or a block
	MOV	R2,R6			; delete for yank/paste command
	BL	buffer_command		; buffer the command
	FNRTS	VS

un14	MOV	R0,#0
	STR	R0,[R9,#f_undop]
	LDR	R0,[R9,#f_ulen]
	STR	R0,[R9,#f_undo]		; set up new undo pointer
	FNRTS

maybe_rapid_not_preinput
	FNJSR	"R8-R9"
	MOV	R7,R9
	FNLDR	R10,car_cursor
	LDR	R0,[R10,#c_wind]	; This code doesn't appear to work properly
	BL	conv_wind_off		; Get R8/R9
	TEQ	R7,R9
	FNRTS	EQ
	FNLDR	R10,car_input
	LDR	R0,[R10,#c_wind]	; This code doesn't appear to work properly
	BL	conv_wind_off		; Get R8/R9
	TEQ	R7,R9
	FNRTS


;E R9=file
;X caret mode and selected region status prepared for
;  insertion of text #
	FNAME	pre_input
pre_input
	FNJSR	"R10"
	LDR	R0,[R9,#f_flags]
	TST	R0,#1<<8
	BNE	pr27			; file read only
	BL	maybe_rapid_not_preinput ; a cursor in this file?
	FNRTS	NE			; return here...

pr26	FNLDR	R0,car_mode
	CMP	R0,#0
	BLGT	caret_writable		; if caret exists the make mode 1/2
	FNRTS	VS
	FNLDR	R0,opt_flags
	TST	R0,#1<<22
	FNRTS	EQ			; don't auto clear selections
	FNLDR	R0,car_selection
	LDR	R0,[R0,#c_wind]
	MOVS	R0,R0
	BLPL	clear_selection
	FNRTS

pr27	PUSH	"R0,R1"
	ADR	R0,pr_s0
	MOV	R1,#1<<29
	BL	warn_user
	PULL	"R0,R1"
	BL	err12
	FNRTS

pr_s0	FNS	("zap_ReadOnly")


	LOCAL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Command Subs						   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	INCORE  4
local_commandtypestored
	DCD	0

;E R0=command R1-R5=command data as in execute_command R9
;X Command action performed and R1-R5=undo data, input caret updated #
	FNAME	do_command
do_command
	STR	R0,local_commandtypestored ; get actual command number (0-7)
	ANDS	R0,R0,#&07		; get actual command number (0-7)
	MOVEQ	PC,R14			; pointer (don't mark changed)
	TEQ	R0,#7
	MOVEQ	PC,R14			; pointer (don't mark changed)
	FNJSR	"R0"
	STR	R0,[R9,#f_docom]	; save the command type
	STR	R2,[R9,#f_dolen]	; length of the data
	STR	R3,[R9,#f_dodata]	; pointer to the data (if applicable)
	TEQ	R0,#1
	TEQNE	R0,#6			; 1, 6 are inserts
	LDR	R0,[R9,#f_flags]
	TSTNE	R0,#1			; undo enabled? If so, we want deleted block
	FNLDR	R14,opt_switches,NE
	BICNE	R14,R14,#bit_return_deletions
	FNSTR	R14,opt_switches,NE
	STRVS	R0,[R13]
	FNRTS	VS

	LDR	R0,[R9,#f_depth]
	CMP	R0,#0
	BLGT	maybe_scrub_all_on_this_file

	FNPULL
	ADD	PC,PC,R0,LSL#2		; jump to it
	DCD	0
	MOV	PC,R14			; command 0 (pointer)
	B	insert_text		; command 1 (insert)
	B	delete_text		; command 2 (del)
	B	replace_text		; command 3 (replace for)
	B	replace_text		; command 4 (replace bac)
	B	delete_text		; command 5 (del bac) (PROTOCOL X)
	B	insert_text		; command 6 (insert bac) (PROTOCOL X)
	MOV	PC,R14			; command 7 (mulitop marker)


maybe_scrub_all_on_this_file
	LDR	R0,[R9,#f_altered]
	CMP	R0,#0
	MOVPL	PC,R14
	B	scrub_all_on_this_file


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Save And New Text Status				    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=file offset of first char to change R1=signed change
;  R2=file offset of first char to be shifted up/down R9
;  f_docom,f_dolen,f_dodata setup
;X clear carets and save txt status in each window looking at this file #
	FNAME	save_txt_status
save_txt_status
	FNJSR	"R10"
	LDR	R10,[R9,#f_depth]
	CMP	R10,#0
	BGT	save_txt_status_concat  ; concatonise (sic) operations :-)

sa10	STR	R0,[R9,#f_altered]
	STR	R1,[R9,#f_change]
	STR	R2,[R9,#f_shiftable]	; save what's happened to the file
	FNLDR	R10,car_cursor
	BL	test_fblk
	BLEQ	scrub_caret		; remove cursor caret
	FNRTS	VS
	FNLDR	R10,car_input
	BL	test_fblk
	BLEQ	scrub_caret		; remove input caret
	BLVC	get_input_window	; R0=window with input caret ; !
	ADRVC	R10,save_txt_status_wind
	BLVC	do_eachwindow		; NO DRAW OPS AFTER THIS
	FNRTS				; AS IT MAY CORRUPT THE CACHE PTR


	FNAME	save_txt_status_concat
save_txt_status_concat
	LDR	R10,[R9,#f_altered]
	CMP	R10,#0
	BMI	sa10			; continue as usual as nothing to add to
	CMP	R10,R0
	MOVGE	R10,R0			; new first altered byte
	STRGE	R10,[R9,#f_altered]
	ADR	R10,save_txt_concat_wind
	BL	do_eachwindow		; concatonate the w_* vars
	FNRTS	VS
	LDR	R14,[R9,#f_change]	; total change so far
	LDR	R10,[R9,#f_shiftable]	; old first shiftable char
	ADD	R10,R10,R14		; offset it will have been shifted to
	CMP	R10,R2
	MOVLT	R10,R2			; new first shiftable char
	SUB	R10,R10,R14		; what it would have been before
	STR	R10,[R9,#f_shiftable]
	ADD	R10,R14,R1		; new total change
	STR	R10,[R9,#f_change]	; add in this change
	FNRTS


	FNAME	new_proposed_txt_status
new_proposed_txt_status
	FNJSR	"R10-R11"
	LDR	R10,[R9,#f_depth]
	CMP	R10,#0
	BGT	new_proposed_txt_status_concat
	BL	alter_selection
	LDRVC	R0,[R9,#f_altered]	; total altered
	LDRVC	R1,[R9,#f_change]	; total change
	BLVC	alter_all_carets	; update cursor positions
	BLVC	redraw_patching_update
	BLVC	mark_proposed_new_sel	; needs R4,R5
	FNRTS

new_proposed_txt_status_concat
	BL	pre_new_txt_status_concat
	BL	mark_proposed_new_sel	; needs R4,R5
	FNRTS


;E R0=first changed R1=signed change R2=new input car off R9
;X carets & windows & markers on this file updated due to change #
	FNAME	new_txt_status
new_txt_status
	FNJSR	"R10-R11"
	LDR	R10,[R9,#f_depth]
	CMP	R10,#0
	BGT	new_txt_status_concat
	BL	alter_selection
	LDRVC	R0,[R9,#f_altered]	; first altered
	LDRVC	R1,[R9,#f_change]	; total change
	BLVC	alter_all_carets	; update cursor positions
	BLVC	redraw_patching_update
	FNRTS


	FNAME	new_txt_concat_wind
new_txt_concat_wind
	FNJSR	"R1-R2"
	LDR	R0,[R8,#w_savedo]	; current saved line offset
	LDR	R1,[R9,#f_change]	; total change so far
	ADD	R0,R0,R1		; its current offset
	BL	cln_off			; find its new physical line
	LDRVC	R1,[R8,#w_savedlc]	; previous current line
	STRVC	R0,[R8,#w_savedlc]	; new value
	SUBVC	R0,R0,R1		; change
	LDRVC	R1,[R8,#w_height]
	ADDVC	R1,R1,R0
	STRVC	R1,[R8,#w_height]	; new height
	FNRTS


	FNAME	pre_new_txt_status_concat
pre_new_txt_status_concat
	FNJSR	"R10-R11"
new_txt_status_concat
	MOV	R11,R0			; save first changed
	ADR	R10,new_txt_concat_wind
	BL	do_eachwindow		; update w_height
	MOVVC	R0,R11
	BLVC	alter_selection		; update selected area ends
	MOVVC	R0,R11
	BLVC	alter_all_carets	; update caret posns for this op
	FNRTS


call_scrub_point
	FNJSR
	BL	test_fblk
	BLEQ	scrub_point		; remove cursor caret
	FNRTS


;E f_*vars set according to change R8/R9
;  R0=window with input caret (remove point caret if not).
;X save txt status of this window #
	FNAME	save_txt_status_wind
save_txt_status_wind
	FNJSR	"R1,R11"
	TEQ	R0,R8			; has this window got input focus
	BLNE	call_scrub_point	; delete the point caret if not
	LDR	R0,[R8,#w_scrolly]	; first shiftable char
	STR	R0,[R8,#w_savedscy]	; first shiftable char
	LDR	R0,[R8,#w_height]
	STR	R0,[R8,#w_savedh]	; save window height before change
	LDR	R0,[R9,#f_altered]	; offset of first changed char
	TEQ	R0,#0
	SUBNE	R0,R0,#1		; this is the first char sure to stay fixed
	BL	clip_cache		; set cached referance point before change
	LDRVC	R0,[R9,#f_altered]	; offset of first changed char
	BLVC	getprevlineinfo
	STRVC	R0,[R8,#w_saveds]	; start of redraw offset
	LDRVC	R0,[R9,#f_shiftable]	; first shiftable char
	LDRVC	R1,[R9,#f_change]	; signed change
	MOVVC	R11,#e_nextline
	BLVC	call_mode		; find first shiftable line
	STRVC	R0,[R8,#w_savedo]	; save offset of first shiftable line
	STRVC	R1,[R8,#w_savedl]	; and phy line number of this line
	STRVC	R1,[R8,#w_savedlc]	; and current for multiop
	FNRTS


	INCORE  8
localtempr0prevline
	DCD	0
localtempr0prevline2
	DCD	0


	FNAME	getprevlineinfo
getprevlineinfo
	FNJSR
	LDR	R14,[R8,#w_format]
	ANDS	R14,R14,#1 << 27
	BEQ	simple_prevline
	PUSH	"R0-R7"			; overkill :-(
	MOV	R11,#e_prevline
	BL	call_mode		; find offset to update from
	ADDVS	R13,R13,#4
	PULL	"R1-R7",VS
	FNRTS	VS
	LDR	R0,[R13],#4
	LDMIA	R13,{R1-R7}
	STR	R14,localtempr0prevline
	BL	modesw_prevline
	STR	R0,localtempr0prevline2
	LDR	R14,localtempr0prevline
	PULL	"R1-R7"
	CMP	R14,R0
	MOVCC	R0,R14
	FNRTS

simple_prevline
	MOV	R11,#e_prevline
	BL	call_mode		; find offset to update from
	FNRTS


;E R0=first altered off R1=signed change R2=first shiftable
;  for the current operation to be concatonated R8/R9
;  f_change f_shiftable not updated, f_altered is updated
;X w_savedo and w_savedl updated due to concatonisation #
	FNAME	save_txt_concat_wind
save_txt_concat_wind
	FNJSR	"R1-R4,R11"
	MOVS	R4,R0			; fist altered char
	SUBNE	R0,R0,#1		; first char sure to stay fixed
	BL	clip_cache		; set cached ref point before change
	MOVVC	R0,R4
	BLVC	getprevlineinfo
	FNRTS	VS
	LDR	R4,[R8,#w_saveds]	; old start offset
	CMP	R0,R4
	STRLT	R0,[R8,#w_saveds]	; new start offset
	LDR	R4,[R9,#f_change]	; signed change so far
	LDR	R0,[R9,#f_shiftable]	; old first shiftable char
	ADD	R0,R0,R4		; its current posn
	CMP	R0,R2
	FNRTS	GE			; first shiftable won't change
	MOV	R0,R2			; new first shiftable
	MOV	R11,#e_nextline
	BL	call_mode		; find new shiftable line
	FNRTS	VS
	SUB	R3,R0,R4		; save new shiftable offset
	LDR	R0,[R8,#w_savedo]	; old shiftable offset
	CMP	R3,R0
	ADD	R0,R0,R4		; its current posn @@@@@
	FNRTS	LT			; no point in storing it if <= old offset...
	MOV	R4,R1			; save curr phy line of new shift
	STR	R4,[R8,#w_savedlc]	; and set as current line
	BL	cln_off			; find curr phy line of old savedo
	SUB	R4,R4,R0		; change in phy line
	LDR	R0,[R8,#w_savedl]
	ADD	R0,R0,R4
	STR	R0,[R8,#w_savedl]	; what the phy lnum would have been
	STR	R3,[R8,#w_savedo]	; new savedo
	FNRTS


;E R8/R9 (not updated)
;X window updated (and R8) and height changed WB #
	FNAME	new_txt_status_wind
new_txt_status_wind
	LDR	R0,[R9,#f_altered]	; zero start posn?
	CMP	R0,#-1
	MOVEQ	PC,R14
	FNJSR	"R1-R5"
	LDR	R0,[R8,#w_saveds]	; first byte to redraw
	BL	offset_line_column	; R2/R3=first char to redraw
	LDRVC	R4,[R8,#w_savedo]	; first saved line offset
	LDRVC	R0,[R9,#f_change]
	ADDVC	R4,R4,R0		; R4=new saved line offset
	MOVVC	R5,R2			; save first changed col
	MOVVC	R0,R4			; start of first saved line
	BLVC	cln_off			; R0=new phy of first saved
	FNRTS	VS

	MOV	R2,R5			; restore R2/R3=first changed char
	MOV	R5,R0			; R5=new phy line of first saved char
	LDR	R0,[R8,#w_savedl]	; R0=old phy line
	SUB	R1,R5,R0		; change in phy line
	STR	R1,[R8,#w_savedc]	; save this change
	LDR	R14,[R9,#f_len]
	CMP	R4,R14			; are we at file end
	ADDCS	R0,R0,#1		; if so then R5 wasn't a line start
	ADDCS	R5,R5,#1		; so move to next phy line to shift
	LDR	R14,[R8,#w_savedh]
	STR	R14,[R8,#w_height]	; restore window height before op
	BL	change_work_height	; shift the area at the bottom
	LDRVC	R4,[R8,#w_width]	; R4=last char of line !?!?!?
	BLVC	update_region		; update entered region
	MOVVC	R0,R3			; ???? ok.
	BLVC	update_linenos		; update any line numbers
	FNRTS


	LOCAL

;E R0=first line R8 (updated)/R9
;X Line numbers redrawn from this line if they exit WB #
	FNAME	update_linenos
update_linenos
	FNJSR	"R1-R3"
	LDR	R1,[R8,#w_format]
	TST	R1,#format_ShowLineNumbers
	FNRTS	EQ			; no line numbers
	MOV	R3,R0			; save first line
	FNLDR	R1,wimp_block
	FNLDR	R0,wimp_leftgap		; force left margin redraw
	RSB	R0,R0,#0
	STR	R0,[R1,#w_minx]
	LDR	R14,[R8,#w_info]
	AND	R2,R14,#7
	ADD	R2,R2,#2
	TST	R14,#8
	ADDNE	R2,R2,#2
	BL	ccd_xyline_xyos
	STR	R2,[R1,#w_maxx]
	STR	R3,[R1,#w_maxy]
	LDR	R2,[R8,#w_maxy]
	LDR	R0,[R8,#w_miny]
	SUB	R2,R2,R0		; os height visible
	LDR	R0,[R8,#w_scrolly]
	SUB	R2,R0,R2		; min y visible
	CMP	R2,R3
	FNRTS	GE			; nothing to update
	STR	R2,[R1,#w_miny]		; min y redraw
	LDR	R0,[R8,#w_handle]
	STR	R0,[R1]
	BL	update_window		; redraw
	FNRTS


;E R0=first phy line to move from R1=signed move R8 (updated)
;X changes height of window and shifts the lines R0+ from margin WB #
	FNAME	change_work_height
change_work_height
	FNJSR	"R1-R7,R10-R11"
	MOV	R10,R0			; save first line to move from
	MOVS	R11,R1			; signed move
	FNRTS	EQ			; no move
	LDR	R2,[R8,#w_margin]	; start col
	MOVS	R3,R11
	RSBMI	R3,R3,#0		; abs size of move
	BL	ccd_xyline_xyos
	FNLDR	R2,wimp_leftgap
	RSB	R2,R2,#0
	MOV	R5,R2			; R5=start os x col
	RSB	R7,R3,#0		; R7=os height of move (now +ve)
	MOV	R3,R10
	BL	ccd_yline_yos
	MOV	R10,R3			; R10=y os of first line to move
	LDR	R0,[R8,#w_scrolly]	; top of window
	CMP	R10,R0
	BGE	ch2			; whole of window to be shifted???

notch2	CMP	R11,#0
	BMI	ch1			; move negative (up)
					; move positive (down)
	LDR	R3,[R8,#w_height]
	ADD	R3,R3,R11
	STR	R3,[R8,#w_height]	; new window height
	BL	change_extent
	BLVC	ccd_workxy
	MOVVC	R6,R3			; dest min y
	MOVVC	R4,R10			; source max y
	MOVVC	R3,R2			; source max x
	ADDVC	R2,R6,R7		; source min y
	MOVVC	R1,R5			; source min x=dest min x
	LDRVC	R0,[R8,#w_handle]
	SWIVC	XWimp_BlockCopy
	FNRTS

ch1	BL	ccd_workxy		; R2/R3 =max values
	MOV	R6,R3			; dest min y
	MOV	R4,R10			; source max y
	MOV	R3,R2			; source max x
	SUB	R2,R6,R7		; source min y
	MOV	R1,R5			; source min x=dest min x
	LDR	R0,[R8,#w_handle]
	SWI	XWimp_BlockCopy
	LDRVC	R3,[R8,#w_height]
	ADDVC	R3,R3,R11		; new height as R11 -ve
	STRVC	R3,[R8,#w_height]
	BLVC	change_extent
	FNRTS

ch2	LDR	R14,local_storedreight  ; window the cursor is in (I hope)...
	CMP	R14,R8
	BEQ	notch2			; this is a bit of a fudge - I hope it's
					; called from the right spot :-/
	LDR	R3,[R8,#w_scrolly]	; (ie multiple views)
	CMP	R11,#0
	SUBPL	R3,R3,R7
	ADDMI	R3,R3,R7
	LDR	R1,[R8,#w_height]
	STR	R3,[R8,#w_scrolly]	; new window scroll offset
	ADD	R1,R1,R11		; new height as R11 -ve
	STR	R1,[R8,#w_height]
	BL	change_extent		; set new extent
	LDRVC	R3,[R8,#w_scrolly]	; store (not needed...)
	MOVVC	R1,R8			; new
	SWIVC	XWimp_GetWindowState	; get the state of the window from the WIMP
	STRVC	R3,[R8,#w_scrolly]	; restore

	BLVC	invalidate_window	; :-(
	MOVVC	R0,#0
	MOVVC	R1,R8
	BLVC	open_window		; open the window at new scroll off

	LDRVC	R0,[R8,#w_format]
	ORRVC	R0,R0,#1<<29		; causes iconisation bug?
	STRVC	R0,[R8,#w_format]	; ignore the redraws when they come??;?
	FNRTS


	LOCAL

;E R8/R9 with R8 updated
;X window extent set according to w_height if it can WB #
	FNAME	change_extent
change_extent
	FNJSR	"R1-R3"
	FNLDR	R1,wimp_block
	FNLDR	R0,wimp_leftgap		; TT fix.
	RSB	R0,R0,#0		; TT fix.
	STR	R0,[R1]			; new minx
	MOV	R0,#0
	STR	R0,[R1,#12]		; new maxy
	BL	ccd_workxy		; R2/R3=workxy
	STR	R2,[R1,#8]		; new maxx
	LDR	R14,[R8,#w_format]
	TST	R14,#bit_windowwrap	; this is now being done twice independently
	LDRNE	R14,[R8,#w_info]
	TSTNE	R14,#bit_infiniteww
	MOVNE	R14,#&8000
	STRNE	R14,[R1,#8]
	LDR	R2,[R8,#w_maxy]
	LDR	R0,[R8,#w_miny]
	SUB	R2,R2,R0		; os height visible
	LDR	R0,[R8,#w_scrolly]
	SUB	R2,R0,R2		; min y visible
	CMP	R3,R2			; is the next line right? TT.
	BGT	needtoopenwindow$l
	STR	R3,[R1,#4]		; new min y
	LDR	R0,[R8,#w_handle]
	SWI	XWimp_SetExtent
	FNRTS

needtoopenwindow$l
	STR	R3,[R1,#4]		; new min y
	LDR	R0,[R8,#w_handle]
	SWI	XWimp_SetExtent
	MOVVC	R1,R8			; NEWNEWNEW!!!
	SWIVC	XWimp_GetWindowState	; update state of window
	MOVVC	R1,R8
	BLVC	reopen_window
	FNRTS


; ;E R8=window
; ;X Force redraw called to invalidate window area #
	FNAME	invalidate_window
invalidate_window			; Tim thinks this is dirty code...
	FNJSR	"R1-R4"
	BL	ccd_workxy
	MOV	R14,R2
	LDR	R0,[R8,#w_handle]
	MOV	R1,#0			; min x
	MOV	R2,R3			; min y
	MOV	R3,R14			; max x
	MOV	R4,#0			; max y
	SWI	XWimp_ForceRedraw
	FNRTS


	LOCAL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Multiple operations concatonated				;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R9=file you are going to operate on or 0 if none
;X Operation set up. Call stop_operation to print results |
;  R0 is saved.
	FNAME	start_operation
start_operation
	FNJSR	"R0"
	CMP	R9,#0
	FNRTS	LE

	LDR	R0,[R9,#f_depth]	; current depth
	CMP	R0,#0
	ADDGT	R0,R0,#1		; increase depth
	STRGT	R0,[R9,#f_depth]	; save new depth
	FNRTS	GT			; already in an operation

	SWI	XHourglass_On		; the first time...

	LDR	R0,[R9,#f_flags]
	TST	R0,#1<<8
	MOV	R0,#7
	BLEQ	command_primative	; insert marker for multiop start
	MVNVC	R14,#0
	STRVC	R14,[R9,#f_altered]	; zero start posn
	MOVVC	R14,#0
	STRVC	R14,[R9,#f_change]	; ...
	LDRVC	R14,[R9,#f_flags]
	STRVC	R14,[R9,#f_oflags]
	MOVVC	R14,#1
	STRVC	R14,[R9,#f_depth]	; now at depth 1
	FNRTS


;E R0=error pointer if VS R9=file or 0 for none
;X Current operation displayed (and error preserved) #
	FNAME	stop_operation
stop_operation
	FNJSR	"R10-R11"
	MOVVS	R10,R0
	MOVVC	R10,#0			; error pointer
	CMP	R9,#0
	BLE	st13

st15	LDR	R0,[R9,#f_depth]
	SUBS	R0,R0,#1		; new level (&clv)
	STRPL	R0,[R9,#f_depth]	; new depth
	BNE	st13			; wasn't in an operation, or still nested
	SWI	XHourglass_Off
	BL	maybe_test_changed	; this may mark the file 'unchanged'
	LDR	R0,[R9,#f_flags]
	LDR	R14,[R9,#f_oflags]
	EOR	R14,R14,R0
	TST	R14,#8
	BLNE	new_file_title		; ensure 'changed' state is correct
	BL	redraw_patching_update
	LDR	R0,[R9,#f_altered]
	CMP	R0,#0			; nothing done?
	BMI	st13			; finished
	BVS	st14
	LDR	R0,[R9,#f_flags]
	TST	R0,#1<<8
	MOVEQ	R0,#&17			; is file r/w and
	TSTEQ	R10,#1<<31		; have we been called by undo?
	BLEQ	command_primative	; add stop marker if not

st14	MOVVS	R10,R0
st13	BLVC	to_new_carets$l		; redraw carets on screen (before...?)
	BICS	R0,R10,#1<<31		; clear flag
	FNPULL
	MOVEQ	PC,R14
	RTV

to_new_carets$l				; redraw carets on screen (before...?)
	LDR	R0,[R9,#f_altered]
	CMP	R0,#0			; nothing done?
	BPL	new_carets		; redraw carets on screen (before...?)
	MOV	PC,R14


	INCORE  4
local_storedreight
	DCD	0

; note that r8 not known at this point...
; new bit to cure redraw probs!
	FNAME	redraw_patching_update
redraw_patching_update
	FNJSR	"R0-R11"
	MOV	R11,R9
	FNLDR	R10,car_cursor
	LDR	R0,[R10,#c_wind]
	BL	conv_wind_off		; may destroy R9 :-(
	CMP	R9,R11
	MOVNE	R9,R11			; wrong window...!
	MOVNE	R8,R14			; wrong window...!
	STR	R8,local_storedreight
	FNLDR	R11,car_mode		; save current caret mode
	PUSH	"R10,R11"
	MVN	R14,#1			; -2
	FNSTR	R14,car_mode		; pretend there are no carets
	ADRL	R10,new_txt_status_wind
	BL	do_eachwindow		; update each window by shifting screen
	PULL	"R10,R11"
	FNSTR	R11,car_mode		; restore caret mode (not VC!)
	FNRTS	VS

	LDR	R0,[R9,#f_altered]
	CMP	R0,#0			; anything done?
	BMI	nuffindone$l
	BL	new_carets		; redraw carets on screen (before...?)
	FNRTS

nuffindone$l
	LDR	R11,[R9,#f_flags]
	ORR	R14,R11,#1<<14		; input linked (so it doesn't update cursor)
	STR	R14,[R9,#f_flags]
	BL	new_carets		; redraw carets on screen (before...?)
					; condition GT above???
	STR	R11,[R9,#f_flags]
	FNRTS


	LOCAL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; INSERT AND CRUNCH						  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=file off R2=num of bytes R3=ptr to data R9
;X text inserted, window & caret updated #
	FNAME	insert_text
insert_text
	FNJSR	"R1-R5,R8,R10"
	MOV	R8,R0
	MOV	R10,R3			; save address of text
	MOV	R4,R1			; save offset
	MOV	R3,R2			; save num of bytes
	MOV	R0,R1			; offset of split
	MOV	R1,R2			; min size of split
	BL	split_buffer
	LDRVC	R5,[R9,#f_splito]	; get split offset
	MOVVC	R0,R5			; first changed offset
	MOVVC	R1,R2			; signed change
	MOVVC	R2,R0			; first shiftable char
	BLVC	save_txt_status		; save text status after this point
	MOVVC	R1,R10			; address of text
	LDRVC	R2,[R9,#f_ptr]
	ADDVC	R2,R2,R5		; address of split
	ADDVC	R0,R5,R3
	STRVC	R0,[R9,#f_splito]	; new split offset
	LDRVC	R0,[R9,#f_splits]
	SUBVC	R0,R0,R3
	STRVC	R0,[R9,#f_splits]	; new split size
	LDRVC	R0,[R9,#f_len]
	ADDVC	R0,R0,R3
	STRVC	R0,[R9,#f_len]		; new file length
	MOVVC	R4,R3			; save num of bytes
	SWI	XZapRedraw_MoveBytes	; BL move_bytes	; copy data
	FNRTS	VS
	MOV	R0,R5			; offset of first changed char
	MOV	R1,R4			; signed change
	CMP	R8,#1
	ADDEQ	R2,R0,R1		; new input caret posn
	MOVNE	R2,R0
	BL	new_proposed_txt_status
	BL	mark_changed		; no so mark changed
	FNRTS


;E R5 start R4 length...
mark_proposed_new_sel
	FNJSR	"R0-R11"
	LDR	R14,local_commandtypestored
	TST	R14,#&40
	FNRTS	EQ
	FNLDR	R10,car_cursor		; *only* works if cursor linked!? :-(
	LDR	R0,[R10,#c_wind]
	BL	conv_wind_off		; get R8/R9...
	MOVVC	R2,R5
	ADDVC	R3,R5,R4		; end offset
	BLVC	alter_selected_region	; redraw selection...
	SUBS	R14,R14,R14		; restore flags...
	FNRTS


	LOCAL

;E R1=file offset R2=num of bytes R9
;X #
	FNAME	delete_text
delete_text
	FNJSR	"R1-R3,R4-R5"
	FNLDR	R14,opt_switches
	TST	R14,#bit_return_deletions
	BEQ	delete_text_blk
	MOV	R4,R1			; save file offset of del start
	MOV	R5,R2			; save length of delete
	ADD	R0,R4,R5		; offset after chars to delete
	MOV	R1,#0
	BL	split_buffer		; split buffer to just after del block
	MOVVC	R0,R4			; first offset
	RSBVC	R1,R5,#0		; signed change
	ADDVC	R2,R4,R5		; first shiftable character
	BLVC	save_txt_status
	FNRTS	VS
	LDR	R0,[R9,#f_len]
	SUBS	R0,R0,R5
	BLMI	err$l			; negative file offset
	STRVC	R0,[R9,#f_len]		; new file len
	LDRVC	R0,[R9,#f_splito]
	SUBVC	R0,R0,R5
	STRVC	R0,[R9,#f_splito]	; new split offset
	LDRVC	R0,[R9,#f_splits]
	ADDVC	R0,R0,R5
	STR	R0,[R9,#f_splits]	; new split size
	MOVVC	R0,R4			; offset in file
	RSBVC	R1,R5,#0		; change in cursor posn
	MOVVC	R2,R4			; cursor start of block
	BLVC	new_txt_status
	BLVC	mark_changed		; no so mark changed
	FNRTS

err$l	ERRlit  "Internal error: delete_text"



;E R1=file offset R2=num of bytes R9
;X R3=temp ptr to deleted data (in split) #
	FNAME	delete_text_blk
delete_text_blk
	FNPULL				; :-(
	FNJSR	"R1-R2,R4-R5"
	MOV	R4,R1			; save file offset of del start
	MOV	R5,R2			; save length of delete
	FNLDR	R0,wimp_data
	MOV	R1,R5
	BL	heap_ensure
	FNSTR	R0,wimp_data,VC		; ensure data buffer big enough
	ADDVC	R0,R4,R5		; offset after chars to delete
	MOVVC	R1,#0
	BLVC	split_buffer		; split buffer to just after del block
	MOVVC	R0,R4			; first offset
	RSBVC	R1,R5,#0		; signed change
	ADDVC	R2,R4,R5		; first shiftable character
	BLVC	save_txt_status
	FNRTS	VS
	LDR	R0,[R9,#f_len]
	SUBS	R0,R0,R5
	BLMI	err$l			; negative file offset
	STR	R0,[R9,#f_len]		; new file len
	LDR	R0,[R9,#f_splito]
	SUB	R0,R0,R5
	STR	R0,[R9,#f_splito]	; new split offset
	LDR	R0,[R9,#f_splits]
	ADD	R0,R0,R5
	STR	R0,[R9,#f_splits]	; new split size
	LDR	R1,[R9,#f_ptr]
	ADD	R1,R1,R4		; start of deleted data
	FNLDR	R2,wimp_data		; block for data ; no heap ensure...?
	MOV	R3,R5
	SWI	XZapRedraw_MoveBytes	; BL move_bytes	; copy deleted data
	MOVVC	R0,R4			; offset in file
	RSBVC	R1,R5,#0		; change in cursor posn
	MOVVC	R2,R4			; cursor start of block
	BLVC	new_txt_status
	BLVC	mark_changed		; no so mark changed
	FNLDR	R3,wimp_data		; deleted data pointer
	FNRTS


;E R0=command num R1=file offset R2=num of bytes R3=replacement blk R9
;X R4=temp ptr to original (deleted) data (was in split :<) #
	FNAME	replace_text
replace_text
	FNJSR	"R1-R3,R5-R8"
	MOV	R8,R0			; save command num 3 or 4
	MOV	R4,R1			; save offset to replace text
	MOV	R6,R2			; save number of bytes
	MOV	R5,R3			; save addr of replacement block
	FNLDR	R0,wimp_data
	MOV	R1,R6
	BL	heap_ensure
	FNSTR	R0,wimp_data,VC		; make sure there's enough room for data
	ADDVC	R0,R4,R6		; offset of split (after block)
	MOVVC	R1,R6			; size of split
	BLVC	split_buffer
	MOVVC	R0,R4			; first affected offset
	MOVVC	R1,#0			; signed change
	ADDVC	R2,R4,R6		; first shiftable offset
	BLVC	save_txt_status
	LDRVC	R7,[R9,#f_ptr]		; start of file
	ADDVC	R1,R7,R4		; source data (old data)
	FNLDR	R2,wimp_data,VC		; buffer for old data
	MOVVC	R3,R6
	SWIVC	XZapRedraw_MoveBytes	; move the old data to wimp_data
	MOVVC	R1,R5			; new data
	ADDVC	R2,R7,R4		; dest for new data
	MOVVC	R3,R6
	SWIVC	XZapRedraw_MoveBytes	; BL move_bytes	; copy in new data
	FNRTS	VS
	MOV	R0,R4			; offset of first changed
	MOV	R1,#0			; signed change
	TEQ	R8,#3
	ADDEQ	R2,R0,R6		; cursor after block
	MOVNE	R2,R0			; cursor start of block
	BL	new_txt_status
	FNLDR	R4,wimp_data,VC		; old data
	BL	mark_changed		; no so mark changed
	FNRTS


;E R0=char
;X R0=char with case swapped |
	FNAME	swap_case
swap_case
	CMP	R0,#'z'
	MOVHI	PC,R14
	CMP	R0,#'a'
	SUBCS	R0,R0,#'a'-'A'
	MOVCS	PC,R14
	CMP	R0,#'Z'
	MOVHI	PC,R14
	CMP	R0,#'A'
	ADDCS	R0,R0,#'a'-'A'
	MOV	PC,R14


;E R0=date format string
;X R0=date length and date read to wimp_kbdbuf WB KB #
	FNAME	read_date
read_date
	FNJSR	"R1-R11"
	MOV	R10,R0			; date format string
	FNLDR	R11,wimp_block		; buffer
	MOV	R1,R11
	MOV	R0,#3
	STRB	R0,[R1]
	MOV	R0,#14
	SWI	XOS_Word		; read 5 byte time to WB
	MOVVC	R0,R11			; 5 byte time block
	FNLDR	R1,wimp_kbdbuf,VC	; dest buffer
	MOVVC	R2,#kbdbuf_size		; keyboard buffer size
	MOVVC	R3,R10			; format string
	SWIVC	XOS_ConvertDateAndTime  ; put string in buffer
	FNLDR	R3,wimp_kbdbuf,VC	; data
	SUBVC	R0,R1,R3		; data length
	FNRTS


;E R0=date format string R2=default R8/R9/R10=input caret
;X date inserted KB WB #
	FNAME	insert_date
insert_date
	FNJSR	"R1-R3"
	BL	strdefault
	BL	read_date		; read date to KB
	MOVVC	R2,R0			; length
	FNLDR	R3,wimp_kbdbuf,VC	; data
	LDRVC	R1,[R10,#c_off]		; offset
	MOVVC	R0,#&11			; block insert
	BLVC	execute_command
	FNRTS


	LOCAL

;E R0=pointer to string (0 terminated Only) R8/R9
;X string entered at file end (using execute command) #
	FNAME	insert_string
insert_string
	FNJSR	"R1-R3"
	MOV	R3,R0			; string
a$l	LDRB	R14,[R0],#1
	TEQ	R14,#0
	BNE	a$l
	SUB	R2,R0,R3
	SUB	R2,R2,#1		; length (cannot use strlen for &0A's)
	LDR	R1,[R9,#f_len]
	MOV	R0,#&11
	BL	execute_command
	FNRTS


; R4=w_flags R5=num bytes R6=w_format R7=data R8-R10=input caret
; R11=max number of chars to replace (<=R5).
; Chars are replaced (if overwrite) as much as possible
; & then inserted R4,R6,R8-R10 preserved #
	FNAME	insert_chars_at
insert_chars_at
	FNJSR
	TST	R4,#2
	BEQ	in17			; insert
	LDR	R0,[R9,#f_len]
	LDR	R1,[R10,#c_off]
	SUB	R1,R0,R1		; num of chars left in file
	CMP	R11,R1
	MOVGT	R11,R1			; clip number of chars to replace
	CMP	R11,#0
	BLE	in17			; insert remaining
	MOV	R0,#3			; replace
	LDR	R1,[R10,#c_off]
	MOV	R2,R11
	MOV	R3,R7
	BL	execute_command		; replace these chars
	FNRTS	VS
	SUB	R5,R5,R11
	ADD	R7,R7,R11		; update pointers
in17	CMP	R5,#0
	FNRTS	LE
	MOV	R0,#1
	LDR	R1,[R10,#c_off]
	MOV	R2,R5
	MOV	R3,R7
	BL	execute_command		; insert the chars
	FNRTS


;E R1=number of returns R8-R10=caret
;X returns entered with auto indent trailing added if nec KB #
	FNAME	insert_returns
insert_returns
	FNJSR	"R1-R7"
	MOV	R7,R1			; save num times to add
	LDR	R2,[R8,#w_format]	; flags
	MOV	R3,#0			; number of trailing chars
	TST	R2,#1<<16
	BEQ	in54			; no auto indent
	LDR	R0,[R10,#c_off]
	BL	mode0_linestart
	MOVVC	R4,R0			; save start offset
	BLVC	mode0_autoplus		; move to end
	FNRTS	VS
	SUB	R3,R0,R4		; number of trailing chars
	LDR	R14,[R10,#c_off]
	CMP	R0,R14
	MOVGT	R3,#0

in54	ADD	R0,R3,#1		; number of chars per line
	MUL	R1,R0,R7		; total block size
	FNLDR	R0,wimp_kbdbuf
	BL	heap_ensure
	FNRTS	VS
	FNSTR	R0,wimp_kbdbuf
	MOV	R5,R0			; buffer pointer
	ADD	R6,R3,#1		; total length of each line
	LDRB	R0,[R8,#w_cr]
	STRB	R0,[R5],#1		; add ret char
	CMP	R3,#0
	BLE	in55

in56	MOV	R0,R4
	BL	cln_readc
	STRB	R0,[R5],#1
	ADD	R4,R4,#1
	SUBS	R3,R3,#1
	BGT	in56

in55	SUBS	R7,R7,#1
	BLE	in57			; all entries set up
	FNLDR	R1,wimp_kbdbuf
	MOV	R2,R5
	MOV	R3,R6
	SWI	XZapRedraw_MoveBytes	; BL move_bytes	; copy next entry
	ADD	R5,R5,R6
	B	in55

in57	MOV	R0,#&11
	LDR	R1,[R10,#c_off]
	FNLDR	R3,wimp_kbdbuf
	SUB	R2,R5,R3
	BL	execute_command
	FNRTS


;E,X as for replace_area (except that R8 is not required)
	FNAME	do_replace_area
do_replace_area
	FNJSR	"R8"
	MOV	R8,#0
	BL	replace_area
	FNRTS


;E R1=file offset R2=number of bytes R3=new data R4=data len R8/R9
;X file contents R1.R2 replaced by R3.R4 by minimum number of commands #
;  data is concatonated if replace/insert/delete length is 1
;  actual text is examined so no replacement done if not needed
	FNAME	replace_area
replace_area
	FNJSR	"R1-R5"
	MOV	R5,R1			; save file offset
	CMP	R2,#0
	CMPNE	R8,#0
	BEQ	re24
	PUSH	"R2,R7-R11"
	MOV	R7,R2
	MOV	R10,R8
	MOV	R11,R9
	BL	get_selection
	BCS	dontcheck$l		; no sel...
	CMP	R2,#0
	BEQ	dontcheck$l		; zero size...
	CMP	R8,R10
	CMPEQ	R9,R11
	CMPEQ	R1,R5
	CMPEQ	R2,R7
	BEQ	currentselection_replacement
dontcheck$l
	PULL	"R2,R7-R11"

re24	CMP	R2,#0
	CMPGT	R4,#0
	BLE	re25
	MOV	R0,R5
	BL	cln_readc
	LDRB	R1,[R3]
	TEQ	R0,R1
	ADDEQ	R5,R5,#1
	ADDEQ	R3,R3,#1
	SUBEQ	R2,R2,#1
	SUBEQ	R4,R4,#1
	BEQ	re24

re26	CMP	R2,#0
	CMPGT	R4,#0
	BLE	re25
	ADD	R0,R5,R2
	SUB	R0,R0,#1
	BL	cln_readc
	ADD	R1,R3,R4
	LDRB	R1,[R1,#-1]
	TEQ	R0,R1
	SUBEQ	R2,R2,#1
	SUBEQ	R4,R4,#1
	BEQ	re26
	TEQ	R2,R4			; neither string is null
	BEQ	re27			; strings are of same length
	MOV	R1,R5
	MOV	R0,#2			; cut...
	CMP	R2,#1
	ORRGT	R0,R0,#&10		; don't concat if large block
	BL	execute_command		; delete the old data
	FNRTS	VS
	MOV	R2,R4
	MOV	R0,#1
	CMP	R2,#1
	ORRGT	R0,R0,#&10
	BL	execute_command		; insert the new data
	FNRTS

re27	MOV	R0,#3			; replace
	MOV	R1,R5
	CMP	R2,#1
	ORRGT	R0,R0,#&10
	BL	execute_command
	FNRTS

re25	TEQ	R2,R4			; are both null?
	FNRTS	EQ
	CMP	R2,#0
	BLE	re28
	MOV	R0,#2			; cut...
	MOV	R1,R5
	CMP	R2,#1
	ORRGT	R0,R0,#&10
	BL	execute_command		; delete old and none to replace
	FNRTS

re28	MOV	R0,#1
	MOV	R1,R5
	MOV	R2,R4
	CMP	R2,#1
	ORRGT	R0,R0,#&10
	BL	execute_command		; insert new as none to delete
	FNRTS

currentselection_replacement
	PULL	"R2,R7-R11"
	BL	start_operation
	MOV	R1,R5
	MOV	R0,#&42
	CMP	R2,#01
	ORRGT	R0,R0,#&10		; don't concat if large block
	BL	execute_command		; delete the old data
	MOV	R2,R4
	MOV	R0,#&41
	CMP	R2,#1
	ORRGT	R0,R0,#&10
	BL	execute_command		; insert the new data
	BL	stop_operation
	FNRTS


	LOCAL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Space stripping code						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=b0 => Strip spaces from the end of lines
;     b1 => Strip tabs from the end of lines
;     b2 => Convert spaces to tabs (outside "quoted" text)
;  R8/R9=window
;X File processed KB #
	FNAME	strip_spaces
strip_spaces
	FNJSR	"R1-R10"
	LDR	R1,[R9,#f_flags]
	ORR	R14,R1,#1<<14
	STR	R14,[R9,#f_flags]	; unlink input caret
	BL	start_operation		; do all as one go
	PUSH	"R1"
	MOV	R1,R0
	MOV	R0,#0
	MOV	R11,#e_stripspaces
	BL	call_mode
	BVS	error$l
	TEQ	R0,#0
	BNE	error$l
	MOVS	R0,R1
	ADRNE	R10,main$l
	BLNE	do_longop		; hourglass
	MOVVC	R0,#255
	MOVVC	R11,#e_stripspaces
	BLVC	call_mode

error$l	BL	stop_operation		; cancel even if there are errors
	LDR	R14,[R9,#f_flags]
	PULL	"R1"
	BIC	R14,R14,#1<<14
	AND	R1,R1,#1<<14
	ORR	R14,R14,R1
	STR	R14,[R9,#f_flags]	; restore cursor linkage state
	FNRTS				; exit (possibly with error)

main$l	FNJSR	"R1-R11"
	EOR	R10,R0,#3		; save flags NOTing the bottom two
	MOV	R7,#0			; current file_offset
	LDRB	R4,[R8,#w_cr]		; return symbol
	LDRB	R6,[R8,#w_tabc]		; tab symbol
	BL	read$l			; R1=buff R2=splito R3=second bit R5=len
line$l					; do next line
	MOV	R11,#0			; b0-b15=current col b16-b31=white space col
	AND	R10,R10,#&0F		; b6=in" b7=in' b8+ file off of white space
	MOV	R8,R7			; off of start of strippable characters
	ADD	R10,R10,R7,LSL#8	; offset of current tabbable region

a$l	CMP	R7,R5
	BCS	endfile$l		; end of file
	CMP	R7,R2
	LDRCCB  R0,[R1,R7]
	LDRCSB  R0,[R3,R7]		; get next byte of file
	ADD	R7,R7,#1
	TEQ	R0,R4
	BEQ	end$l			; reached end of line
	TST	R10,#1<<2		; tabifying?
	BNE	t$l			; yes

b$l					; update space stripping vals
	TST	R10,#1
	TEQEQ	R0,#&20
	BEQ	a$l			; the character was strippable
	TST	R10,#2
	TEQEQ	R0,R6
	MOVNE	R8,R7			; not strippable so reset
	B	a$l

t$l					; extra code when checking for tabs as well
	ADD	R11,R11,#1		; next column (cos we're keeping count)
	TEQ	R0,R6			; tab?
	ADDEQ	R11,R11,#7
	BICEQ	R11,R11,#7		; move to next tab stop
	TEQNE	R0,#&20
	BEQ	b$l			; carry on with space stripping
	TST	R10,#3<<6		; non white space character
	BNE	u$l			; in a quoted expression
	SUB	R14,R11,R11,LSR#16	; number of white space chars + terminator
	MOV	R14,R14,LSL#16
	CMP	R14,#3<<16
	BLE	u$l			; not worth compressing (2 white spaces)
	PUSH	"R0"
	BL	tabify$l		; compress
	BLVC	quit$l
	PULL	"R14",VS
	FNRTS	VS
	PULL	"R0"
	FNRTS	CS

u$l					; sorted tabs out up to this non white space
	TEQ	R0,#'''                 ; update quote state
	EOREQ	R10,R10,#1<<7		; AFTER sorting out white space (inside?)
	TEQ	R0,#'"'
	EOREQ	R10,R10,#1<<6
	MOV	R11,R11,LSL#16
	ADD	R11,R11,R11,LSR#16	; duplicate current position
	AND	R10,R10,#&FF
	ADD	R10,R10,R7,LSL#8	; and save current offset
	B	b$l			; carry on with space stripping

endfile$l				; reached end of file
	ADD	R7,R7,#1		; go one off end (to fake LF)

end$l	SUB	R0,R7,R8		; reached the end of a line
	SUBS	R0,R0,#1		; number of bytes to strip
	BLE	s$l
	MOV	R2,R0			; number of bytes to delete
	PUSH	"R2-R11"
	MOV	R1,R8			; offset
	MOV	R0,#1
	LDR	R8,[R13,#28+40]		; R8 as stacked on entry
	LDR	R10,[R13,#36+40]	; and R10 (just in case)
	MOV	R11,#e_stripspaces
	BL	call_mode		; ask mode what to do
	PULL	"R2-R11"
	FNRTS	VS
	CMP	R0,#1			; R0 = 0: suppress
	SUBHI	R7,R7,R2		; R0 > 1: replaced by mode (update R7)
	ADDHI	R7,R7,R1
	BNE	ss$l			; fall through if R0 = 1 (default action)
	MOV	R0,#&12			; delete block
	MOV	R1,R8			; offset
	SUB	R7,R7,R2		; new current offset
	LDR	R8,[R13,#28]
	BL	command_primative	; don't let wordwrap get at it!
	BLVC	quit$l
	FNRTS	VS

ss$l	BL	read$l			; new values

s$l	CMP	R7,R5			; spaces stripped
	BLT	line$l			; do next line
	FNRTS

read$l	LDR	R1,[R9,#f_ptr]		; start of buffer
	LDR	R2,[R9,#f_splito]	; offset of split
	LDR	R3,[R9,#f_splits]
	ADD	R3,R1,R3		; apparent start of second half
	LDR	R5,[R9,#f_len]		; end offset
	MOV	PC,R14

tabify$l				; possible tab compression
	FNJSR	"R4,R8"			; R1-R3,R5 are updated. Note R8 read below...
	; if to call e_stripspaces for tabification, then call it here
	MOV	R1,R11,LSR#16		; start column
	BIC	R2,R11,R1,LSL#16
	SUB	R2,R2,#1		; end column (taking off terminator)
	FNLDR	R3,wimp_kbdbuf		; buffer to use

y$l	CMP	R1,R2
	BCS	z$l			; finished
	ADD	R0,R1,#8
	BIC	R0,R0,#7		; next tab stop
	CMP	R0,R2
	MOVLE	R1,R0			; can fit a tab in
	MOVLE	R0,R6
	ADDGT	R1,R1,#1
	MOVGT	R0,#&20
	STRB	R0,[R3],#1
	B	y$l

z$l					; replacement data constructed
	MOV	R1,R10,LSR#8		; file offset of start
	SUB	R2,R7,R1
	SUB	R2,R2,#1		; number of bytes to replace
	FNLDR	R0,wimp_kbdbuf
	SUB	R4,R3,R0		; data length
	MOV	R3,R0			; data
	LDR	R8,[R13,#28+12]		; stacked R8
	BL	replace_area
	SUBVC	R0,R4,R2		; change in data length
	ADDVC	R7,R7,R0		; update the search offset
	BLVC	read$l			; get new values
	FNRTS

quit$l	FNJSR	"R1"			; return CS to quit (escape set)
	MOV	R0,R6
	MOV	R1,R5
	BL	long_op_display		; percentage
	SWIVC	XOS_ReadEscapeState
	FNRTS


;E R9=file to be operated on
;X Operation level set to 1 and no marker buffered |
	FNAME	undo_start_operation
undo_start_operation
	FNJSR
	MOV	R14,#0
	STR	R14,[R9,#f_depth]	; for redraw of carets...
	BL	scrub_all_on_this_file  ; get rid of any cursors /before/ op start
	MOV	R14,#1
	STR	R14,[R9,#f_depth]
	LDR	R14,[R9,#f_flags]
	STR	R14,[R9,#f_oflags]
	MVN	R14,#0
	STR	R14,[R9,#f_altered]
	FNRTS


;E R0=error pointer if VS R9=file to be operated on
;X Current operation stop op'd but no marker buffered #
	FNAME	undo_stop_operation
undo_stop_operation
	FNJSR	"R10-R11"
	ORRVS	R10,R0,#1<<31
	MOVVC	R10,#1<<31		; undo flag
	B	st15			; stop the operation


;E R0=offset of first stable character R8/R9
;X Start of cache set to the line containg this character #
	FNAME	clip_cache
clip_cache
	FNJSR	"R1-R2"
	MOV	R1,#0
	STR	R1,[R8,#w_txtn]		; null cache
	LDR	R1,[R8,#w_coff]
	CMP	R0,R1
	FNRTS	EQ			; return if already there
	BL	cln_off			; get this reference point
	STRVC	R0,[R8,#w_cline]	; new phy line
	STRVC	R1,[R8,#w_coff]		; new line offset
	STRVC	R2,[R8,#w_clogl]	; new logical line
	FNRTS




 END
