; Diff colouring mode
; $Id: module,fff,v 1.3 2001-04-24 04:17:55 ds Exp $
;
; (c) Zap Developers 2001

	GET	h.Diff
	GET	h.Version

	AREA	|!!!Module_Header_Area|,CODE,READONLY
	ENTRY

	DCD	0x00
	DCD	init_code
	DCD	finalise_code
	DCD	0x00
	DCD	title_string
	DCD	help_string
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0

help_string = "ZapDiff",9
	    = version,"(00 Jan 0000)"
 [ BUILD > ""
		= " ",BUILD
  [ (BUILD:RIGHT:1 < "0" :LOR: BUILD:RIGHT:1 > "9") :LAND: patch_level <> ""
		= "-",patch_level
  ]
 |
  [ test_flag
		= " [TEST"
   [ patch_level <> ""
		= " ",patch_level
   ]
		= "]"
  |
   [ patch_level <> ""
		= " patch-",patch_level
   ]
  ]
 ]
	FNS (" © Zap Developers")

title_string FNS ("ZapDiff")

ws_store	DCD	0
zap_modulename	=	"Zap", 0

get_workspace
	LDR	r11, ws_store
	MOV	pc, lr

init_code
	FNJSR
	LDR	r2, [r12, #0]
	CMP	r2, #0
	BNE	module_init
	MOV	r0, #6
	MOV	r3, #ws_size
	SWI	XOS_Module
	FNRTS	VS
	STR	r2, [r12, #0]
	ADRL	r0, ws_store
	STR	r2, [r0, #0]
	MOV	r0, #-1
	STR	r0, [r2, #ws_modenumber]
	MOV	r0, #0
	STR	r0, [r2, #ws_menudata]
module_init
	MOV	r0, #18
	ADR	r1, zap_modulename
	SWI	XOS_Module
	FNRTS	VS
	MOV	r12, r4		;  Zap workspace
	ADR	r0, mode_table
	FNcall	Zap_AddMode
	FNRTS

finalise_code
	FNJSR
	MOV	r0,#7
	LDR	r2,[r12]
	SWI	XOS_Module
	FNRTS	VS
	MOV	r0,#0
	STR	r0,[r12]
	FNRTS

mode_name
	=	"Diff", 0
mode_author
	=	"James Aylett", 0
	ALIGN

mode_table
	DCD	mode_table
	DCD	mode_name
	DCD	mode_author
	DCD	0		;  basemode = text
	DCD	emode_UsesMessageTrans :OR: emode_MayBeCloned :OR: emode_ModeWordIsBlock
	DCD	mode_init
	DCD	0
	DCD	mode_table_end - mode_table
	DCD	0
	DCD	0
	DCD	0
	DCD	mode_start
	DCD	mode_end
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	mode_nextline
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	mode_redrawline
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	mode_prevline
mode_table_end

	LOCAL
mode_init
	CMP	r1, #einit_ModeMenu
	BEQ	init_modemenu
	CMP	r1, #einit_ModeStarting
	BEQ	init_modestarting

	CMP	r1, #einit_ColoursSubmenu
	ADREQ	r1, colsmenu$l
	MOVEQ	pc, lr

	CMP	r1, #einit_RedrawStart
	BEQ	init_redrawstart

	TEQ	r1, #einit_ModeStarted
	MOVNE	pc, lr

	FNJSR	"r1-r3, r7, r8"

	MOV	r8, #0
	LDR	r1, [r11, #ws_modenumber]
	BL	init_colours
	FNRTS	VS

	FNcall	Zap_GetModeWord
	TEQ	r0, #0
	BEQ	init_config

	LDR	r7, [r0, #0]
	CMP	r7, #mb_size
	FNRTS	EQ
	; Config block is wrong size!
	; Note that currently this is irrelevant ...
	MOV	r1, #mb_size
	FNcall	Zap_Ensure
	FNRTS	VS
	MOV	r7, #mb_size
	STR	r7, [r0, #mb_sizestore]
	FNcall	Zap_PutModeWord
	FNRTS
colsmenu$l
	=	"diff_colours", 0
	ALIGN

init_config
	MOV	r0, #mb_size
	FNcall	Zap_Claim
	FNRTS	VS
	MOV	r7, #mb_size
	STR	r7, [r0, #mb_sizestore]
	MOV	r7, #0
	STR	r7, [r0, #mb_flags]
	FNcall	Zap_PutModeWord

	ADR	r3, vardata$l
	MOV	r2, #0
	LDR	r7, [r3], #4
setupvars$l
	LDR	r0, [r3], #4
	FNcall	Zap_ModeData
	ADD	r2, r2, #1
	CMP	r2, r7
	BLT	setupvars$l
	FNRTS

vardata$l
	DCD	2		; total vars to write
	DCD	0x77 :OR: (tab_DisplayAsSpaces :SHL: tab_DisplayFormat_config_shift)
	DCD	0x7 :OR: modeconfig_LineNumberColon :OR: modeconfig_CursorSmart

init_modestarting
	LDR	r1, [r11, #ws_modenumber]
	CMP	r1, #-1
	STREQ	r0, [r11, #ws_modenumber]
	MOV	pc, lr

	LOCAL
init_modemenu
	FNJSR
	BL	load$l
	LDRVC	r1, [r0, #4]
	FNRTS
load$l
	FNJSR
	LDR	r0, [r11, #ws_menudata]
	CMP	r0, #0
	FNRTS	NE

	ADR	r0, menu_path$l
	FNcall	Zap_LoadMenu
	STRVC	r0, [r11, #ws_menudata]
	FNRTS
menu_path$l
	=	"<ZapDiff$Menus>", 0
	ALIGN

	LOCAL
init_colours
	FNJSR	"r1-r5"
	MOV	r0, #-1
	FNcall	Zap_ModeColourNum
	CMP	r0, #colour_max
	FNRTS	GE

	MOV	r0, #colour_max
	FNcall	Zap_ModeColourNum
	MOV	r2, #colour_base
	ADR	r3, cols$l
set_col$l
	LDR	r0, [r3], #4
	FNcall	Zap_ModeColour
	ADD	r2, r2, #1
	CMP	r2, #colour_max
	BLT	set_col$l
	FNRTS
cols$l
	DCD	0xbbefef10	; beige
	DCD	0x0000dd10	; red
	DCD	0x00cc0010	; green
	DCD	0x00885510	; olive
	DCD	0xFFBB0010	; cyan


	LOCAL
init_redrawstart
	FNJSR	"r0-r5,r11"
	MOV	r0,#0
	LDR	r1,[r9,#f_ptr]
	LDR	r2,[r9,#f_splito]
	LDR	r3,[r9,#f_splits]
	LDR	r5,[r9,#f_len]
	ADD	r3,r1,r3
scan$l
	; check first char of line
	BL	readchar$l
	TEQ	r4,#'-'		; '-' => unified format
	MOVEQ	r4,#diff_UNIFIED
	BEQ	knowndiff$l
	TEQ	r4,#'*'		; '*' => context format
	MOVEQ	r4,#diff_CONTEXT
	BEQ	knowndiff$l
	TEQ	r4,#'d'		; 'd' => "diff" line? RCS format?
	BEQ	diff_or_rcs$l
	TEQ	r4,#'a'		; 'a' => RCS format, if followed by digit
	BEQ	maybe_rcs$l
	TEQ	r4,#'O'		; 'O' => "Only in" line
	BEQ	nextline$l
	CMP	r4,#'0'		; digit => standard format? ed format?
	RSBHSS	r14,r4,#'9'
	BHS	standard_or_ed$l
	; anything else - not a diff file...?
unknowndiff$l
	MOV	r4,#diff_UNKNOWN
knowndiff$l
	BL	get_workspace
	STR	r4,[r11,#ws_difftype]
	FNRTS

readchar$l
	CMP	r0,r5
	BHS	unknowndiff$l	; OK so long as no extra registers pushed :-)
	CMP	r0,r2
	MOVHS	r1,r3
	LDRB	r4,[r1,r0]
	ADD	r0,r0,#1
	MOV	pc,r14

nextline$l
	MOV	r11,#e_linenext
	FNcall	Zap_CallMode
	B	scan$l

standard_or_ed$l
	; standard is "<number><letter><number>"
	; ed       is "<number><letter>"
	BL	readchar$l
	CMP	r4,#'0'
	RSBHSS	r14,r4,#'9'
	BHS	standard_or_ed$l; skip digits
	CMP	r4,#'a'
	RSBHSS	r14,r4,#'z'
	BLO	unknowndiff$l	; must be lowercase letter
	; if the next chr is a digit, we have standard format
	BL	readchar$l
	CMP	r4,#'0'
	RSBHSS	r14,r4,#'9'
	MOVLO	r4,#diff_ED
	MOVHS	r4,#diff_STANDARD
	B	knowndiff$l

diff_or_rcs$l
	; RCS is "d<number>" or "a<number>"
	BL	readchar$l
	TEQ	r4,#'i'
	BEQ	nextline$l	; 'i' => "diff" line
maybe_rcs$l
	CMP	r4,#'0'
	RSBHSS	r14,r4,#'9'
	MOVHS	r4,#diff_RCS
	BHS	knowndiff$l	; digit => RCS format
	B	unknowndiff$l


mode_start
	FNJSR
	LDRB	r0, [r8, #w_format] ; mode number
	FNcall	Zap_RestoreModeWord
	FNRTS

mode_end
	FNJSR
	LDRB	r0, [r8, #w_format] ; mode number
	FNcall	Zap_SaveModeWord
	FNRTS


	LOCAL
mode_redrawline
	FNJSR	"r11"

	LDRB	r0, [r7, #0]	; first char of line
	PUSH	"r0, r6, r9"
	; Can't use Zap_BaseMode because r11 is a parameter to e_redrawline :-(
	MOV	r0, #0
	FNcall	Zap_ReadMode
	MOV	lr, pc
	LDR	pc, [r1, #(2*e_redrawline)]

	PULL	"r4, r6, r9"	; r4 = first char of line
	BL	get_workspace
	LDR	r11,[r11,#ws_difftype]
	CMP	r11,#diff_NUM_TYPES
	ADDLO	pc,pc,r11,LSL #2
	B	done$l
	B	standard$l
	B	context$l
	B	unified$l
	B	done$l	; ed format
	B	done$l	; rcs format
			; can't colour ed, rcs without multiline parsing

standard$l
	; add start '>', remove start '<'
	; control lines start with digits
	CMP	r4, #'>'
	MOVEQ	r1, #colour_add
	BEQ	drawline$l

	CMP	r4, #'<'
	MOVEQ	r1, #colour_remove
	BEQ	drawline$l

	CMP	r4, #'0'
	RSBHSS	r14, r4, #'9'
	MOVHS	r1, #colour_control
	BHS	drawline$l

informationals$l
	TEQ	r4,#'d'
	TEQNE	r4,#'O'
	MOVEQ	r1,#colour_info
	BEQ	drawline$l
	B	done$l

context$l
	; add start '!', remove start '!' (!)
	; control lines start and end with '*'
	; filename lines start with '*' (old) or '-' (new)
	TEQ	r4, #'!'
	MOVEQ	r1, #colour_change
	BEQ	drawline$l

	TEQ	r4, #'*'
	; TO DO: check last character
	MOVEQ	r1, #colour_control
	BEQ	drawline$l

	B	informationals$l

unified$l
	; add start '+', remove start '-' (also colours old, new filenames)
	; control start '@'
	CMP	r4, #'+'
	MOVEQ	r1, #colour_add
	BEQ	drawline$l

	CMP	r4, #'-'
	MOVEQ	r1, #colour_remove
	BEQ	drawline$l

	CMP	r4, #'@'
	MOVEQ	r1, #colour_control
	BEQ	drawline$l

	B	informationals$l

	; can't colour without multiline parsing

drawline$l
	LDR	r0, [r8, #w_txtw]
	ADD	r6, r6, r0
loop$l	STRB	r1, [r6],#1
	SUBS	r0, r0, #1
	BNE	loop$l

done$l
	FNRTS

	LOCAL
mode_nextline
	FNJSR	"r2, r9, r11"
	LDR	r2, [ws, #ws_lastprevline]
	CMP	r2, #0
	BNE	just_nextline$l
	LDR	r0, [r9, #f_len]
	FNcall	Zap_OffsetLine	; \E r0/r1 the wrong way round ...
	EOR	r0, r0, r1
	EOR	r1, r0, r1
	EOR	r0, r1, r0
	FNRTS
just_nextline$l
	LDRB	r9, [r8, #w_format] ; ie our mode number
	MOV	r11, #e_nextline
	FNcall	Zap_BaseMode
	FNRTS

	LOCAL
mode_prevline
	STR	r0, [ws, #ws_lastprevline]
just_prevline$l
	FNJSR	"r9, r11"
	LDRB	r9, [r8, #w_format] ; ie our mode number
	MOV	r11, #e_prevline
	FNcall	Zap_BaseMode
	FNRTS

	END
