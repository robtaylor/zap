; Contains startup code including read/writing config file etc.
; Also contains some misc error code
; $Id: StartUp,fff,v 1.1.2.2 1999-01-10 01:16:42 ds Exp $

 GET h.ZapHeader
 GET h.Heap
 GET h.Redraw
 GET h.KeyBits
 GET h.ModeBits
 GET h.CreateFile
 GET h.Strings
 GET h.Version

; IMPORT env_noicon_check

 EXPORT init_vars
 EXPORT init_stack
 EXPORT free_stack
 EXPORT init_fixed
 EXPORT init_config
 EXPORT read_given_config_block
 EXPORT init_envstring
 EXPORT init_load
 EXPORT Saveoptions
 EXPORT err3
 EXPORT err12
 EXPORT err23
 EXPORT err41
 EXPORT check_object_type
 EXPORT generate_error
 EXPORT init_external
 EXPORT remove_external_object
 EXPORT get_pointer_to_code_cols

stack_size		* &800		; stack size
initial_wimpslot	* 96*1024	; 96K initial wimpslot

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; INITIALISE VARIABLES						  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;X variable blocks claimed and first word nulled & vars set up #

init_vars
 FNJSR "R1-R11"
 ADR R10,list$l
a$l
 LDMIA R10!,{R0,R1}		; buffer size, offset of buffer pointer
 CMP R0,#0
 BMI b$l			; end of list reached (-1)
 CMP R0,#4
 MOVCC R0,#4			; ensure at least 4 bytes
 BL heap_claim
 STRVC R0,[R12,R1]		; save buffer address
 MOVVC R14,#0
 STRVC R14,[R0]			; clear first word by default
 BVC a$l
 FNRTS
b$l
 BL check_scn_valid		; read scn_* variables
 FNRTS VS
 MOV R0,#0			; R0=0
 MOV R1,#-1			; R1=-1
 MOV R2,#1			; R2=1
 FNSTR R0,file_num
 FNSTR R0,wind_num
 FNSTR R0,font_num
 FNSTR R0,red_blklen
 FNSTR R0,red_datasize
 FNSTR R0,wind_count
 FNSTR R0,car_mode
 FNSTR R0,car_omode
 FNSTR R0,key_llen
 FNSTR R0,key_flags
 FNSTR R0,key_last
 FNSTR R0,key_lastcom
 FNSTR R0,clk_depth
 FNSTR R0,font_cache
 FNSTR R0,yank_off
 FNSTR R0,yank_len
 FNSTR R0,red_bac
 FNSTR R0,red_screen
 FNSTR R0,menu_count
 FNSTR R0,mini_lineed
 FNSTR R0,wimp_loglen
 FNSTR R0,if_count
 FNSTR R0,if_skip
 FNSTR R0,if_stop
 FNSTR R0,local_varlist
 FNSTR R0,wimp_poll_word
 FNSTR R1,wimp_throwback
 FNSTR R1,wimp_drag
 FNSTR R1,wimp_helpdata
 MOV R14,#2
 FNSTR R14,red_for
 FNLDR R14,wimp_dzap
 STR R1,[R14,#&2C]
 FNLDR R14,wimp_print
 STR R2,[R14,#&10]
 FNLDR R14,car_input
 STR R1,[R14,#c_wind]
 STR R1,[R14,#c_owind]
 FNLDR R14,car_cursor
 STR R1,[R14,#c_wind]
 STR R1,[R14,#c_owind]
 FNLDR R14,car_selection
 STR R1,[R14,#c_wind]
 STR R1,[R14,#c_owind]
 FNLDR R14,wimp_sizelist
 STR R1,[R14]
 FNLDR R14,key_maplist
 STR R1,[R14]
 FNLDR R14,ext_comm_flags
 MOV R1,#4
 STR R1,[R14]
; MOV R0,#0
 MOV R1,#0
 MOV R2,#&200
 ADR R3,keyname$l
 BL add_key_table
 MOV	R0, #&33	; default attributes - full read write for all
 FNSTR  R0, wimp_attr
 FNRTS
keyname$l FNS ("Default")
list$l
 DCD &500,wimp_data ; was &100 - now allows for set_up_print_palette
 DCD 0,fnd_string
 DCD 0,fnd_replace
 DCD &20,fnd_replace2
 DCD 4*kbdbuf_size,wimp_kbdbuf
 DCD 0,file_list
 DCD 0,wind_list
 DCD 0,font_list
 DCD 0,red_blkbuf
 DCD 0,fnd_tree
 DCD 4,wimp_cacheline
 DCD 0,key_learn
 DCD 0,menu_struct
 DCD 0,menu_entries
 DCD 0,font_struct
 DCD 0,font_entries
 DCD 0,font_ssstruct
 DCD 0,font_ssentries
 DCD 0,wimp_timeformat
 DCD 0,wimp_dateformat
 DCD 0,wimp_selecttype
 DCD 0,wimp_adjusttype
 DCD 0,wimp_modelist
 DCD 0,font_name
 DCD 0,font_namelow
 DCD 0,font_namehigh
 DCD 4,wimp_sizelist
 DCD 0,wimp_eolstring
 DCD 0,wimp_sofstring;
 DCD 0,wimp_eofstring;
 DCD 16,key_maplist
 DCD 0,yank_ptr
 DCD 0,wimp_indentstring
 DCD 0,red_data
 DCD &80,red_workarea   ; &80
 DCD 0,font_cinit
 DCD 0,font_cmain
 DCD &20,font_wspace
 DCD 4,menu_handles
 DCD &80,wimp_loglist   ; &80
 DCD &60,key_off
 DCD 0,throw_name
 DCD &20,ext_modes	; &40
 DCD &20,ext_comms	; &80
 DCD &10,ext_messages
 DCD 4,ext_comm_flags
 DCD 0,wimp_clicksend
 DCD if_limit*4,if_bits	; eeek lots of memory :-<
 ;DCD 0,tem_offsets
 DCD -1

;;;;;;;;;;;;;;;;; stack control ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R12=module workspace NO STACK R14=return address
;X R0-R11 corrupt R12 preserved R13=FD stack filled with &ABC00DEF #

init_stack
 FNLDR R0,env_start
 ADD R0,R0,#initial_wimpslot-&8000 ; initial size to claim
; ADD R0,R0,#initial_wimpslot	; initial size to claim
; SUB R0,R0,#&8000
 MOV R1,#-1
 MOV R10,R0			; save slot size asked for
 SWI XWimp_SlotSize		; set wimpslot (CORRUPTS R4 !!!)
 MOVVS PC,R14
 CMP R0,R10
 BLT err$l			; wimp slot is not big enough
 LDR R1,stack_word
 FNLDR R2,env_start
 ADD R13,R2,#stack_size		; set up full descending stack
 FNSTR R13,env_top		; start of free memory
 SUB R3,R13,R2
 B fill_words			; is this needed...?
err$l ERR "Couldn't init_stack"

;X R0=amount unused on stack (still &ABC00DEF) |

free_stack
 STMFD R13!,{R1-R2,R14}
 MOV R0,#0
 FNLDR R1,env_start
 LDR R2,stack_word
fr1
 LDR R14,[R1,R0]
 TEQ R14,R2
 ADDEQ R0,R0,#4
 BEQ fr1
 LDMFD R13!,{R1-R2,PC}
stack_word DCD &ABC00DEF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Claim fixed buffers					   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;X Fixed length bufs claimed Then env_top updated Then bufs cleared #

init_fixed
 FNJSR "R1-R11"
 FNLDR R10,env_top		; current pointer
 ADR R1,table$l
a$l
 LDMIA R1!,{R2-R3}
 CMP R2,#0
 STRPL R10,[R12,R3]		; save buffer address
 ADDPL R10,R10,R2		; next buffer
 BPL a$l
 FNLDR R2,env_top		; start of bufs
 SUB R3,R10,R2			; number of bytes
 MOV R0,R10			; new env_top
 BL set_wimpslot		; claim memory
 FNRTS VS
 MOV R1,#0
 MOVVC R1,#0
 BLVC fill_words		; clear the memory
 FNRTS
table$l
 DCD &100,wimp_buffer
 DCD &100,wimp_block
 DCD &64,car_block		; hex?
 DCD &80,wimp_dzap
 DCD &80,wimp_print
 DCD &200,fnd_macros
 DCD cusr_blk,car_input
 DCD cusr_blk,car_cursor
 DCD cusr_blk,car_selection
 DCD 32,wimp_mzap
 DCD 80,mini_openblk
 DCD &40,menu_memory
 DCD -1

 LOCAL

;X !Config loaded in if found and correct type
;  Options block read and set up.
;  Mode blocks left stored in memory undread until the mode is loaded. #
;  Mode blocks all cleared to 0's.

init_config
 FNJSR "R1-R10"
; BL loadzapredraw
 BL load_config			; R6=addr R7=len
; FNRTS VS
 FNSTR R6,wimp_config,VC		; address of config file
 FNSTR R7,wimp_conlen,VC		; config file length
 MOVVC R1,#0
 ADDVC R2,R12,#opt_mode0
 MOVVC R3,#max_mode*4
 BLVC fill_words			; clear all mode words to 0
 MOVVC R0,#max_mode*4
 BLVC heap_claim			; one word for each mode data entry
; FNRTS VS
 FNSTR R0,opt_modedata,VC		; address of mode data buffers (to be filled)
 MOVVC R1,#0
 MOVVC R2,R0
 MOVVC R3,#max_mode*4
 BLVC fill_words			; clear all mode data pointers
 MOVVC R0,#1
 BL read_given_config_block	; read the options block
 FNRTS VS
 CMP R0,#-1
 BLEQ err$l
 ;FNLDR R14,opt_switches
 ;TST R14,#1 << 21
 ;BLEQ loadzapredraw
; BLVC loadzapredraw
 BLVC update_options		; make any changes required to options block
 FNRTS
err$l ERR "zap_e_badconfig"

 LOCAL

;X R6=address of heap block with the config file in.
;  R7=length #

load_config
 FNJSR "R1-R5"
 MOV R0,#5
 ADR R1,file$l
 SWI XOS_File			; get file info
 BVS err$l			; load default
 TST R0,#1			; file?
 BEQ err$l			; load default
 MOV R7,R4			; file length
 MOV R0,R4			; file length
 BL heap_claim
 FNRTS VS
 MOV R6,R0			; save block address
 MOV R0,#&FF
 ADR R1,file$l
 MOV R2,R6
 MOV R3,#0
 SWI XOS_File			; load the file
 BVS err$l			; problems
 LDR R0,[R6]			; first word of file
 LDR R14,default$l
 TEQ R0,R14
 BNE err$l			; not of correct format
 FNRTS				; file loaded ok
err$l				; load the default file instead
 ;SWI &107
 ;B err$l
 ADDS R0,R0,#0			; clv
 ADR R1,default$l
 MOV R7,#(defend$l-default$l)
 MOV R0,R7
 BL heap_claim
 MOVVC R6,R0
 MOVVC R2,R6
 MOVVC R3,R7
 BLVC move_bytes		; copy in default file
 FNRTS
file$l = "<",|zap$|,"$Options>",0
 ALIGN

default$l			; default config file
 = "Conf"

__global_start$l
 DCD 1				; global storage block
 DCD __global_end$l-__global_start$l	; total length
 DCD 0				; res0
 DCD 0				; res1
 DCD 0				; res2
 DCD 0				; res6
 DCD &F				; opt_info (+or to opt_format, opt_flags)
 DCD 0				; char set for ctrl chars (0-3)
 DCD 10				; default column tab width for windows
 DCD &00100001			; default flags for files/windows scaled+undo
 DCD &00001000			; default format type for windows text+tabs
 DCD 0				; default address of first byte
 DCD 1				; default line number of first line
 DCD 1				; default line spacing
 DCD 0				; default width of margin
 DCD &01020000			; cursor types norm,split1,split4,left
 DCD &0A0A0A0A			; code of newline/linefeed
 DCD &09090909			; code of tab charcters
 DCD 77				; wrapwidth
 DCD 0 ; &00000700		; byte 0=background 1=foreground - HMM!
 DCD &48070105			; switches word ; &00070105
 DCD &FFFFFF00			; reserved 3 ; fg
 DCD &00000000			; reserved 4 ; bg
__global_end$l

	&	2
	&	&54
	FNS	("Text")
	&	&38
	&	&1203004D, &0200000F, &00000000, &00000000
	&	-1
	&	&00000010, &00000010, &FFFFFF10, &FFFFFF10
	&	&00000010, &FFFFFF10, &00000010, &00EEEE10
	&	&0000DD10
	&	4
	&	&00000000

	&	2
	&	&58
	FNS	("Byte")
	&	&3C
	&	&05400010, &0200000F, &00000000, &00000000
	&	-1
	&	&00000010, &00000010, &FFFFFF10, &FFFFFF10
	&	&00000010, &FFFFFF10, &00000010, &00EEEE10
	&	&0000DD10, &FFBB0010
	&	4
	&	&082E0200

	&	2
	&	&58
	FNS	("Word")
	&	&3C
	&	&05400004, &0200000F, &00000000, &00000000
	&	-1
	&	&00000010, &00000010, &FFFFFF10, &FFFFFF10
	&	&00000010, &FFFFFF10, &00000010, &00EEEE10
	&	&0000DD10, &FFBB0010
	&	4
	&	&042E0200

	&	2
	&	&54
	FNS	("ASCII")
	&	&38
	&	&05000040, &0200000F, &00000000, &00000000
	&	-1
	&	&00000010, &00000010, &FFFFFF10, &FFFFFF10
	&	&00000010, &FFFFFF10, &00000010, &00EEEE10
	&	&0000DD10
	&	4
	&	&00000000

	&	2
	&	&B4
	FNS	("Code")
	&	&98
	&	&05000042, &0200000F, &00000000, &00000000
	&	-1
startofcolours$l
	&	&00000010, &00000010, &FFFFFF10, &FFFFFF10
	&	&00000010, &FFFFFF10, &00000010, &00EEEE10
	&	&0000DD10, &99999930, &00BBFF30, &00CC0050
	&	&FFBB0010, &77777710, &BBBBBB10, &99999910
	&	&77777710, &77777710, &DDDDDD10, &BBEEEE10
	&	&00BBFF10, &DDDDDD10, &BBBBBB10, &99999910
	&	&99999910, &DDDDDD10, &00000090, &0000DD50
	&	&0000DD10, &99440010, &0000DD10, &99440010
	&	&00BBFF10
	&	4
	&	&20000000

	&	2
	&	&80
	FNS	("Throwback")
	&	&60
	&	&1201004D, &0200000F, &00000000, &00000000
	&	-1
	&	&00000010, &00000010, &FFFFFF10, &FFFFFF10
	&	&00000010, &FFFFFF10, &00000010, &00EEEE10
	&	&0000DD10, &00BBFF10, &00CC0010, &00EEEE10
	&	&0000DD10, &BBEEEEA0, &008855A0, &BBBBBBA0
	&	&999999A0, &77777710, &55555510
	&	4
	&	&00000000

	&	0	; end of list
defend$l

get_pointer_to_code_cols
 ADR R0,startofcolours$l
 MOV PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Config block handling					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=Block type (1=options block 2,3=mode block)
;  R1=Mode number of block to read if R0=2,3
;X R0=-1 if block not found (+ve otherwise)
;  Block read in and removed from list.

read_given_config_block
 FNJSR "R1-R7"
 MOV R3,R0			; save block type
 MOV R4,R1			; and mode
 FNLDR R6,wimp_config
 FNLDR R7,wimp_conlen
 ADD R5,R6,#4			; first config block
loop$l
 LDR R0,[R5]
 TEQ R0,#0
 BEQ notfound$l
 TEQ R0,R3
 BNE next$l			; not the correct type
 TEQ R0,#2
 TEQNE R0,#3
 BNE found$l			; not a mode block
 ADD R0,R5,#8			; mode name
 BL test_mode_name		; get number if loaded
 FNRTS VS
 TEQ R0,R4
 BEQ found$l			; check its the correct mode
next$l
 LDR R0,[R5,#4]			; block length
 ADD R5,R5,R0			; next block
 B loop$l
notfound$l
 MOV R0,#-1
 FNRTS
found$l				; got the right block
 BL read_config_block		; read in the block (it does wimp_conlen)
 MOVVC R0,#0			; found
 FNRTS

 LOCAL

;E R6=address of config file R7=length of config file
;  R5=pointer to a config file block
;X Block read in and deleted if it can be, skipped otherwise
;  R5,R7,wimp_conlen updated. #

read_config_block
 FNJSR "R1-R4,R6,R8-R11"
 LDR R0,[R5]			; block type
 LDR R4,[R5,#4]
 ADD R4,R5,R4			; next block
 CMP R0,#1
 FNRTS LT			; end of the file
 BEQ opt$l			; standard block
 MOV R11,R0			; save block type for later
 ADD R0,R5,#8
 BL test_mode_name		; R0=mode num / -1 if not found
 FNRTS VS
 ADDS R8,R0,#0			; save mode number
 MOVMI R5,R4			; skip as mode not found
 FNRTS MI
 ADD R0,R5,#8			; mode name
 BL str_len
 ADD R9,R5,R0
 TEQ R11,#2
 BEQ type2$l
 ADD R0,R9,#9			; clone name ***NYI
 ; We'll need to do mode clone handling here later:
 ; - call test_mode_name, and accept the block if (VS | (VC & R0==R8))
 BL str_len
 ADD R9,R9,R0
 ADD R9,R9,#1			; skip extra NUL
type2$l
 ADD R9,R9,#12			; 8+1 term+3 align
 BIC R9,R9,#3			; Zap bit length ...
 LDR R10,[R9],#4		; length of Zap bit
 BL read_conf_mode_data
 FNRTS VS
 ADD R9,R9,R10			; Mode bit length ...
 LDR R10,[R9],#4		; length of mode bit
 MOV R0,R8
 BL read_mode			; R0=unlinked R1=linked
 LDR R0,[R1,#2*e_mode]		; mode num + flags
 TST R0,#1<<10			; do we need to claim block?
 BNE claim$l
 CMP R10,#0
 LDRGT R0,[R9]
 ADDGT R1,R12,#opt_mode0
 STRGT R0,[R1,R8,LSL#2]		; store the word of data
 B end$l
claim$l
 ADD R0,R10,#4			; length of block inc count word
 BL heap_claim
 FNRTS VS
 MOV R2,R0
 ADD R1,R12,#opt_mode0
 STR R2,[R1,R8,LSL#2]		; save pointer to the block
 ADD R0,R10,#4
 STR R0,[R2],#4			; save total block length
 MOV R1,R9
 MOV R3,R10
 BL move_bytes			; copy in the data
 B end$l
opt$l				; main options block
 ADD R1,R5,#8
 ADD R2,R12,#opt_start
 MOV R3,#(opt_end-opt_start)
 BL move_bytes
end$l				; finished - delete the block
 MOV R1,R4
 MOV R2,R5
 SUB R3,R4,R6
 SUB R3,R7,R3
 BL move_bytes
 SUB R0,R4,R5			; amount deleted
 SUB R7,R7,R0
 FNSTR R7,wimp_conlen
 FNRTS

 LOCAL

;E R6=address of config file, R7=length
;  R0=mode number to add block for / -1 for main global block
;X Block added to end of config file & R6,R7,wimp_con* updated

write_config_block
 FNJSR "R1-R5,R8-R11"
 ADD R5,R6,R7			; after 0
 SUB R5,R5,#4			; start for this block
 ADDS R8,R0,#0			; R8=save mode number
 BMI opt$l			; do main block
 BL read_mode			; R1=linked mode table
 CMP R1,#0			; was this a valid mode?
 FNRTS LE			; Mode not valid so exits
 ADD R0,R12,#opt_mode0
 LDR R4,[R0,R8,LSL#2]		; mode word contents
 LDR R10,[R1,#e_mode*2]		; mode flags
 TST R10,#1<<10
 MOVEQ R11,#4			; size of the mode block
 BEQ a$l
 CMP R4,#0			; valid contents?
 FNRTS LE
 LDR R0,[R4]
 SUB R11,R0,#4			; size of the mode block
a$l				; R4=opt_moden R10=flags R11=mode blk len
 FNLDR R3,opt_modedata		; R1=linked mode table
 LDR R3,[R3,R8,LSL#2]		; pointer to my data for this mode
 LDR R0,[R3]
 BIC R0,R0,#&FF000000		; length of block (length word -> -1)
 ADD R0,R0,R11			; add length of mode block
 ADD R0,R0,#64			; 12+4+blk+4+blk=28+blks, plus space for name
 BL ensure_config_block
 FNRTS VS
 MOV R0,#3
 STR R0,[R5]			; block code
 LDR R2,[R1,#e_title*2]		; address of mode name
 PUSH "R1"
 ADD R1,R5,#8
 BL strcopy			; copy in mode name
 PULL "R14"
 LDR R2,[R14,#e_title*2]	; address of clone name ***NYI [+4]
 BL strcopy			; copy in clone name
 ADD R1,R1,#3
 BIC R9,R1,#3			; next place to write (Zap block)
 BL write_conf_mode_data	; write the data block (below)
 FNRTS VS
 STR R11,[R9],#4		; size of mode block
 TST R10,#1<<10
 STREQ R4,[R9],#4		; mode word contents
 BEQ end$l
 ADD R1,R4,#4
 MOV R2,R9
 MOV R3,R11
 BL move_bytes
 ADD R9,R9,R11
end$l				; R5=block start R9=block end
 SUB R0,R9,R5			; block length
 STR R0,[R5,#4]			; save
 MOV R0,#0
 STR R0,[R9],#4			; add terminator
 SUB R7,R9,R6			; new length
 FNSTR R7,wimp_conlen
 FNRTS
opt$l				; do main options block
 CMN R0,#1
 BLT version$l
 MOV R0,#1
 STR R0,[R5]
 MOV R3,#opt_end-opt_start
 ADD R0,R3,#16
 BL ensure_config_block
 FNRTS VS
 ADD R1,R12,#opt_start
 ADD R2,R5,#8
 ADD R9,R2,R3
 BL move_bytes
 B end$l
version$l
 MOV R0,#-1
 STR R0,[R5]
 MOV R0,#12
 BL ensure_config_block
 ADR R0,version_info$l
 LDMIA R0,{R0-R2}
 ADD R9,R5,#8
 STMIA R9!,{R0-R2}
 B end$l
version_info$l
 & version_major, version_minor, version_config

;E R5=current posn R6=start of config block R7=current length
;  R0=size of block to insert
;X Block made big enough

ensure_config_block
 FNJSR "R1"
 ADD R1,R0,R7			; size block needs to be
 SUB R5,R5,R6			; offset into block
 MOV R0,R6
 BL heap_ensure
 FNSTR R0,wimp_config,VC
 MOVVC R6,R0
 ADDVC R5,R6,R5			; new posn in block
 FNRTS

;E R3=pointer to mode data block R9=pointer to output buffer
;X Block copied, R9 updated #

write_conf_mode_data
 FNJSR "R1-R5"
 MOV R4,R3			; source block
 LDR R5,[R4],#4			; block length etc
 MOV R3,R5,LSR#22		; size of mode data
 BIC R5,R5,#&FF000000		; actual block len (len word -> -1)
 STR R5,[R9],#4
 MOV R1,R4			; start of mode data
 MOV R2,R9
 ADD R9,R9,R3
 SUB R5,R5,R3			; length word + col data
 ADD R4,R4,R3			; start of colour data
 BL move_bytes
 MOV R0,#-1
 STR R0,[R9],#4
 MOV R1,R4
 MOV R2,R9
 SUB R3,R5,#4
 ADD R9,R9,R3
 BL move_bytes
 FNRTS

;X Options block updated to new format

update_options
 FNJSR "R1-R4"
 FNLDR R0,opt_minicols
 TEQ R0,#0
 FNRTS EQ			; up to date
 AND R14,R0,#&F
 FNSTR R14,opt_minibac		; background wimp colour
 MOV R0,R0,LSR#8
 AND R0,R0,#&F
 FNSTR R0,opt_minifor		; foreground wimp colour
 MOV R0,#0
 FNSTR R0,opt_minicols		; this is now clear
 MOV R0,#1			; convert wimp to 24 bit
 ADD R1,R12,#red_flags		; redraw block
 ADD R2,R12,#opt_minibac
 MOV R3,R2
 MOV R4,#2			; 2 palette entries
 FNRTS VS
 SWI XZapRedraw_CreatePalette
 SUBS R14,R14,R14		; clv
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Startup						    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;X Environment string read to start of free memory #

init_envstring
 FNJSR "R1-R2"
 SWI XOS_GetEnv
 FNRTS VS
 MOV R2,R0			; environment string
 FNLDR R1,env_top
 FNSTR R1,env_string
 BL strcopy			; copy in the string
 ADD R1,R1,#4
 BIC R1,R1,#3
 FNSTR R1,env_top		; new env top
 FNRTS

 LOCAL

;X Looks at the environment string and loads any file after "Zap " WD #

init_load
 FNJSR "R1-R5"
; BL env_noicon_check
; LDR R2,[R2,#8]
; CMP R2,#0
; FNRTS LE
; SWI &107
 FNLDR R5,env_string		; pointer to environment string
 LDR R0,[R5],#4			; get first word
 LDR R1,zap$l
 TEQ R0,R1
 FNRTS NE			; no match

 MOV R0,R5
 BL str_len
loop1$l
 LDRB R14,[R5,R0]
 CMP R14,#32
 SUBLE R0,R0,#1
 BLE loop1$l
loop2$l
 LDRB R14,[R5,R0]
 CMP R14,#32
 SUBGT R0,R0,#1
 BGT loop2$l

 ADD R2,R5,R0
 ADD R2,R2,#1			; skipping that space...
 LDRB R14,[R2]
 CMP R14,#'-'
 CMPNE R14,#&20
 FNRTS LE			; no match

;  MOV R5,R2
; skip$l
;  LDRB R0,[R5],#1
;  CMP R0,#&20
;  FNRTS CC			; no match
;  BEQ skip$l			; skip spaces
;  SUB R2,R5,#1			; start of filename

; LDRB R14,[R2]
; CMP R14,#&20
; FNRTS CC
 FNLDR R1,wimp_data
 MOV R3,#&100
 MOV R4,#&20			; low limit/terminator...? (was &20)
 BL strmove			; copy filename to buffer stripping spaces
 FNLDR R0,wimp_data
 BL install_file
 FNRTS
zap$l = "Zap "

 LOCAL

;X Config file written and options saved

 DCD 7
Saveoptions
 FNJSR
 FNLDR R6,wimp_config
 FNLDR R7,wimp_conlen
 MOV R10,R7			; save orginal length of file
 MVN R4,#1			; first block to add in
su10
 MOV R0,R4			; block to add
 BL write_config_block		; add it
 FNRTS VS
 ADD R4,R4,#1			; next mode
 CMP R4,#max_mode
 BLT su10
 MOV R0,#&0A
 ADR R1,file$l
 MOV R2,   #&F00
 ORR R2,R2,#&0FD		; data file type
 MOV R3,#0
 MOV R4,R6
 ADD R5,R6,R7
 SWI XOS_File			; write the file
 MOVVC R7,R10			; original length of file
 ADDVC R6,R6,R7
 MOVVC R0,#0
 STRVC R0,[R6,#-4]		; put it back to what it was
 FNSTR R7,wimp_conlen,VC
 FNRTS
file$l = "<",|zap$|,"$Options>",0
 ALIGN

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Some error code						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; generate an error block, with error number offset $a and message $b

	MACRO
$la	FNerr $a,$b
$la	ADD R0,PC,#0			; address of the error message
	B lookup_error			; return with an error
	DCD (ENUM+$a)			; the error number
	= $b,0
	ALIGN
	MEND

err3 FNerr 3,("zap_e_badnum")
err12 FNerr 12,("zap_ReadOnly")
err23 FNerr 23,("zap_e_invmode")
err41 FNerr 41,("zap_e_wrongtype")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Helpful error messages				    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=file object type R1=file name
;X If object cannot have file type operations done then
;  error formed in WD #

check_object_type
 TST R0,#1
 MOVNE PC,R14			; is a file
 FNJSR "R1-R7"
 MOV R3,R0			; save object type
 MOV R4,R1			; source name
 TST R3,#2
 ADREQ R0,notfound$l
 ADRNE R0,directory$l
 MOV R2,#0
 BL lookup_error
 FNRTS
notfound$l
 & ENUM+2
 FNS ("zap_e_notfound")
directory$l
 & ENUM+2
 FNS ("zap_e_isadir")

 LOCAL

;E R0=error message R1=string to append to error message
;X R0=error message + ": " + string in WD and V flag set #

generate_error
 FNJSR "R1-R3"
 MOV R3,R1
 FNLDR R1,wimp_data
 MOV R2,R0
 LDR R0,num$l
 STR R0,[R1],#4
 BL strcpy
 ADR R2,fill$l
 BL strcpy
 FNLDR R0,wimp_data
 SUB R0,R1,R0
 RSB R0,R0,#256
 MOV R2,R3
 BL strbuf
 FNPULL
 FNLDR R0,wimp_data
 ORRS PC,R14,#Vbit
num$l  DCD ENUM
fill$l FNS (": ")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Load file listing external file objects		;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;X External file loaded and contents stored

init_external
 FNJSR "R1"
 ADR R0,sub$l
 ADR R1,fname$l
 BL str_readfile
 FNRTS
fname$l = "<",|zap$|,"$External>",0
 ALIGN
sub$l				; R10=pointer to external file ended by a 0
 FNJSR "R1-R4,R10"
line$l				; next line loop
 LDRB R0,[R10]
 TEQ R0,#0
 FNRTS EQ			; end
 CMP R0,#'|'			; comment?
 CMPNE R0,#&20			; or starts with a space/tab or is empty?
 BLE next$l			; if so...
 MOV R0,R10
 BL str_len			; length of the line
 CMP R0,#2
 BLT next$l			; invalid
 ADD R1,R10,R0
 LDRB R14,[R1,#-1]
 TEQ R14,#'*'
 LDREQB R14,[R1,#-2]
 TEQEQ R14,#&20
 MOVEQ R14,#10
 STREQB R14,[R1,#-2]		; partition off any *'s
 ADD R0,R0,#2			; include terminator(s)
 BL heap_claim
 FNRTS VS
 MOV R4,R0			; save the buffer address
 PUSH "R4"
 MOV R2,R10
 MOV R1,R4
 MOV R3,#&100
 MOV R4,#&20
 BL strmove			; copy the file name
 PULL "R4"
 BL str_jump			; jump to next argument
 ADD R1,R1,#1
 MOV R3,R1			; save start of second argument
 MOV R2,R10
 BL strcopy			; copy the second arg (if there is one)
 BL str_next			; start of next line
 LDRB R0,[R10]
 TEQ R0,#'*'
 BEQ start$l			; start the mode now
 SUB R10,R10,#1			; re-read this line
 MOV R3,#0			; current extension type (mode names atm)
object$l			; next object loop
 BL str_next			; start of next line
 FNRTS CS			; end of file
 MOV R1,R10
 BL str_skip			; skip spaces and tabs
 CMP R1,R10
 BEQ line$l			; weren't any to skip - not indented
 LDRB R0,[R10]
 TEQ R0,#'-'
 ADDEQ R3,R3,#1			; onto the next object type
 BEQ object$l
 BL add_external_object
 BVC object$l
 FNRTS
next$l				; skip to start of next line
 BL str_next
 B line$l
start$l				; load the module and do a command
 LDRB R0,[R3]
 CMP R0,#&20
 MOVGT R0,R3
 SWIGT XWimp_StartTask		; do the command if there is one
 MOVVC R0,#1
 MOVVC R1,R4
 SWIVC XOS_Module		; load the module
 MOVVC R0,R4
 BLVC heap_free
 FNRTS VS
 B next$l			; move onto next module

 LOCAL

; ext_modes,ext_comms,ext_messages contain 0 termianted lists
; of mode names,command names,messages numbers (the first two followed
; by zeros 'till the next alignment) followed by a pointer to the module
; file to load to install that mode, command etc (zero if freed)
; The module file name is of the form <module name>,0,<extra file>,0
; The extra file will be Wimptasked before the module is loaded.
; Each command name is followed by a flags word (the same as is stored
; immediately before the command's entry point). If the word isn't specified
; in the file, then &80000000 is used to indicate this.

;E R10=pointer to mode/command name/message number string
;  R3=object type (0=mode 1=command 2=message)
;  R4=pointer to name of module to load to deal with this command/mode/mess
;X Object added #

add_external_object
 FNJSR "R1-R6,R10"
 CMP R3,#3
 FNRTS CS			; illegal type
 ADR R14,list$l
 LDR R2,[R14,R3,LSL#2]
 LDR R5,[R12,R2]		; list pointer
 MOV R1,R5
findend$l
 LDR R0,[R1]
 TEQ R0,#0
 BEQ found$l
 TEQ R3,#2
 ADDEQ R1,R1,#8
 BEQ findend$l
a$l
 LDRB R0,[R1],#1
 TEQ R0,#0
 BNE a$l
 ADD R1,R1,#7
 BIC R1,R1,#3			; align + skip the address
 B findend$l
found$l
 SUB R6,R1,R5			; current list length
 MOV R0,R10
 TEQ R3,#2
 MOVEQ R0,#4
 BLNE str_len			; R0=length of argument
 ADD R1,R6,R0
 ADD R1,R1,#20+63		; +term (4) +addr (4)+ listterm(4)
 BIC R1,R1,#63			; align to next 64 boundry
 MOV R0,R5
 BL heap_ensure
 FNRTS VS
 STR R0,[R12,R2]		; new list pointer
 ADD R1,R0,R6			; start of the entry
 TEQ R3,#2
 BEQ num$l
copy$l				; copy the string (make upper case if comm)
 LDRB R0,[R10],#1
 TEQ R3,#1			; command ?
 BNE c$l			; no
 SUB R14,R0,#'a'
 CMP R14,#26
 ADDCC R0,R14,#'A'		; convert to upper case
c$l
 CMP R0,#&20
 STRGTB R0,[R1],#1
 BGT copy$l			; do next byte
 MOV R0,#0
b$l
 STRB R0,[R1],#1		; add terminator
 TST R1,#3
 BNE b$l			; until aligned
 TEQ R3,#1			; command?
 BNE end$l			; no
 BL str_skip
 FNRTS VS
 BL str_readnum
 MOVVS R0,#&80000000		; if there's an error
 ADDS R0,R0,#0			; CLV
 MOVVC R2,R0
 MOVVC R3,R1
 FNLDR R0,ext_comm_flags,VC	; flags words list:
 MOVVC R1,#4
 BLVC heap_extend
 FNRTS VS
 LDR R1,[R0]
 FNSTR R0,ext_comm_flags
 STR R2,[R0,R1]			; write flags word
 ADD R1,R1,#4
 STR R1,[R0]
 MOV R1,R3
 B end$l
num$l
 BL str_readnum
 FNRTS VS
 STR R0,[R1],#4
end$l
 MOV R14,#0
 STMIA R1,{R4,R14}		; address of filename, terminator
 FNRTS
list$l
 DCD ext_modes
 DCD ext_comms
 DCD ext_messages

 LOCAL

;E R0=address of module name to remove (it has now been loaded)
;  Never want to try loading something twice!!
;X Object removed from external lists (or replaced with 0) so it's never
;  again loaded. Heap block containing name is freed.

remove_external_object
 FNJSR "R1-R4"
 MOV R4,R0			; save pointer to module name
 FNLDR R1,ext_modes		; remove from external modes
 BL sub$l
 FNLDR R1,ext_comms		; remove from external commands
 BL sub$l
 FNLDR R1,ext_messages
a$l
 LDMIA R1!,{R0,R14}
 CMP R0,#0
 BLE end$l
 TEQ R14,R4
 MOVEQ R14,#0
 STREQ R14,[R1,#-4]
 B a$l
end$l
 MOV R0,R4
 BL heap_free
 FNRTS
sub$l				; string handling
 FNJSR
b$l
 MOV R0,R1
 BL str_len
 CMP R0,#0
 FNRTS LE			; reached the end
 ADD R1,R1,R0
 ADD R1,R1,#4
 BIC R1,R1,#3
 LDR R0,[R1],#4
 TEQ R0,R4
 MOVEQ R14,#0
 STREQ R14,[R1,#-4]
 B b$l

 END
