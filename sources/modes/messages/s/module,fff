; s/module,fff
; converted from makefile.bas by bas2asm.pl
	GET	h.ZapMsg

	DCD	0x00
	DCD	StartUpHere
	DCD	0x00
	DCD	0x00
	DCD	D1
	DCD	ModHelpString
	DCD	D1
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	module_flags

w_formmb
	DCD	0
	DCD	0
	DCD	0

D1	=	"ZapMsg"
	DCW	0
	DCD	0
	DCD	0
	DCD	0
	DCD	D2
	=	0

D2	=	27,0," provides support for",27,2,"Zap editor.",13
	=	"It provides a syntax-colouring mode for messages ",27,7,"s.",0
	ALIGN

ModHelpString
	=	"ZapMsg",9,9,"0.27 (00 Jan 0000) © "
lp1	=	"Tim Tyler",0
	ALIGN

module_flags
	DCD	1			; 32 bit compatible


		; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Data3
	=	"Zap", 0x00
	DCD	0x00
StartUpHere
	STMFD	sp!, {lr}
	LDR	r2, [r12, #0]
	CMP	r2, #0
	BNE	ModuleInit
	MOV	r0, #6
	MOV	r3, #0x20
	SWI	XOS_Module
	LDMVSFD	sp!, {pc}
	STR	r2, [r12, #0]
	ADRL	r0, Data47
	STR	r2, [r0, #0]
	MOV	r0, #0
	STR	r0, [r2, #20]
ModuleInit
	MOV	r0, #4
	STR	r0, [r2, #12]
	MOV	r0, #0x12
	ADR	r1, Data3
	SWI	XOS_Module
	MOV	r12, r4
RefDataTab
	ADR	r0, DataTable
	FNcall	0
	LDMFD	sp!, {pc}

MsgLabeled
	=	"Messages"
	DCD	0x00

DataTable
	DCD	DataTable
	DCD	MsgLabeled
	DCD	lp1
	DCD	0x00	;  REM = BaseMode = Text
	DCD	0x40D	;  REM mode = 13 ; bit 10 = workspace, please!
	DCD	Initialisation	;  REM init
	DCD	0	;  MnuDta; REM &00 ; menu...extension menu
	DCD	Initialisation - DataTable	;  REM size of table ; len
	DCD	0	;  postload ; 0
	DCD	0	;  REM beforesave ; e_presave  \ called before being saved
	DCD	0
	DCD	0;E_Start	;  REM e_start            \ window entering this mode
	DCD	0;E_End	;  REM e_end                \ window leaving this mode
	DCD	0x00	;  REM e-width              \ find work area width
	DCD	0	; mode_calllinecol ; mode_linecol
	DCD	0x00
	DCD	0	; mode_callclnlog ; mode_clnlog
	DCD	0	; mode_callclnphy ; mode_clnphy - physical to file offsel
	DCD	0	; mode_callclnoff ; mode_clnoff
	DCD	0	; mode_callnextline ; mode_nextline
	DCD	0	; mode_minus ; mode_minus
	DCD	0	; mode_plus ; mode_plus
	DCD	0	; sminus ; REM lp3 ;e_sminus       \ perform shift-left
	DCD	0	;  splus  ; REM lp4 ;e_splus        \ perform shift-right
	DCD	0	; mode_cminus ;mode_cminus
	DCD	0	; mode_cplus ; mode_cplus
	DCD	redrawline	; e_redrawline \ redraw display line
	DCD	0x00	; mode_redrawlnum
	DCD	0x00
	DCD	0x00
	DCD	0	;  REM Tabular ; e_tab           \ tab key pressed
	DCD	0x00
	DCD	0x00
	DCD	0	;  BranchSave% ; REM &00 trytwo ; REM e_saveandrun
	DCD	0	; mode_calllinestart
	DCD	0	; mode_calllineend;mode_lineend
	DCD	0	; mode_calllinenext;mode_linenext
	DCD	0	; mode_calllineprev;mode_lineprev
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0	;  BranchSave% ; REM e_compile \ compile & run and don't exit
	DCD	0x00
	DCD	0	; JustRun ; REM e_run     \ run the program being edited
	DCD	0	; JustRun ; REM e_runandquit \  run
	DCD	0x00	;  REM e_basic   \ drops into language...?
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0x00	;  REM e_setwidth - changing window width
	DCD	0x00
	DCD	mode_prevline	;  redrawA ; REM e_prevline \ find start of update reg'n; Easy!
	;DCD	0	; openwindow


Initialisation
	CMP	r1, #9
	BEQ	spellcheck
	;CMP	r1, #7
	;BEQ	amenucreation
	CMP	r1, #1
	MOVCC	pc, lr
	STREQ	r0, [r11, #4]
	STREQ	r0, modenumberlocal
	TEQ	r1, #6
	ADREQ	r1, MenuExtension
	MOVEQ	pc, lr
	TEQ	r1, #2
	MOVNE	pc, lr
	STMFD	sp!, {r1, r7, r8, lr}
		;  REM here? yes!
	MOV	r8, #0
	BL	ZapModeWord
	TEQ	r7, #0
	BEQ	nocfginit
	LDR	r0, [r7, #0]
	CMP	r0, #zizeofcfgwksp
	LDMEQFD	sp!, {r1, r7, r8, pc}
		;  REM no !Config...
nocfginit
	MOV	r0, #0x11
	FNcall	Zap_ModeColourNum	;  REM change palette size.
	TEQ	r7, #0
	BEQ	noheapblkatall
	LDR	r1, [r7, #0]
	TEQ	r1, #zizeofcfgwksp
	BEQ	justendtheresnoneed
	MOV	r1, #zizeofcfgwksp	;  REM all vc
	MOV	r0, r7
	LDR	lr, [r12, #0]
	ADD	lr, lr, #8	;  REM zap call - ensure heap block
	STMFD	sp!, {lr}
	MOV	lr, pc
	LDMFD	sp!, {pc}
	MOV	r7, r0
	STR	r1, [r7, #0]
	BL	OnToWrtMdeWrd
noheapblkatall
	MOV	r0, #zizeofcfgwksp
	LDR	lr, [r12, #0]
	ADD	lr, lr, #4	;  REM zap call - start heap block
	STMFD	sp!, {lr}
	MOV	lr, pc
	LDMFD	sp!, {pc}
	MOV	r7, r0
	BL	OnToWrtMdeWrd
	MOV	r0, #zizeofcfgwksp	;  REM vc
	STR	r0, [r7]
	MOV	r0, #0
	STR	r0, [r7, #4]
	MOV	r0, #0x0D
	STR	r0, [r7, #8]
	LDR	r0, startupformatwd
	STR	r0, [r7, #0x0C]
	LDRVC	r0, SDsasa	;  REM DATA 5%/8% ! vc= no !config file ?
	LDRVC	r1, [r11, #4]
	MOVVC	r2, #0
	LDRVC	lr, [r12, #0]
	ADDVC	lr, lr, #0x0184	;  REM call - RD/WRT Zap data mode words.
	STMVCFD	sp!, {lr}
	MOVVC	lr, pc
	LDMVCFD	sp!, {pc}
	BLVC	UnkPreColBit	;  REM to set up colours with zmcs
justendtheresnoneed
	LDMFD	sp!, {r1, r7, r8, pc}

SDsasa	DCD     0x1203004D


startupformatwd
	DCD	0x77800000
MenuExtension
	=	"Comments",0
	=	"%...",0
	=	"Punctuation",0
	=	"Text",0
	=	"Separator",0
	=	"MsgTrans(\\)",0
	=	"Aliases",0
	=	"Colon",0
	=	"GSTrans",0
	=	"Wild Cards",0
	=	0
	ALIGN


UnkPreColBit
	STMFD	sp!, {r1-r4, lr}
	ADR	r3, DefaultColours
	LDR	r1, [r11, #4]	;  REM normally 0
PreZModColBit
	MOV	r2, #0x09	;  REM start colours
ZModColBit
	LDRB	r0, [r3], #1
	FNcall	Zap_ModeColour	;  REM Read colour definitions
	LDMVSFD	sp!, {r1-r4, pc}
	ADD	r2, r2, #1
	TEQ	r2, #0x13	;  REM max colours
	BNE	ZModColBit
	LDMFD	sp!, {r1-r4, pc}
DefaultColours
		;  REM Colour Numbers :
	=	0x0A	;  REM Comment Colour =&9
	=	0x0F	;  REM String colour  =&A
	=	0x01	;  REM Punctuation    =&B
	=	0x0C	;  REM Embedded {}    =&C
	=	0x09	;  REM Commands       =&D
	=	0x0D	;  REM Misc Punct.    =&E
	=	0x0E	;  REM Number colour  =&F
	=	0x0B	;  REM Error colour   =&10
	=	0x03	;  REM GSTrans        =&11
	=	0x0E	;  REM Unknown        =&12
	=	0,0	;  REM double zero termination !
	ALIGN



ZapModeWord
	STMFD	sp!, {r0-r2, lr}
	LDR	r1, [r11, #4]
	LDR	r2, [r12, #0]
	ADD	r2, r2, #0x0164	;  REM Zap_GetModeWord - read mode word
	MOV	lr, pc
	MOV	pc, r2
	MOV	r7, r0
	LDMFD	sp!, {r0-r2, pc}

OnToWrtMdeWrd
	STMFD	sp!, {r0-r2, lr}
	LDR	r1, [r11, #4]
WrtMdeWrd
	MOV	r0, r7
	LDR	r2, [r12, #0]
	ADD	r2, r2, #0x0168	;  REM zap call...write the mode word
	MOV	lr, pc
	MOV	pc, r2
	LDMFD	sp!, {r0-r2, pc}


; ------------ e_redrawline --------------

redrawline
	STMFD	sp!, {r6, r12, lr}
	STMFD	sp!, {r7, r11}
	BL	Branch208
	BL	ZapModeWord
	LDR	r2, [r7, #8]	;  REM Preserved start colour & flags
	LDR	r3, [r7, #0x0C]
	ADRL	r12, w_formmb
	STR	r3, [r12, #8]
	LDMFD	sp!, {r7, r11}	;  REM calls...
	LDR	r3, [r8, #60]	;  REM char width of cached line (x 8)
	STR	r4, [r12]
	LDRB	r12, [r8, #88]	;  REM ? At very beginning.
	BIC	r2, r2, #0x700
	BIC	r2, r2, #0xFF
	ORR	r2, r2, #0x0D
	ORR	r2, r2, #0xF000	;  REM ! ; fe? ; ff000
	BIC	r2, r2, #0x00E00000	;  REM HERE? &0F000000
	LDR	r5, [r9, #0]	;  REM ?
	LDR	r10, [r9, #4]	;  REM ?
	ADD	r10, r10, r5
	TEQ	r7, r10
	LDMEQFD	sp!, {r6, r12, pc}	;  REM end - return for good!
	LDR	r10, [r9, #56]	;  REM ?
	ADD	r10, r10, r5
	CMP	r7, r10
	MOVCC	r10, r5
	MOV	r6, #0
BitAftStart
	SUB	r6, r6, #1
	LDRB	r0, [r7], #-1
	TEQ	r0, r12
	BEQ	UpToStart
	CMP	r7, r10
	BCS	BitAftStart
	TEQ	r5, r10
	LDRNE	r10, [r9, #60]
	SUBNE	r7, r7, r10
	MOVNE	r10, r5
	CMP	r7, r10
	BCS	BitAftStart
	SUB	R6,R6,#1	; cl fix
	SUB	R7,R7,#1	;
UpToStart			;
	ADDS	r6, r6, #2	;
	ADD	r7, r7, #2	;
	SUBPL	r7, r7, r6
	LDMPLFD	sp, {r6}
	TEQ	r5, r10
	LDREQ	r10, [r9, #52]	;  REM ?
	ADDEQ	r10, r10, r5
	LDRNE	r10, [r9, #60]	;  REM ?
	ADDNE	r5, r5, r10
	LDRNE	r10, [r9, #8]	;  REM ?
	ADDNE	r10, r10, r5
	LDRB	r0, [r8, #144]	;  REM         endchar?
	ORR	r12, r12, r0, LSL #24
	LDR	r0, [r8, #100]	;  REM         width.
	ORR	r12, r12, r0, LSL #12
RtAtStrtA
	MOV	lr, #0
RtAtStrtB
	CMP	r7, r10	;  REM EOF?
	BCC	Branch13
	LDR	r10, [r9, #8]
	ADD	r10, r10, r5
	CMP	r7, r10
	LDMCSFD	sp!, {r6, r12, pc}
	LDR	r1, [r9, #60]	;  REM ???
	ADD	r7, r7, r1
	ADD	r5, r5, r1
	ADD	r10, r10, r1
Branch13
	LDRB	r0, [r7], #1	;  REM get char
	AND	r1, r12, #0xFF
	EOR	r2, r2, #0x0400	;  REM newline? ; alternating colour...
	TEQ	r0, r1
	TSTEQ	r2, #0x0400
	BICEQ	r2, r2, #0x700	;  REM THIS CODE IS NEVER EXECUTED...
	BICEQ	r2, r2, #0xFF
	ORREQ	r2, r2, #0x0D
	BEQ	RtAtStrtB
	BIC	r2, r2, #0x0400
	TEQ	r0, r1
	BEQ	BranchNL	; REM Jeez, what a mess...
	CMP	r6, #0	;  REM wed morn-reinit
	MOVGT	r1, #1
	STRGTB	r1, [r6, r3,LSL #1]
	AND	r1, r2, #0xFF
	CMP	r1, #0x0D
	BEQ	BNL2
Backhome
	AND	r1, r2, #0xFF	;  REM Here begins the |G-type GStrans Testing
	CMP	r1, #0x09	;  REM comment
	BEQ	aftertestA
	TEQ	r0, #'>'	;  REM GSTrans Testing1
	BEQ	GSTtest	;  sun OK
GSTstop
	CMP	r6, #0	;  REM Here begins |G-type GStrans testing
	BLE	aftertestA	;  REMaftert7... very dodgy...
	LDR	r1, Sol6	;  REM sun...
	CMP	r6, r1	;  REM sun...
	BLE	aftertestA
	LDRB	r1, [r6, #-1]	;  REM ???
	CMP	r1, #'|'
	BNE	aftertestA
	TEQ	r0,#' '
	TEQNE	r0,r12,LSR #24
	BEQ	TabbingSub
	SUB	r1, r3, #1
	LDRB	r1, [r6, r1]
	TEQ	r1, #0x11
	BEQ	aftertestA
	SUB	r6, r6, #1
	ADD	r6, r6, r3
	MOV	r1, #0x0B
	STRB	r1, [r6]
	ADD	r6, r6, #1
	SUB	r6, r6, r3
	TST	r2, #0x80000000
	BNE	aftertestA
	MOV	r1, #0x11
	STRB	r1, [r6, r3]
	B	AfterColour
aftert7
	LDR	r1, Sol7
	CMP	r7, r1
	BLE	aftertestA	;  REM code never fires?
	LDRB	r1, [r7, #-2]	;  REM in hope
	CMP	r1, #'|'
	BEQ	AfterColour
aftertestA
	CMP	r0, #'0'
	BLT	afterttA
	CMP	r0, #'9'
	BLE	okaftts7
	CMP	r0, #'A'
	BLT	afterttA
okaftts7
	CMP	r6, #0	;  REM Here begins more testing
	BLE	aftt7
	LDR	r1, Sol6	;  sun WK
	CMP	r6, r1	;  sun WK
	BLE	aftt7	;  sun WK
	LDRB	r1, [r6, #-1]
	CMP	r1, #'`'
	BNE	afterttA
	SUB	r1, r3, #1
	LDRB	r1, [r6, r1]
	TEQ	r1, #0x0B
	BEQ	afterttA
	SUB	r1, r3, #1
	MOV	r0, #0x0B
	STRB	r0, [r6, r1]
	MOV	r0, #0x0F
	STRB	r0, [r6, r3]
	LDRB	r0, [r7, #-1]
	B	AfterColour
aftt7
	LDR	r1, Sol7
	ADD	r1, r1, #2
	CMP	r7, r1
	BLE	afterttA	;  REM code never fires?
	LDRB	r1, [r7, #-2]	;  REM in hope
	CMP	r1, #'`'
	BEQ	AfterColour
afterttA
	CMP	r6, #0	;  REM Here begins more testing
	BLE	aftt7D
	LDR	r1, Sol6	;
	CMP	r6, r1	;
	BLE	aftt7D	;
	LDRB	r1, [r6, #-1]
	CMP	r1, #'\'
	BNE	endaftt
	SUB	r1, r3, #1
	LDRB	r1, [r6, r1]
	TEQ	r1, #0x0E
	BEQ	endaftt
	SUB	r1, r3, #1
	MOV	r0, #0x0B
	STRB	r0, [r6, r1]
	MOV	r0, #0x0E
	STRB	r0, [r6, r3]
	LDRB	r0, [r7, #-1]
	B	BeforeColour	;  AfterColour%
aftt7D
	LDR	r1, Sol7
	ADD	r1, r1, #2
	CMP	r7, r1
	BLE	endaftt	;  REM code never fires?
	LDRB	r1, [r7, #-2]	;  REM in hope
	CMP	r1, #'\'
	BEQ	BeforeColour	;  AfterColour%
endaftt
nopechk
	TEQ	r0, #'%'
	BEQ	QuoteBit
	AND	r1, r2, #0xFF
	CMP	r1, #0x0A
	BNE	nottestond
	CMP	r0, #'0'
	BLT	testond
	CMP	r0, #'9'
	BLE	nottestond
	CMP	r0, #'z'
	BGT	testond
	CMP	r0, #'a'
	BGE	nottestond
	CMP	r0, #'Z'
	BGT	testond
	CMP	r0, #'A'
	BGE	nottestond
testond
	BIC	r2, r2, #0xFF
	ORR	r2, r2, #0x0C
nottestond
	CMP	r1, #0x09
	BEQ	ComCodeRestart
	CMP	r1, #0x0A
	BEQ	BeforeColour
	TEQ	r0, #':'
	BEQ	CurlyBrackOpen
	TST	r2, #0x10000000	;  REM START OF LINE FLAG...
	BNE	NotatStart
	TEQ	r0, #'#'
	TEQNE	r0, #';'
	TSTEQ	r2, #0x04000000
	BEQ	CommentStart
	CMP	r0, #'?'	;  REM ; make yellow?
	MOVEQ	r1, #0x12	;  REM
	BEQ	r1setup
	CMP	r0, #'/'	;  REM ; make yellow?
	BICEQ	r2, r2, #0xFF	;  REM COL cream/normal - lt grey (= &0B);
	ORREQ	r2, r2, #0x0E	;  REM testing very dubious TST code...
	MOVEQ	r1, #0x0D
	BEQ	fromslash
NotatStart
	AND	r1, r2, #0xFF
	TEQ	r1, #0x0C	;  REM COL Errors/Redirection  ...new
	BEQ	SymbolChecking
afterteststop
	AND	r1, r2, #0xFF
	TEQ	r1, #0x02	;  REM ????
	BEQ	NotANumber
	TEQ	r1, #0x0D	;  REM COL Command! NO NuffinUMBERS...
	BICEQ	r2, r2, #0xFF
	ORREQ	r2, r2, #0x02	;  #&0e!!
	ANDEQ	r1, r2, #0xFF
	TEQ	r1, #0x0E	;  REM COL cream/normal ... NO NUMBERS...
	TEQNE	r1, #0x0F	;  REM COL Orange/Numbers?
	BNE	BeforeColour
NotANumber
	TEQ	r0, #'_'
	BEQ	PlainNoOSChk
	AND	r1, r0, #0xDF
	CMP	r1, #'Z'
	RSBLSS	r1, r1, #'@'
	BLS	PlainNoOSChk
itsoknow
Bother
DontBother
	TST	r2, #0x00E00000
AfterCmdCntChk
	AND	r1, r2, #0xFF
	TEQ	r1, #0x09
	BEQ	BeforeColour
	TEQ	r1, #0x02
	BNE	SymbolChecking	;  REM  BR if not normal colour...
	TEQ	r0, #'_'	;  REM If numbers check for end of numbers
	BEQ	PlainNoOSChk
	CMP	r0, #'9'
	RSBLSS	r1, r0, #'/'	;  REM = asc "0"
PlainNoOSChk
	BICLS	r2, r2, #0xFF
	ORRLS	r2, r2, #0x02
	BLS	BeforeColour
SymbolChecking
	CMP	r6, #0
	BLE	BeforeColour	;  REM BLT     BeforeColour%
	TST	r2, #0x8000000
	BNE	ErrEchConf
	TEQ	r0, #'#'
	TEQNE	r0, #'@'
	TEQNE	r0, #'|'
	MOVEQ	r1, #0x0B
	STREQB	r1, [r6, r3]
	BEQ	AfterColour
BeforeColour
	;  REM NUMBERS?
	TEQ	r0, #' '
	TEQNE	r0, r12, LSR #24	;  REM = tab?
	BEQ	TabbingSub
Branch24
	CMP	r6, #0
	BLE	firstpass	;  REM new addition to test
	ANDGT	r1, r2, #0x1F	;  REM write colours
	STRGTB	r1, [r6, r3]
AfterColour
	CMP	r6, #0
	BLE	firstpass
	STRB	r0, [r6]	;  EQ?
	ADD	r6, r6, #1
firstpass
	ADD	lr, lr, #1
BeginOfEnd
	AND	r1, r12, #0xFF	;  REM end character... yes! At last...
	TEQ	r0, r1	;  REM end character... yes!
	BICEQ	r2, r2, #0x78000000	; REM START OF LINE FLAGS...
	CMP	r6, #0
	ADDLTS	r6, r6, #1
	BMI	RtAtStrtB	;  REM round loop...
	LDMEQFD	sp, {r6}	;  REM huh?
	BEQ	RtAtStrtA
	AND	r1, r12, #0xFF	;  REM end character... yes! At last...
	TEQ	r0, r1	;  REM end character... yes!
	BEQ	tocheckbackwardsnow
	ORRNE	r2, r2, #0x0400
backcheckbackwardsnow
	BIC	r1, r12, #0xFF000000	;  REM if not width...
	CMP	lr, r1, LSR #12
	BICLT	r2, r2, #0x0400
	BLT	RtAtStrtB	;  REM go round loop...
	BEQ	tohaveajollygoodtime
tohaveajollygoodback
	BIC	r0, r12, #0xFF000000
	CMP	lr, r0, LSR #12
	BICGE	r2, r2, #0x0400	;  REM NE
	AND	r0, r12, #0x0200
	ORR	r2, r2, r0
	LDMFD	sp!, {r6, r12}
	STMFD	sp!, {r7, r11}
	BL	Branch208
	BL	ZapModeWord
	STR	r2, [r7, #8]
	LDMFD	sp!, {r7, r11, pc}	;  REM on exit set things up... r7...
fromslash
	CMP	r6, #0
	BLT	BeforeColour
	STRB	r1, [r6, r3]
	B	AfterColour
tohaveajollygoodtime
	STMFD	sp!, {lr}
	LDR	lr, [r9, #f_ptr]
	LDR	r0, [r9, #f_splito]
	ADD	r0, r0, lr
	CMP	r7, r0
	LDREQ	r0, [r9, #f_splits]
	ADDEQ	r0, r0, r7
	MOVNE	r0, r7
	LDR	r1, [r9, #f_bufl]
	ADD	r1, lr, r1
	CMP	r0, r1
	LDRCCB	r0, [r0]	;  Hmm...(Beyond end...?)
	AND	r1, r12, #0xFF	;  REM end character... yes! At last...
	TEQ	r0, r1	;  REM  ! the same length as the width
	ADDEQ	r7, r7, #1
	ADDEQ	r11, r11, #1
	LDMFD	sp!, {lr}
	B	tohaveajollygoodback
tocheckbackwardsnow
	ADD	r11, r11, #1	;  REM This code only executed if <CR>...
	BIC	r2, r2, #0xFF000000	;  REM START OF LINE FLAGS...xxx
	BIC	r2, r2, #0x00F00000
	B	backcheckbackwardsnow
ComCodeRestart
	TEQ	r0, #'_'
	BEQ	AfterCmdCntChk
	AND	r1, r0, #0xDF
	CMP	r1, #'Z'
	RSBLSS	r1, r1, #'@'
	BLS	AfterCmdCntChk
	B	itsoknow
CmdCntChk
	CMP	r0, #32
	BNE	AfterCmdCntChk
	CMP	r6, #0
	LDRGEB	r1, [r6, #-1]	;  REM danger

endaftt11New
	CMP	r1, #32
	BEQ	AfterCmdCntChk
	MOV	r1, r2, LSR #21
	AND	r1, r1, #7
	SUBS	r1, r1, #1
	BICEQ	r2, r2, #0x10000000
	BIC	r2, r2, #0x00E00000
	ORR	r2, r2, r1, LSL #21
	B	AfterCmdCntChk
ErrEchConf
	CMP	r6, #0
	BLE	AfterColour
	AND	r1, r2, #0xFF
	CMP	r1, #0x0F
	BEQ	BeforeColour
	CMP	r1, #0x0E
	MOVEQ	r1, #0x02
	STREQB	r1, [r6, r3]
	TEQ	r0, #' '
	TEQNE	r0, r12, LSR #24	;  REM = tab?
	BEQ	TabbingSub
	B	AfterColour
NotANum2
	B	NotANumber


BranchNL
	TST	r2, #0x10000000	;  REM START OF LINE FLAGS SET...
	BEQ	Bother2
	TST	r2, #0x60000000	;  REM IF/THEN FLAGS SET?
	BEQ	DontBother2
Bother2
DontBother2
	MOV	lr, #0x70000000	;  REM        ;;Jeez, what a mess!;;
	B	BeginOfEnd
BNL2
	BIC	r2, r2, #0x10000000	;  REM START OF LINE FLAGS SET...
	STR	r6, Sol6
	SUB	r1, r7, #1
	STR	r1, Sol7
	B	Backhome

Sol6	DCD	0
Sol7	DCD	0

GSTtest
	CMP	r6, #0
	BLT	GSTstop
	TST	r2, #0x80000000
	BNE	lastonehereis
	MOV	r0, #0
gstchklp
	SUB	r0, r0, #1
	ADD	r1, r6, r0
	CMP	r1, #0
	BLT	notaGSTseq
	LDRB	r1, [r6, r0]
	CMP	r1, #' '
	BLE	notaGSTseq
	CMP	r1, #127
	BGT	notaGSTseq
	CMP	r1, #'<'
	BNE	gstchklp
	ADD	r6, r6, r3
	MOV	r1, #0x0B
	STRB	r1, [r6, r0]
	MOV	r1, #0x11
	ADD	r0, r0, #1
roundAloop
	STRB	r1, [r6, r0]
	ADD	r0, r0, #1
	CMP	r0, #0
	BLT	roundAloop
	SUB	r6, r6, r3
lastonehereis
	MOV	r1, #0x0B
	STRB	r1, [r6, r3]
	MOV	r0, #'>'
	B	AfterColour
notaGSTseq
	MOV	r0, #'>'
	B	GSTstop
modenumberlocal
	DCD	0


		; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CommentStart
	; comments
	AND	r1, r2, #0xFF
	CMP	r1, #0x0A	;  REM in quotes?
	BICNE	r2, r2, #0xFF
	ORRNE	r2, r2, #0x09
	ORRNE	r2, r2, #0x10000000
	B	BeforeColour
QuoteBit
	; "Quotes"
	AND	r1, r2, #0xFF
	CMP	r1, #0x09
	BEQ	BeforeColour
	BIC	r2, r2, #0xFF
	ORR	r2, r2, #0x0A
	B	BeforeColour
CurlyBrack
	; "No {} NUFFIN"
	CMP	r6, #0
	ANDGT	r1, r2, #0x0F
	STRGTB	r1, [r6, r3]
	BIC	r2, r2, #0xFF
	MOV	r1, r2, LSR #24
	AND	r1, r1, #0x01	;  REM Bits for {} depth
	CMP	r1, #0x00
	ORREQ	r2, r2, #0x0E	;  REM COL Cream/Normal
	ORRNE	r2, r2, #0x0C	;  REM COL Grey/Redirected
	B	AfterColour
CurlyBrackOpen
	; originally for ; "{"s
	ORR	r2, r2, #0x10000000
	AND	r1, r2, #0xFF
	TEQ	r1, #0x0A
	TEQNE	r1, #0x09
	TEQNE	r1, #0x0C
	BEQ	BeforeColour
	BIC	r2, r2, #0xFF
	ORR	r2, r2, #0x0C
	ORR	r2, r2, #0x1000000
	ORR	r12, r12, #0x0200
	MOV	r1, #0x10
r1setup
	CMP	r6, #0
	BLT	AfterColour
	STRB	r1, [r6, r3]
	B	AfterColour
CurlyBrackClose
	; originally for ' these ' ; "}"
	ORR	r2, r2, #0x10000000
	AND	r1, r2, #0xFF
	TEQ	r1, #0x0A
	TEQNE	r1, #0x09
	BEQ	BeforeColour
	BIC	r2, r2, #0x1000000
	MOV	r1, r2, LSR #24
	AND	r1, r1, #0x01	;  REM Bits for {} depth
	TEQ	r1, #0x00
	BICNE	r2, r2, #0xFF
	ORRNE	r2, r2, #0x0C	;  REM COL Grey/Redirected
	ORRNE	r12, r12, #0x0200
	BNE	BeforeColour
	BIC	r12, r12, #0x0200
	B	CurlyBrack

TabbingSub
	AND	r1, r2, #0xF
	TEQ	r1, #0x0D
	TEQNE	r1, #0x0B
	ORREQ	r2, r2, #0x0100
	AND	r1, r4, #0x3000
	TEQ	r1, #0
	TEQEQ	r0, r12, LSR #24
	BEQ	AfterColour
	TEQ	r0, #' '
	BEQ	Branch24
	CMP	r6, #0
	BLT	BeginOfEnd
	MOV	r0, #9	;  REM tab!
	TEQ	r1, #0x1000
	MOVEQ	r0, #0x20	;  REM " "!!!!
	TEQ	r1, #0x3000
	MOVEQ	r0, #'-'	;  REM "-"!!!!
TabLoop
	MOV	r1, #8	;  REM = COL control Character...
	STRB	r1, [r6, r3]	; @@@@
	MOV	r1, #1
	STRB	r1, [r6, r3,LSL #1]	;  REM wrong?
	STRB	r0, [r6], #1	;  REM @@@@@@
	ADD	lr, lr, #1
	AND	r1, r4, #0x3000
	TEQ	r1, #0x2000
	MOVEQ	r0, #0x20
	BIC	r1, r12, #0xFF000000
	TEQ	lr, r1, LSR #12
	TSTNE	lr, #7
	BNE	TabLoop
	AND	r0, r4, #0x3000
	TEQ	r0, #0x3000
	MOVEQ	r0, #9	;  REM  | ?
	STREQB	r0, [r6, #-1]	;  REM @@@@ ???
	MOV	r0, r12, LSR #24
	B	BeginOfEnd


Data47	DCD	0x0
Branch208
	LDR	r11, Data47
	MOV	pc, lr


; ----------- e_prevline -------------

mode_prevline
	SUBS	r0, r0, #32
	MOVMI	r0, #0
	MOV	PC,R14


; ------- e_init spelling op --------

spellcheck
	STMFD	sp!, {lr}
	MOV	r7, r0
	SUBS	r0, r7, #1
	MVNMI	r1, #0	;  sof
	LDMMIFD	sp!, {pc}
	BL	charfromoffset
	CMP	r0, #0x0A
	MVNEQ	r1, #0	;  pass back 'ignore' flag
	LDMEQFD	sp!, {pc}
	CMP	r0, #'|'	;  GSTrans |M etc...
	CMPNE	r0, #'%'	;  %s for a string...
	CMPNE	r0, #'\'	;  \S (click SELECT to...)
	CMPNE	r0, #'`'	;  `z abbreviation...
	LDMNEFD	sp!, {pc}
	MOV	r1, #0	;  flag
	MOV	r0, #1	;  new offset to use...
	LDMFD	sp!, {pc}

charfromoffset
	STMFD	sp!, {lr}
	LDR	lr, [r9, #f_splito]
	CMP	r0, lr
	LDRCS	lr, [r9, #f_splits]
	ADDCS	r0, r0, lr
	LDR	lr, [r9, #f_ptr]
	LDRB	r0, [lr, r0]
	LDMFD	sp!, {pc}


 END
