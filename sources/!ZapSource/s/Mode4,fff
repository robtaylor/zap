; Contains mode entry points for code mode.
; THIS IS A 1.39+ BETA 8+ Mode 4 - modified to work with Mode4dis
; $Id: Mode4,fff,v 2.15 2003-09-06 16:14:34 christian Exp $
; -*- armasm -*-

	GBLA	NEW_DISASM
; change to 1 to use Debugger Plus 2.07; also do so in s.Mode4dis
NEW_DISASM	SETA	1

	GET	h.ZapHeader
	GET	h.Messages
	GET	h.AlterTxt
	GET	h.Commands
	GET	h.Execute
	GET	h.CreateWind
	GET	h.Cursors
	GET	h.Heap
	GET	h.KeyBits
	GET	h.Menus
	GET	h.MiniBuff
	GET	h.Mode0
	GET	h.Mode1+2
	GET	h.Mode3
	GET	h.ModeBits
	GET	h.ModuleBits
	GET	h.Redraw
	GET	h.Strings
	GET	h.Update
	GET	h.TMTVars

	IMPORT	get_pointer_to_code_cols
	IMPORT	mode4_clever_dis
	IMPORT	mode4_clever_search

	EXPORT	mode_table_4
	EXPORT	mode4_return
	EXPORT	mode4_setwidth
	EXPORT	inmode4_return
	EXPORT	CmdCODEflagstoggle
	EXPORT	Code_disasmtoggle
	EXPORT	redrawallcodemodewindows
	EXPORT	but_sortwwout
	EXPORT	mode4_aif_headerstring
	EXPORT	mode4_mod_headerstring
 [ NEW_DISASM <> 0
	EXPORT	disassemble
 ]


mode_table_4
	DCD	mode_table_4
	DCD	mode4_title
	DCD	mode4_author
	DCD	1			; based on Word mode...
	DCD	4+emode_BinaryMode+emode_UsesMessageTrans+emode_MayBeCloned
	DCD	mode4_init
	DCD	0
	DCD	mode4_table_end-mode_table_4

	DCD	0			; postload
	DCD	0
	DCD	0
	DCD	mode4_start
	DCD	mode4_end
	DCD	mode4_width
	DCD	mode4_linecol
	DCD	mode4_lineoff
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	mode4_minus
	DCD	mode4_plus
	DCD	mode4_minus
	DCD	mode4_plus
	DCD	mode3_cminus
	DCD	mode3_cplus
	DCD	mode4_redrawline
	DCD	0
	DCD	mode4_char		; start a new string
	DCD	Null			; no delete char
	DCD	0
	DCD	mode4_return
	DCD	0
	DCD	0
	DCD	mode1_linestart
	DCD	mode1_lineend
	DCD	mode1_lineend
	DCD	mode1_linestart
	DCD	mode4_copy
	DCD	0
	DCD	0
	DCD	mode4_aligncaret
	DCD	command_primative
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	mode4_search
	DCD	replace_area		; 0
	DCD	0			; selection
	DCD	mode4_click		; click
	DCD	0			; messages
	DCD	mode4_setwidth
	DCD	0			; list fns
	DCD	mode0_prevline
	DCD	0			; Open window
	DCD	mode4_interrogate	; Answer all Zap's questions...
	DCD	0			; e_returnword
	DCD	mode4_help
mode4_table_end

mode4_author
	=	"Dominic Symes, Tim Tyler, Justin Fletcher and Darren Salt",0
	ALIGN

mode4_title
	FNS	("Code")


; -------------- e_init --------------

mode4_init
	TEQ	R1,#7
	BEQ	mode4_menu
	TEQ	R1,#13
	BEQ	mode4_init_13
 [ NEW_DISASM = 0
	TEQ	R1,#14
	BEQ	mode4_init_14
 ]
	TEQ	R1,#6
	ADREQ	R1,mode4_cols
	TEQ	R1,#0
	MOVEQ	R0,#-1			; don't kill this module
	MOVEQ	PC,R14
	TEQ	R1,#2
	MOVNE	PC,R14
	FNJSR	"R0-R4,R8"
	MOV	R8,#0
	MOV	R1,R0			; mode number
	BL	ensure_colours_correct

	MOV	r8,#0
	LDR	R1,[R13]		; mode number
	BL	get_mode_word
	BVS	mode4_dontchangeathing
	TEQ	R0,#0
	BNE	mode4_dontchangeathing
	MOV	R0,#&20000000		; default_mode_word
	BL	put_mode_word
mode4_dontchangeathing
	FNRTVC	; return no error (why? - cl)


 [ NEW_DISASM = 0
mode4_init_13				; set up for redraw
	FNJSR	"R0-R7"
	BL	getdisasmdata
	STR	R0,local_disassemblerflags
	LDRB	R2,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDR	R2,[R14,R2,LSL #2]
	BL	readandputdisasmdata
	FNRTS
 |
	LOCAL

mode4_init_13				; set up for redraw etc.
	FNJSR	"R0-R2"
	LDR	R2,[R8,#w_format]
	TST	R2,#bit_windowwrap	; global?
	AND	R2,R2,#255		; mode number
	BEQ	local$l
	MOV	R0,#0
	MOV	R1,#0
	SWI	XDebugger_Flags
	SUBVSS	R1,R1,R1
	;ORR	R1,R1,#1<<23		; allow those lower-case letters!
	;STR	R1,local_disassemblerflags
	ADD	R2,R8,R2,LSL #2
	LDR	R0,mask$l
	LDR	R2,[R2,#w_mode0]
	AND	R1,R0,R1,LSL #8
	BIC	R2,R2,R0
	ORR	R2,R2,R1
	STR	R2,localmodeword
	FNRTS
local$l	ADD	R2,R8,R2,LSL #2
	LDR	R2,[R2,#w_mode0]
	STR	R2,localmodeword
	MOV	R2,R2,LSL #4
	MOV	R2,R2,LSR #12
	;ORR	R2,R2,#1<<23
	STR	R2,local_disassemblerflags
	FNRTS

mask$l	&	&0FFFFF00

getdisasmdata
	FNJSR
	BL	mode4_init_13
	LDRVC	R0,local_disassemblerflags
	FNRTS
 ]


 [ NEW_DISASM = 0
mode4_init_14				; end of redraw data
	B	readandrestoredisasm
 |

;E R0,R1 as for Debugger_Disassemble
;X Instruction disassembled, or R0/VS
disassemble
	FNJSR	"R0-R2"
	BL	mode4_init_13		; shouldn't be needed
	LDR	R2,local_disassemblerflags
	SWI	XDebugger_DisassemblePlus
	LDMVSFD	R13,{R0-R2}
	SWIVS	XDebugger_Disassemble
	STMIA	R13,{R0-R2}		; hmm...
	FNRTS
 ]



ensure_colours_correct
	FNJSR	"R1-R4,R8"
	MOV	R8,#0			; default options
	MOV	R2,#0
	MOV	R4,#MODE4_COLNUMBS
	BL	get_pointer_to_code_cols
	BL	mode4_init_cols		; setup initial colours
	FNRTS

	LOCAL


;E R0=pointer to words of wimp colours R1=mode number R4=num of cols
;  R8=window to set /0
;X Default colours set up #

mode4_init_cols
	FNJSR	"R1-R5"
	MOV	R3,R0
	MVN	R0,#0
	BL	mode_colour_num
	CMP	R0,R4
	FNRTS	"GE"			; why doesn't it work?
	MOV	R5,R0
	MOV	R0,R4
	BL	mode_colour_num
	MOV	R2,#0			; colour number
a$l
	LDR	R0,[R3],#4		; next bit of data
	CMP	R2,R5
	BLT	postinitcolour		; Debugging - Why doesn't it work?
	BL	mode_colour
	FNRTS	VS
postinitcolour
	ADD	R2,R2,#1
	CMP	R2,R4
	BCC	a$l
	FNRTS

mode4_cols
	=	"zap_m_codecols",0
	ALIGN


; --------------- e_setwidth -------------

mode4_setwidth
	FNJSR
	CMP	R0,#&FF			; 255 limit ?
	MOVGT	R0,#&FF
	BL	mode0_setwidth
	ANDS	R0,R0,#&FF
	MOVEQ	R0,#1
	FNRTS


; ---------------- e_width ---------------

mode4_width
	FNJSR	"R1-R2"
	MOV	R0,#4
	STR	R0,[R8,#w_bpl]
	MOV	R0,#-1
	LDRB	R1,[R8,#w_format]	; mode number
	MOV	R2,#0
	BL	mode_data		; read the first word of mode data
	AND	R0,R0,#&FF
	CMP	R0,#1
	MOVLT	R0,#1			; width
	LDRB	R1,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDR	R1,[R14,R1,LSL #2]!	; load in our mode word
	BIC	R1,R1,#255
	ORR	R1,R1,R0
	STR	R1,[R14]		; save in our mode word
	ADD	R0,R0,#18
	TST	R1,#mode4_BinaryOpcodes
	ADDNE	R0,R0,#27
	FNRTS

	LOCAL

localmodeword
	&	0

local_temp4r6
	%	32


; E R0 = offset (4 => -4...) / R7 = current address.
; X R0 -> to addr - offset (as an offset?)

getpreviousaddress
	FNJSR
	SUB	R14,R7,R0
	LDR	R0,[R9,#f_ptr]
	CMP	R14,R0
	MOVCC	R0,#0			; !???
	FNRTS	CC
	LDR	R1,[R9,#f_splito]	; offset of split start
	ADD	R1,R0,R1
	CMP	R14,R1			; R7...?
	MOVCC	R0,R14
	FNRTS	CC
	LDR	R1,[R9,#f_splite]	; offset of split end
	ADD	R1,R0,R1
	CMP	R14,R1
	MOVCS	R0,R14
	FNRTS	CS
	LDR	R1,[R9,#f_splits]	; size of split
	SUB	R14,R14,R1
	SUB	R5,R5,R1
	LDR	R1,[R9,#f_splito]	; offset of split start
	ADD	R10,R0,R1		; yuck code... (apparent buffer end...)
	MOV	R0,R14
	FNRTS

tizhexed
	FNJSR
	MOV	R3,#4
	MOV	R4,#0			; current instruction
hex2$l					; hex dump loop
	CMP	R7,R10
	BLCS	red_overflow
	FNRTS	VS
	LDRB	R0,[R7],#1
	ORR	R4,R4,R0
	MOV	R4,R4,ROR #8		; save byte in instruction

	ADD	R6,R6,#2		; increment R6 like hex2...
	TST	R2,#1<<17
	SUBEQ	R6,R6,#4		; little endian so go back
	SUBS	R3,R3,#1
	BHI	hex2$l
	MOV	R0,R4			; instruction
	TST	R2,#1<<17
	BLNE	reverse_word		; big endian
	SUB	R1,R7,R5
	SUB	R1,R1,#4		; offset in file of instruction
	MOV	R4,R0			; save the instruction
	LDR	R2,[R8,#w_addr]
	FNRTS

 [ NEW_DISASM = 0
;E R2 data
readandputdisasmdata
	LDR	R1,[R8,#w_format]
	TST	R1,#bit_windowwrap	; non-global...?
	MOVNE	PC,R14
	MOV	R1,R2,LSR #8
	BIC	R1,R1,#(&F << 20)	; options - need to update if these change
	;ORR	R1,R1,#1<<23		; allow those lower-case letters!
	B	putdisasmdata

search_readandputdisasmdata
	LDR	R1,[R8,#w_format]
	TST	R1,#bit_windowwrap	; non-global...?
	MOVNE	PC,R14
	MOV	R1,R2,LSR #8
	BIC	R1,R1,#(&F << 20)	; options - need to update if these change
	B	putdisasmdata

carefully_readandputdisasmdata
	FNJSR
	LDR	R14,[R8,#w_format]
	TST	R14,#bit_windowwrap
	MOVEQ	R1,R2,LSR #8
	BICEQ	R1,R1,#(&F << 20)	; options - need to update if these change
 ; *don't* allow those lower-case letters!?!?!?!
	BLEQ	putdisasmdata
	SUBS	R14,R14,R14
	FNRTS

carefully_readandrestoredisasm
	FNJSR
	LDR	R14,[R8,#w_format]
	TST	R14,#bit_windowwrap
	BLEQ	restoredisasm
	SUBS	R14,R14,R14
	FNRTS

readandrestoredisasm
	LDR	R0,[R8,#w_format]
	TST	R0,#bit_windowwrap
	MOVNE	PC,R14
; fall through

restoredisasm
	FNJSR	"R0,R1"
	LDR	R1,local_disassemblerflags
	BL	putdisasmdata
	FNRTS

 ]
local_disassemblerflags
	DCD	0


; colour numbers
		^	0
c_bg1		#	1
c_bg2		#	1
c_bg		*	c_bg2
c_fg		#	1
c_selbg		#	1
c_selfg		#	1
c_curbg		#	1
c_curfg		#	1
c_lines		#	1
c_ctls		#	1

c_ascii		#	1
c_hex		#	1
c_comment	#	1
c_swi		#	1
c_branch	#	1
c_pushr14	#	1
c_pullpc	#	1
c_square	#	1
c_curly		#	1
c_punct		#	1
c_regs		#	1
c_numbers	#	1
c_immediate	#	1
c_shift		#	1
c_ldm		#	1
c_ldr		#	1
c_swiname	#	1
c_cond		#	1
c_undef		#	1
c_fpreg		#	1
c_cpreg		#	1
c_fpop		#	1
c_cpop		#	1
c_vfpreg	#	1
c_vfpop		#	1

MODE4_COLNUMBS 	*	@

; redraw flags in R2
rf_umull	*	(1<<8)
rf_swi		*	(1<<9)
rf_ef		*	(1<<12)				; ef bits must be 0 in FIX
rf_efgh		*	(1<<13)				; efgh bits must be 0 in WFS, RFS, WFC, RFC

mode4_redrawline
	LDR	R1,[R9,#f_len]
	SUB	R4,R7,R5
	CMP	R4,R1
	ADDHS	R11,R11,#1
	MOVHS	PC,R14			; return quickly if at EOF

	FNJSR	"R11"
	STR	R11,local_temp4r6 + 24	; save it...
	STR	R9,local_temp4r6 + 28	; this too...
 [ NEW_DISASM = 0
	LDRB	R2,[R8,#w_format]	; mode number
	ADD	R2,R8,R2,LSL #2
	LDR	R2,[R2,#w_mode0]
	STR	R2,localmodeword
 ]
	MOV	R1,#0			; important r1=0?
	;STR	R1,local_bgcol_please
	MOV	R2,#7
	MOV	R0,#9			; colour
	BL	colour_chars_both	; colour the ascii column
	MOV	R1,#7
	MOV	R2,#11
	LDR	R0,localmodeword
	TST	R0,#mode4_BinaryOpcodes
	ADDNE	R2,R2,#27
	MOV	R0,#10			; colour of hex/binary
	BL	colour_chars_both	; colour the hex dump column
	PUSH	"R5,R7,R10"		; save start of line
	MOV	R3,#4
ascii$l					; ascii characters loop
	CMP	R7,R10
	BLCS	red_overflow
	ADDVS	R6,R6,R3
	BVS	asciiend$l
	LDRB	R0,[R7],#1
	STRB	R0,[R6],#1
	SUBS	R3,R3,#1
	BHI	ascii$l
asciiend$l				; finished ascii field
	BL	colons
	PULL	"R5,R7,R10"		; get start of line
	LDR	R2,[R8,#w_format]	; format value

	; fudge...
	SUB	R0,R7,#4
	LDR	R14,local_temp4r6 + 16	; recover previous attempt...
	TEQ	R0,R14
	SUBEQ	R0,R7,#8
	LDREQ	R14,local_temp4r6 + 20	; recover previous attempt...
	TEQEQ	R0,R14
	BEQ	atprehex$l		; we've just done the previous instr...?
notprehex$l
	ADR R0,local_temp4r6		; save it...
	STMIA R0,{R5-R7,R10}

	MOV	R0,#8
	BL	getpreviousaddress
	LDR	R11,[R9,#f_ptr]
	CMP	R0,R11
	MOVCS	R7,R0
	BLCS	tizhexed
	ADD	R1,R1,R2		; user file address
	SWI	XDebugger_Disassemble	; discard results...
	ADR	R0,local_temp4r6
	LDMIA	R0,{R5-R7,R10}
	MOV	R0,#4
	BL	getpreviousaddress
	LDR	R11,[R9,#f_ptr]
	CMP	R0,R11
	MOVCS	R7,R0
	BLCS	tizhexed
	ADD	R1,R1,R2		; user file address
	SWI	XDebugger_Disassemble	; discard results...
	; end of fudge...

	ADR	R1,local_temp4r6
	LDMIA	R1,{R5-R7,R10}
atprehex$l
	MOV	R1,#0			;?
	LDR	R2,[R8,#w_format]	; format value
	MOV	R3,#4			; huh?
	MOV	R4,#0			; current instruction
 ; restore...
	SUB	R0,R7,#4		; ?
	STR	R0,local_temp4r6 + 20	; recover previous attempt...
	STR	R7,local_temp4r6 + 16	; save it...
	LDR	R0,localmodeword
	TST	R0,#mode4_BinaryOpcodes
	BNE	insertbinarydata
	TST	R2,#1<<17
	ADDEQ	R6,R6,#6		; little endian
hex$l					; hex dump loop
	CMP	R7,R10
	BLCS	red_overflow
	BVS	finished$l
	LDRB	R0,[R7],#1
	ORR	R4,R4,R0
	MOV	R4,R4,ROR #8		; save byte in instruction
	BL	hex2
	TST	R2,#1<<17
	SUBEQ	R6,R6,#4		; little endian so go back
	SUBS	R3,R3,#1
	BHI	hex$l
	TST	R2,#1<<17
	ADDEQ	R6,R6,#10		; finish hex dump field
backfrominsertbinarydata
	BL	colons			; now print instruction
	MOV	R0,R4			; instruction
	TST	R2,#1<<17
	BLNE	reverse_word		; big endian
	SUB	R1,R7,R5
	SUB	R1,R1,#4		; offset in file of instruction

	LDR	R11,[R9,#f_load]
	MOV	R11,R11,ASR #8
	CMP	R11,#-6			; module?
	BEQ	module$l		; it is a module
	;CMP	R11,#-8			; absolute?
					; now check for AIF based on contents
	B	absolute$l		; it is an absolute
dis$l					; disassemble the instruction
	MOV	R4,R0			; save the instruction
	LDR	R2,[R8,#w_addr]
	ADD	R1,R1,R2		; user file address
	BL	mode4_clever_dis	; gerph
	BVS	finished$l

	; find the condition code
	ADR	R11,conds$l		; get the condition code string
c0$l	MOV	R2,R1
c1$l	LDRB	R0,[R2],#1		; get to the end of the mnemonic
	TEQ	R0,#' '
	TEQNE	R0,#0
	BNE	c1$l

	SUB	R2,R2,#2
	MOV	R3,#1
	MOV	R0,R4,LSR #28
	ADD	R11,R11,R0,LSL #1

c2$l	SUB	R2,R2,#1
c3$l	CMP	R2,R1			; don't go behind the mnemonic
	BLO	cfail$l
	LDRB	R0,[R2,R3]
	LDRB	R14,[R11,R3]
	BIC	R0,R0,#&20
	TEQ	R0,R14
	MOVNE	R3,#1			; no match - try previous character
	BNE	c2$l
	SUBS	R3,R3,#1
	BPL	c3$l

	SUB	R2,R2,R1		; offset of condition code
	B	cdone$l

conds$l	 =	"EQNECSCCMIPLVSVCHILSGELTGTLEALNV"
conds2$l =	"ZZZZHSLO"

cfail$l	MOV	R0,R4,LSR #28		; if CC or CS
	CMP	R0,#4
	ADRLO	R0,conds2$l
	CMPLO	R11,R0			; try again with LO and HS
	MOVLO	R11,R0
	BLO	c0$l
	MOV	R2,#-1

	; now colour the disassembly
cdone$l	MOV	R0,R1
	BL	redraw_strcpy

	MOV	R11,#c_fg
	; now R6 = output,  R2 = flags  R3 = end  R11 = colour

	LDRB	R0,[R6]
	TEQ	R0,#';'			; quick check for comments
	BEQ	comment$l
	TEQ	R0,#'U'			; and undefined
	BNE	start$l
	MOV	R0,#1
	BL	geto$l
	TEQ	R0,#'n'
	BEQ	undefined$l

	; ascertain the instruction type
start$l	ADRL	R11,opctab$l
sloop$l	LDR	R0,[R11],#4
	AND	R0,R0,R4
	LDR	R1,[R11],#8
	TEQ	R0,R1
	BNE	sloop$l

	CMP	R2,#-1
	MOVEQ	R2,#0
	MOVEQ	R14,#0
	LDR	R11,[R11,#-4]		; flags
	ORR	R2,R2,R11
	MOV	R11,R11,LSR #24		; initial colour

	TST	R2,#rf_ef		; nasty check for SBZ bits in some
	MOVNE	R0,#1<<19		; FP ops
	ORRNE	R0,R0,#1<<7
	TSTNE	R4,R0
	BNE	notfp$l
	TST	R2,#rf_efgh
	ORRNE	R0,R0,#(1<<6)+(1<<5)
	TSTNE	R4,R0
	BEQ	colok$l
notfp$l	MOV	R11,#c_cpop

colok$l	TEQ	R14,#0			; no condition to colour?
	BEQ	donecond$l

coliloop$l
	BL	storecol$l		; colour the opcode
	SUB	R2,R2,#1
	TST	R2,#&FF
	BNE	coliloop$l

	LDR	R14,localmodeword
	TST	R14,#mode4_Unconditional
	BNE	donecond$l

	LDR	R14,[R8,#w_format]	; condition colour is background
	TST	R14,#1<<25
	MOVEQ	R11,#c_cond
	MOVEQ	R1,#c_bg
	MOVNE	R1,#c_cond
	BL	storecolbac$l
	BL	storecolbac$l
	MOV	R11,R2,LSR #24		; restore colour

donecond$l
	LDRB	R0,[R6]			; colour the rest of the mnemonic
	TEQ	R0,#' '
	BEQ	doneinstr$l
	BL	storecol$l
	B	donecond$l

doneinstr$l
	LDRB	R0,[R6]			; colour the spaces before the operands
	TEQ	R0,#' '
	BNE	params$l
	BL	storecol$l
	B	doneinstr$l

params$l
	TST	R2,#rf_swi		; if it was an SWI, colour its name
	BNE	swiname$l
	LDR	R0,localmodeword	; colour rest in same colour
	TST	R0,#mode4_MinimalColouring
	BNE	finishline$l
	B	a$l

onecol$l
	BL	storecol$l
a$l	MOV	R11,#c_fg

		; main operand colouring loop
mainloop$l
	LDRB	R0,[R6]
	TEQ	R0,#';'			; comments
	BEQ	comment$l		;

	TEQ	R0,#'&'			; numbers
	BEQ	number$l		;
	CMP	R0,#'0'			;
	RSBHSS	R1,R0,#'9'		;
	BHS	number$l		;

	TEQ	R0,#'['			; [ ]
	TEQNE	R0,#']'			;
	MOVEQ	R11,#c_square		;
	BEQ	onecol$l		;

	TEQ	R0,#'{'			; { }
	TEQNE	R0,#'}'			;
	MOVEQ	R11,#c_curly		;
	BEQ	onecol$l		;

	TEQ	R0,#'#'			; immediate numbers
	BEQ	immediate$l		;

	TEQ	R0,#'!'			; ! ^ - ,
	TEQNE	R0,#'^'			;
	TEQNE	R0,#'-'			;
	TEQNE	R0,#','			;
	MOVEQ	R11,#c_punct		;
	BEQ	onecol$l		;

	BIC	R0,R0,#&20

	TEQ	R0,#'R'
	BEQ	r$l

	TEQ	R0,#'P'			; PC
	BEQ	pc$l			;

	TEQ	R0,#'A'			; a1-a3 ASL ASR
	TEQNE	R0,#'V'			; v1-v7
	BEQ	avreg$l

	TEQ	R0,#'S'			; sl sp sb S0-S7
	BEQ	sreg$l

	TEQ	R0,#'L'			; lr LSL LSR
	BEQ	l$l

	TEQ	R0,#'I'			; ip
	BEQ	i$l

	TEQ	R0,#'F'			; fp, F0-F7
	BEQ	f$l

	TEQ	R0,#'C'			; C0-C15 CP0-CP15
	BEQ	c$l

	TEQ	R0,#'D'			; D0-D15
	BEQ	d$l

	B	onecol$l		; unknown (c_fg)

; possibly PC
pc$l	MOV	R0,#1			; check for PC
	BL	geto$l			;
	TEQ	R0,#'C'			;
	TEQNE	R0,#'c'			;
	MOVEQ	R11,#c_regs		;
	BLEQ	storecol$l		;
	B	onecol$l		;

; a1-a3 v1-v7 ASL ASR
avreg$l	MOV	R0,#1
	BL	geto$l
	CMP	R0,#'0'			;
	RSBHSS	R1,R0,#'9'		;
	MOVHS	R11,#c_regs
	BLHS	storecol$l

	TEQ	R0,#'S'
	TEQNE	R0,#'s'
	BEQ	shift$l
	B	onecol$l

; sl sp sb SPSR_cxsf S0-S31
sreg$l	MOV	R0,#1
	BL	geto$l
	BIC	R1,R0,#&20
	TEQ	R1,#'L'
	TEQNE	R1,#'P'
	TEQNE	R1,#'B'
	MOVEQ	R11,#c_regs
	BEQ	untilcomma$l

; S0-S31
	CMP	R0,#'0'			;
	RSBHSS	R1,R0,#'9'		;
	BLO	onecol$l

	MOV	R11,#c_vfpreg
	BL	storecol$l
	MOV	R0,#1
	BL	geto$l
	CMP	R0,#'0'			;
	RSBHSS	R1,R0,#'9'		;
	BLHS	storecol$l
	B	onecol$l

; lr LSL LSR
l$l	MOV	R0,#1
	BL	geto$l
	BIC	R0,R0,#&20
	TEQ	R0,#'S'
	MOVEQ	R11,#c_shift
	BEQ	untilcomma$l
	TEQ	R0,#'R'
	MOVEQ	R11,#c_regs
	BLEQ	storecol$l
	B	onecol$l

; ip
i$l	MOV	R0,#1
	BL	geto$l
	TEQ	R0,#'P'
	TEQNE	R0,#'p'
	MOVEQ	R11,#c_regs
	BLEQ	storecol$l
	B	onecol$l

; fp F0-7
f$l	MOV	R0,#1
	BL	geto$l
	TEQ	R0,#'P'
	TEQNE	R0,#'p'
	BNE	fpreg$l
	MOV	R11,#c_regs
	BL	storecol$l
	B	onecol$l

; F0-F7
fpreg$l	CMP	R0,#'0'			;
	RSBHSS	R0,R0,#'7'		;
	MOVHS	R11,#c_fpreg
	BLHS	storecol$l
	B	onecol$l

; D0-D15
d$l	MOV	R0,#1
	BL	geto$l
	CMP	R0,#'0'			;
	RSBHSS	R1,R0,#'9'		;
	BLO	onecol$l

	MOV	R11,#c_vfpreg
	BL	storecol$l
	MOV	R0,#1
	BL	geto$l
	CMP	R0,#'0'			;
	RSBHSS	R1,R0,#'5'		;
	BLHS	storecol$l
	B	onecol$l

; C0-C15  CP0-CP15  CPSR_cxsf
c$l	MOV	R0,#2
	BL	geto$l
	TEQ	R0,#'S'
	TEQNE	R0,#'s'
	MOVEQ	R11,#c_regs
	BEQ	untilcomma$l

	MOV	R11,#c_cpreg
untilcomma$l
	BL	storecol$l
	LDRB	R0,[R6]
	TEQ	R0,#','
	TEQNE	R0,#' '
	TEQNE	R0,#']'
	TEQNE	R0,#'}'
	BNE	untilcomma$l
	B	mainloop$l

; SWI names
swiname$l
	LDRB	R0,[R6]			; check it's a name
	BIC	R0,R0,#&20		;
	CMP	R0,#'A'			;
	RSBHSS	R1,R0,#'Z'		;
	MOVHS	R11,#c_swiname		;
	BHS	finishline$l		;
	B	mainloop$l		;

; numbers
number$l
	MOV	R11,#c_numbers		; hex numbers
	B	immloop$l

; immediate numbers
immediate$l
	MOV	R11,#c_punct		; colour the #
	BL	storecol$l		;
	MOV	R11,#c_immediate	;
immloop$l
	LDRB	R0,[R6]			; colour 0-9A-F&-
	CMP	R0,#'0'			;
	RSBHSS	R1,R0,#'9'		;
	BHS	immok$l			;
	BIC	R1,R0,#&20		;
	CMP	R1,#'A'			;
	RSBHSS	R1,R1,#'F'		;
	BHS	immok$l			;
	TEQ	R0,#'&'			;
	TEQNE	R0,#'-'			;
	BNE	mainloop$l		;
immok$l	BL	storecol$l		;
	B	immloop$l		;

; registers, ROR, RRX
r$l	MOV	R0,#1			; check for RO and RR
	BL	geto$l
	BIC	R0,R0,#&20
	TEQ	R0,#'O'
	TEQNE	R0,#'R'
	BEQ	shift$l

	MOV	R11,#c_regs		; colour a register
	BL	storecol$l		; R
	BL	storecol$l		; 1
	LDRB	R0,[R6]			; see if R10-R15
	CMP	R0,#'0'			;
	RSBHSS	R0,R0,#'5'		;
	BLHS	storecol$l		; yes
	B	mainloop$l		;

; ASL LSL ASR LSR ROR RRX
shift$l	MOV	R11,#c_shift
	B	untilcomma$l

; comments
comment$l
	MOV	R11,#c_comment		; store the colour until we run out of chars
finishline$l
	BL	storecol$l		;
	LDRB	R0,[R6]			;
	TEQ	R0,#';'			;
	MOVEQ	R11,#c_comment		;
	B	finishline$l		;

; undefined or unpredictable instructions
undefined$l
	MOV	R11,#c_undef		; store the colour until we run out of chars
	B	finishline$l		;


storecol$l
	MOV	R1,#c_bg
; store the colour. Doesn't return if finished the line
; E r3 -> end output address  r6 -> current output address  r11 = colour R1 = bac
; X r0 corrupt  r6 incremented
storecolbac$l
	LDR	R0,[R8,#w_txtw]
	STRB	R11,[R6,R0]
	STRB	R1,[R6,R0,LSL #1]
	ADD	R6,R6,#1
	CMP	R6,R3
	MOVLO	PC,R14

finished$l
	FNPULL				; redraw all finished
	ADDS	R11,R11,#1		; clv - red_overflow can return VS
	MOV	PC,R14


; get a character from the OUTPUT
; E r0 = offset  r6 = current output pointer
; X r0 = char / 0 if unreadable
geto$l	ADD	R0,R0,R6		; check it's in the output
	CMP	R0,R3			;
	LDRLOB	R0,[R0]			; load it if there
	MOVHS	R0,#0			; otherwise unknown
	MOV	PC,R14			;


insertbinarydata
	TST	R2,#1<<17
	ADDEQ	R6,R6,#27		; little endian
binaryloop$l
	CMP	R7,R10
	BLCS	red_overflow
	BVS	finished$l
	LDRB	R0,[R7],#1
	ORR	R4,R4,R0
	MOV	R4,R4,ROR #8		; save byte in instruction
	BL	bin8
	MOV	R0,#32
	STRB	R0,[R6],#1
	TST	R2,#1<<17
	SUBEQ	R6,R6,#18		; little endian so go back
	SUBS	R3,R3,#1
	BHI	binaryloop$l
	SUB	R6,R6,#1
	TST	R2,#1<<17
	ADDEQ	R6,R6,#45		; finish hex dump field
	B	backfrominsertbinarydata


	MACRO
$la	OPC	$mask, $value, $colour, $flags
$la	DCD	$mask
	DCD	$value
	DCW	$flags			; essentially ($colour << 24) OR $flags
	DCB	0,$colour		; but AS doesn't like that
	MEND

opctab$l	; mask	   value      colour	 flags
	OPC	&0E000000, &0A000000, c_branch,  0		; B BL
	OPC	&0FFFFFF0, &012fff10, c_branch,  0		; BX
	OPC	&0F000000, &0F000000, c_swi,	 rf_swi		; SWI
	OPC	&0E108000, &08008000, c_pullpc,  0		; LDM ...PC
	OPC	&0E104000, &08104000, c_pushr14, 0		; STM ...R14
	OPC	&0E000000, &08000000, c_ldm,	 0		; LDM STM
	OPC	&0C000000, &04000000, c_ldr,	 0		; LDR STR
	OPC	&0E400090, &00400090, c_ldr,	 0		; LDRH LDRSH LDRSB STRH STRSH STRSB

	OPC	&0F080F90, &0E080180, c_cpop,	 0		; FP op with undefined precision
	OPC	&0FF08F10, &0ED00100, c_cpop,	 0		; undefined FP op
	OPC	&0FF08F10, &0EE00100, c_cpop,	 0		; undefined FP op
	OPC	&0FF08F10, &0EF00100, c_cpop,	 0		; undefined FP op
	OPC	&0F98FFF0, &0E90F110, c_fpop,	 0		; FP compares
	OPC	&0F800F10, &0E800110, c_cpop,	 0		; undefined FP register txfer
	OPC	&0FE00F10, &0E600110, c_cpop,	 0		; undefined FP register txfer
	OPC	&0FF00F10, &0E000110, c_fpop,	 0		; FLT
	OPC	&0FF00F10, &0E100110, c_fpop,	 rf_ef		; FIX
	OPC	&0F000F10, &0E000110, c_fpop,	 rf_efgh	; WFS RFS WFC RFC
	OPC	&0C000F00, &0C000100, c_fpop,	 0		; valid FP ops (CP1)
	OPC	&0E000F00, &0C000200, c_fpop,	 0		; LFM / SFM (CP2)

	OPC	&0E400F10, &0E400B00, c_cpop,	 0		; double-precision VFP op with D set
	OPC	&0EB00E50, &0E800A00, c_vfpop,	 0		; FDIVS FDIVD
		; pqrs = 1111 go here
	OPC	&0E800E50, &0E800A00, c_cpop,	 0		; undefined VFP op
	OPC	&0E000E10, &0E000A00, c_vfpop,	 0		; VFP data processing ops

	OPC	&0E400F00, &0C400B00, c_cpop,	 0		; double-precision VFP op with D set
	OPC	&0F800E00, &0C000A00, c_cpop,	 0		; undefined VFP load / store
	OPC	&0FA00E00, &0DA00A00, c_cpop,	 0		; undefined VFP load / store
	OPC	&0E000E00, &0C000A00, c_vfpop,	 0		; valid VFP load / store

	OPC	&0F000F90, &0E000B90, c_cpop,	 0		; double-precision VFP op with D set
	OPC	&0FE00F10, &0E200A10, c_cpop,	 0		; undefined VFP register txfer
	OPC	&0FC00E10, &0E400A10, c_cpop,	 0		; undefined VFP register txfer
	OPC	&0FC00E10, &0E800A10, c_cpop,	 0		; undefined VFP register txfer
	OPC	&0FE00E10, &0EC00A10, c_cpop,	 0		; undefined VFP register txfer
	OPC	&0FEE0F10, &0EE00A10, c_vfpop,	 0		; FMXR FMRX with valid sys reg
	OPC	&0FEF0F10, &0EE80A10, c_vfpop,	 0		; FMXR FMRX with valid sys reg
	OPC	&0FE00E10, &0EE00A10, c_cpop,	 0		; invalid FMXR FMRX
	OPC	&0F000E10, &0E000A10, c_vfpop,	 0		; valid VFP register txfer

	OPC	&0C000000, &0C000000, c_cpop,	 0		; CP load / store
	OPC	&00000000, &00000000, c_fg,	 0		; default


; decode absolute header
; => r1 = file offset
; return using B dis$l
absolute$l
	CMP		r1,#(end_abs_stab - abs_stab) ; +20 for jump header
	BCS		dis$l		; definitely not in header
	CMP		r1,#20		; compare with start of data block
	BLT		dis$l		; is < header data, so we don't care
	; check it is a valid AIF file
	PUSH	"R0"			; save the word
	MOV	R0,#16			; address of SWI "OS_Exit"
	BL	cln_readw		; get word
	EOR	r0,r0,#&EF000000	; clear top bits
	EORS	r0,r0,#&00000011	; clear SWI number
	PULL	"R0"			; word not now needed
	BNE	dis$l			; if not 0 now, it's invalid
	MOV	r0,r1			; put the offset in the right reg
	BL	mode4_aif_headerstring
	BL	redraw_strcpy
	MOV	R11,#c_comment		; use comment colour
	B	finishline$l


; decode module header
; => r1 = file offset
; return using B dis$l
module$l
	MOV	r11,r0			 ; hang on to instruction
	MOV	r0,r1			 ; r0 = offset
	BL	mode4_mod_headerstring	 ; read the string
	TEQ	r0,#0			 ; did we decode it ?
	MOVEQ	r0,r11			 ; if not, restore instruction
	BEQ	dis$l			 ; if not, normal disassembly
	BL	redraw_strcpy
	MOV	R11,#c_comment
	B	finishline$l


	LOCAL

; copy string R0->R6 without spilling and no terminator
; E R0 -> string  R6 = output buffer
; X R6 preserved,  R3 -> end
redraw_strcpy
	FNJSR	"R2,R4,R6"
	PUSH	"R0,R6"
	MOV	R0,#-1
	BL	mode4_setwidth		; read width
	PULL	"R1,R3"

	ADD	R0,R0,R3		; absolute limit

	LDRB	R4,[R8,#w_format]
	ADD	R4,R8,R4,LSL #2
	LDR	R4,[R4,#w_mode0]
	TST	R4,#mode4_CommentFree
	MOVNE	R4,#';'
	MOVEQ	R4,#0

loop$l	CMP	R3,R0
	FNRTS	HS

	LDRB	R2,[R1],#1		; copy in
	TEQ	R2,#0
	TEQNE	R2,R4
	STRNEB	R2,[R3],#1
	BNE	loop$l
	FNRTS



; return a string for the module header
; => r0 = offset in file
; <= r0 = string pointer, or 0 if not known
mode4_mod_headerstring
	FNJSR	"R1-R5,R9"
	CMP	R0,#(end_mod_stab - mod_stab)
	MOV	r1,r0			; r1 = offset
	MOVCS	r0,#0			; if too big, it's not known
	FNRTS	CS			; definitely not in header
	MOV	R2,#0			; check valid loop
	PUSH	"R0"			; save the word
checkoff$l				; check it is a valid module offset
	MOV	R0,R2
	BL	cln_readw		; get word
	TEQ	R2,#4
	TEQNE	R2,#8
	BICEQ	R0,R0,#1 << 31		; clear bit 31 if init/final
	MOV	R4,R0			; preserve for later...
	BL	valid_off		; valid offset?
	PULL	"R0",CS
	MOVCS	r0,#0			; if too big, it's not known
	FNRTS	CS			; definitely not in header
	CMP	R2,R1
	ADDCC	R2,R2,#4
	BCC	checkoff$l
	PULL	"R0"			; word not now needed
	ADR	R0,mod_stab
	LDR	R14,[R0,R1]		; get string offset
	TST	R14,#1<<31
	BEQ	nostring$l
	ADD	R2,R2,#4
	CMP	R4,R2			; offset must be >= next word
	FNLDR	R2,wimp_kbdbuf
	BIC	R14,R14,#1<<31
	PUSH	"R14"
	BLO	copied$l
	MOV	R5,#127			; should be enough space(!)
	LDR	R9,local_temp4r6 + 28	; get saved R9
	LDR	R3,[R9,#f_len]
copy$l	CMP	R4,R3
	FNLDR	R2,wimp_kbdbuf,HS
	BHS	copied$l		; at or past EOF - nullify
	MOV	R0,R4
	BL	cln_readc
	SUBS	R5,R5,#1
	CMPNE	R0,#0
	STRNEB	R0,[R2],#1		; copy while space in buffer & !NUL
	ADDNE	R4,R4,#1
	BNE	copy$l
copied$l
	MOV	R0,#0			; string terminator
	STRB	R0,[R2]
	PULL	"R14"
nostring$l
	FNLDR	R0,env_modstart		; base for indirected offsets
	ADD	R1,R0,R14		; string address
	FNLDR	R2,wimp_kbdbuf
	MOV	R3,#128
	ADD	R2,R2,#128
	FNLDR	R4,wimp_kbdbuf
	BL	lookup_token
	MOVVC	R0,R2
	FNRTS				; return the string


;E R0=word R2=module offset R9=file
;X CC if word valid CS ow |
valid_off
	FNJSR
	CMP	R2,#&10
	BCC	code$l			; code offset
	CMP	R2,#&1C
	BCC	string$l		; string/table offset
	TEQ	R2,#&24
	BEQ	string$l		; string/table offset
	CMP	R2,#&20
	BCS	code$l			; code offset
	CMP	R0,#&01000000		; swi number
	FNRTS
code$l
	AND	R14,R0,#3		; word aligned?
	CMP	R14,#1
	FNRTS	CS			; not word aligned
string$l
	PUSH	"R0"			; skip this check if compressed
	MOV	R0,#4
	BL	cln_readw
	MOVS	R0,R0,LSR #31		; move b31 into b0, and (effectively) clear C
	PULL	"R0"
	FNRTS	NE			; module is compressed

	LDR	R14,[R9,#f_len]
	CMP	R0,R14			; in file range?
	FNRTS

mod_stab
	DCD	starto$l
	DCD	inito$l
	DCD	fino$l
	DCD	serviceo$l
	DCD	titleo$l+1<<31
	DCD	helpo$l+1<<31
	DCD	commo$l
	DCD	swichunk$l
	DCD	swicode$l
	DCD	switable$l
	DCD	swideccode$l
	DCD	msgdeccode$l+1<<31
	DCD	modflags$l
end_mod_stab
starto$l	= "zap_d_starto",0
inito$l		= "zap_d_inito",0
fino$l		= "zap_d_fino",0
serviceo$l	= "zap_d_serviceo",0
titleo$l	= "zap_d_titleo",0
helpo$l		= "zap_d_helpo",0
commo$l		= "zap_d_commo",0
swichunk$l	= "zap_d_swichunk",0
swicode$l	= "zap_d_swicode",0
switable$l	= "zap_d_switable",0
swideccode$l	= "zap_d_swidecode",0
msgdeccode$l	= "zap_d_msgdecode",0
modflags$l	= "zap_d_modflags",0
	ALIGN

stored_blank_string
	DCD	0

mode4_lineoff
	LDRB R1,[R8,#w_format]	; mode number
	ADD R0,R8,#w_mode0
	LDR R1,[R0,R1,LSL #2]
	MOV R0,#0
	TST R1,#mode4_BinaryOpcodes
	AND R1,R1,#255			; bottom 8 bits
	ADD R1,R1,#18			; hex width
	ADDNE R1,R1,#27		; + bin width
	MOV PC,R14

mode4_linecol
	MOV	PC,R14			; must be at line start

mode4_plus
	FNJSR
	MOV	R0,R1
	MVN	R2,#1			;-2
	BL	follow_branch
	FNRTS

mode4_minus
	FNJSR
	BL	previous_mark
	MVN	R2,#1			; -2 for already moved
	FNRTS

;E R0=instruction word R1=(apparent) address
;X R0=(apparent) address to jump to / CS if none #

find_branch_addr
	FNJSR	"R1-R2"
 [ NEW_DISASM = 0
	SWI	XDebugger_Disassemble
 |
	BL	disassemble
 ]
	ADRVS	R1,stored_blank_string
	MOVVS	R2,#1

fi2	LDRB	R0,[R1],#1
	TEQ	R0,#'&'
	BEQ	fi3
	CMP	R0,#&20
	BCS	fi2
	SEC
	FNRTS

fi3	MOV	R2,R1			; save first digit
	BL	hex_read
	SUB	R14,R1,R2
	TEQ	R14,#8			; was it 8 chars
	BNE	fi2			; if not then carry on
	CLC
	FNRTS

;E R1=apparent address... R2 = 0ffset (4 or 8)
getpreviousinstrs
	FNJSR	"R1"
	SUBS	R1,R1,R2
	MOVS	R0,R1
	MOVMI	R0,#0
	BLPL	cln_readw			; get instruction in R0
	LDR	R2,[R8,#w_addr]		; base address
	ADD	R1,R2,R1
 [ NEW_DISASM = 0
	SWI	XDebugger_Disassemble	; for the sake of ADRLs.
 |
	BL	disassemble		; for the sake of ADRLs.
 ]
	ADRVS	R1,stored_blank_string
	MOVVS	R2,#1
	FNRTS

; decodes an offset into an AIF header description
; => r0= offset in the file
; <= r0= string to give it, or 0 if none
	LOCAL
mode4_aif_headerstring
	FNJSR	"R1-R3"
	CMP	r0,#&40			; is it < start of debugger ?
	BLO	topheader$l		; if so, it's an explicit header
	MOV	r14,#-4*1		; -1 string means 'unknown'
	MOVEQ	r14,#-4*2		; if = start, it's the -2 string
	TEQ	r0,#&44			; is it start of zero-init ?
	MOVEQ	r14,#-4*3		; if so, it's the -3 string
	TEQ	r0,#&7C			; is it end of zero-init ?
	MOVEQ	r14,#-4*4		; if so, it's the -4 string
	MOV	r0,r14			; offset = r14
topheader$l
	ADR	R14,abs_stab		; take address of offset table
	LDR	R14,[R14,R0]		; get string offset
	FNLDR	R0,env_modstart		; base for indirected offsets
	ADD	R1,R0,R14		; string address
	MOV	R2,#-1
	BL	lookup_token
	MOVVC	R0,R2
	FNRTS

	DCD	zeroe$l
	DCD	zeros$l
	DCD	debug$l
	DCD	unknown$l
abs_stab
	DCD	decomp$l
	DCD	selfreloc$l
	DCD	zeroinit$l
	DCD	entry$l
	DCD	foolish$l
	DCD	abs_readonly$l
	DCD	abs_readwrite$l
	DCD	abs_debug$l
	DCD	abs_zeroinit$l
	DCD	abs_debugtype$l
	DCD	abs_base$l
	DCD	abs_workspace$l
	DCD	abs_addrmode$l
	DCD	abs_database$l
	DCD	abs_res1$l
	DCD	abs_res2$l
end_abs_stab
zeroe$l		= "zap_d_zeroe",0
zeros$l		= "zap_d_zeros",0
debug$l		= "zap_d_debug",0
unknown$l	= "zap_d_unknown",0
; before here are the 'special' -ve's
decomp$l	= "zap_d_decomp",0
selfreloc$l	= "zap_d_selfreloc",0
zeroinit$l	= "zap_d_zeroinit",0
entry$l		= "zap_d_entry",0
foolish$l	= "zap_d_foolish",0
abs_readonly$l	= "zap_d_abs_readonly",0
abs_readwrite$l	= "zap_d_abs_readwrite",0
abs_debug$l	= "zap_d_abs_debug",0
abs_zeroinit$l	= "zap_d_abs_zeroinit",0
abs_debugtype$l	= "zap_d_abs_debugtype",0
abs_base$l	= "zap_d_abs_base",0
abs_workspace$l	= "zap_d_abs_workspace",0
abs_addrmode$l	= "zap_d_abs_addrmode",0
abs_database$l	= "zap_d_abs_database",0
abs_res1$l	= "zap_d_abs_res1",0
abs_res2$l	= "zap_d_abs_res2",0
	ALIGN


	LOCAL


;E R0=file offset R8/R9 R10=caret
;X Branch at this offset followed #
follow_branch
	FNJSR	"R1-R3"
	STR	R14,local_temp4r6 + 16	; blat cache...
	BIC	R1,R0,#3		; offset of instruction
 [ NEW_DISASM = 0
	PUSH	"R1"
	BL	getdisasmdata
	STR	R0,local_disassemblerflags
	BL	carefully_readandputdisasmdata
	PULL	"R1"
 ]
	; fudge
	MOV	R2,#8
	BL	getpreviousinstrs
	MOV	R2,#4
	BL	getpreviousinstrs
	; end fudge
	MOVS	R0,R1
	BLPL	cln_readw		; get instruction in R0
	MOV	R3,R0			; save 'instruction'
	LDR	R2,[R8,#w_addr]		; base address
	ADD	R1,R2,R1
	BL	find_branch_addr
	BVS	exit$l
	BCC	branch$l		; R0=new address

	BIC	R3,R3,#1 << 31		; clear bit 31...
	SUBS	R0,R3,R2		; file offset corresponding to this address
	BMI	exit$l			; off bottom of file (signed!)
	LDR	R14,[R9,#f_len]
	CMP	R0,R14
	BCS	exit$l			; off end of file
	MOV	R0,R3			; indirect (eg module header)
	SUB	R0,R0,R2		; find file offset
	BL	goto_offset
exit$l
 [ NEW_DISASM = 0
	BL	carefully_readandrestoredisasm
 ]
	FNRTS

branch$l
	SUB	R0,R0,R2		; find file offset
	BL	goto_offset
	B	exit$l

	LOCAL

mode4_return
	FNJSR	"R4"
	TEQ	R0,#0
	BNE	doword$l
inmode4_return
 [ NEW_DISASM = 0
	LDRB	R2,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDR	R2,[R14,R2,LSL #2]
	STR	R2,localmodeword
	BL	getdisasmdata
	STR	R0,local_disassemblerflags
	BL	loaddisasmwithcare	; if needed VC
	LDR	R2,localmodeword
	BL	carefully_readandputdisasmdata
 |
	BL	getdisasmdata
	BIC	R1,R0,#1<<23
	MOV	R0,#-1
	SWI	XDebugger_Flags
	BICVC	R0,R0,#&FF000000
	MOVVS	R0,#-1
	PUSH	"R0"
 ]
	ADR	R0,asm$l		; command to execute
	MOV	R1,#command_DontLearn
	BL	command_string
 [ NEW_DISASM = 0
	BL	carefully_readandrestoredisasm
 |
	PULL	"R1"
	TEQ	R1,#0
	MOVPL	R0,#-1
	SWIPL	XDebugger_Flags
	SUBS	R0,R0,R0 ; clv
 ]
	FNRTS
doword$l
	ADR	R0,word$l
	MOV	R1,#command_DontLearn
	BL	command_string
	FNRTS
asm$l	=	"ASSEMBLE",0
word$l	=	"EDITWORD",0
	ALIGN

mode4_start
	FNJSR	"R1"
	TEQ	R8,#0
	FNLDRB	R0,opt_format,EQ
	LDRNEB	R0,[R8,#w_format]	; mode number
	BL	modes_start
	BL	loaddisasmwithcare	; load it if needed/possible.
	CMP	R8,#0
	FNRTS	EQ
	LDRB	R1,[R8,#w_format]	; mode number
	ADD	R14,R12,#opt_mode0
	LDR	R0,[R14,R1,LSL #2]
	ADD	R14,R8,#w_mode0
	STR	R0,[R14,R1,LSL #2]
	FNRTS

mode4_end
	TEQ	R8,#0
	FNLDRB	R0,opt_format,EQ
	LDRNEB	R0,[R8,#w_format]	; mode number
	B	modes_end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Search through a line (detokenise)			;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;E R1=2 => R3=search file offset R4=direction
;  R1=3 => R1=detokenised str R2=offset/-ve R3=file off of line R10=len
;  R1=4 => As for 3 but R2=end of match offset
;X If R1=2 return vals as passed with R1=3
;  If R1=3 return R1=0 R2=file off of match R3=next offset
;  If R1=4 return R1=0 R2=file off of match end

mode4_search
	ADRL R14,local_temp4r6
	STR R14,[R14,#16]		; blat cache...
	TEQ R1,#3
	BEQ next$l			; find match offset and next line
	TEQ R1,#4
	BEQ end$l			; find end of match offset
	TEQ R1,#2
	MOVNE PC,R14
start$l					; get line to search through
	FNJSR
 [ NEW_DISASM = 0
	PUSH	"R1-R10"		; hmm...
	LDRB	R2,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDR	R2,[R14,R2,LSL #2]
	MOV	R3,R2
	BL	getdisasmdata
	STR	R0,local_disassemblerflags
	BL	search_readandputdisasmdata
	PULL	"R1-R10"
 |
	BL	getdisasmdata
 ]

	CMP	R4,#0
	ADDPL	R3,R3,#3		; offset 1-3 means go to the next line
	BIC	R3,R3,#3		; file offset of 'line start'
	MOVS	R0,R3
	BLPL	cln_readw		; R0=instruction
	LDRVC	R1,[R8,#w_addr]		; address of first byte
	ADDVC	R1,R1,R3		; address to assume instruction came from
	BLVC	mode4_clever_search	; R1=buf R2=len (RET VS???)
	BVS	possibleproblem$l
	MOV	R10,R2			; save the length
	CMP	R4,#0
	MOVPL	R2,#0			; offset in the detokenised line
	SUBMI	R2,R10,#1		; start at the line end

 [ NEW_DISASM = 0
	BL	readandrestoredisasm	; preserves...?
 ]

	FNRTS

possibleproblem$l
 [ NEW_DISASM = 0
	BL	readandrestoredisasm	; preserves...?
 ]
	ADDS	R14,R14,#0
	MOV	R1,#-1			; flag...????
	FNRTS

next$l
	MOV	R1,#0
	CMP	R2,#0
	MOVPL	R2,R3			; file offset of match (off in str ignored)
	ADD	R3,R3,R4,LSL #2		; jump a word in the correct direction
	MOV	PC,R14
end$l
	MOV	R1,#0
	ADD	R2,R3,#3
	MOV	PC,R14



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Insert a character							;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


	LOCAL

; --------------- e_char ---------------

; R4=w_flags R5=num typed R6=w_format R7=address of characters R8-R10=input
mode4_char
	FNJSR
	BL	minibuffer_wipe		; clear the minibuffer
a$l
	LDRB	R0,[R7],#1
	BL	minibuffer_writec
	FNRTS	VS
	SUBS	R5,R5,#1
	BGT	a$l			; fill up minibuffer
	LDR	R6,[R10,#c_off]		; offset of the instruction
	LDR	R5,[R8,#w_addr]		; address of offset 0
	BIC R6,R6,#3			; word align
	ADD	R0,R5,R6		; address instruction came from
	FNLDR	R1,wimp_block
	MOV	R2,#&100
	SWI	XOS_ConvertHex8		; start off with the address in hex
	FNRTS	VS
	FNLDR	R0,wimp_block
	BL	minibuffer_prompt
	FNRTS	VS
	MOV	R1,#0
	MOV	R0,#0			; address to assume instruction came from
 [ NEW_DISASM = 0
	SWI	XDebugger_Disassemble	; R1=buf R2=len
 |
	BL	disassemble		; R1=buf R2=len
 ]
	ADRVSL	R1,stored_blank_string
	ADR	R0,assemble$l
	BL	find_key_command	; locate+load
	FNRTS	VS
	TEQ	R0,#0
	FNRTS	EQ			; not found
	MOV	R7,R0			; command address
	BL	minibuffer_start	; open the minibuffer
	FNRTS
assemble$l FNS ("ASSEMBLE")

;local_bgcol_please
;	DCD	0


;X R1=pointer to the menu
mode4_menu
	FNJSR	"R0"
	MOV	R0,#14			; Code mode menu
	BL	read_menu_handle	; create the code mode menu
	FNRTS

redrawallcodemodewindows
	FNJSR	"R10"
	SWI	XHourglass_On
	ADR	R10,callallroutine$l
	BL	do_allwindow
	SWI	XHourglass_Off
	FNRTS
callallroutine$l
	FNJSR	"R0-R12"
	MOV	R0,#4
	BL	isthisaclonebase
	BLEQ	Updatewindow
	FNRTS

	LOCAL

redrawmostcodemodewindows		; 'global' ones anyway...
	FNJSR
	SWI	XHourglass_On
	CMP	R8,#0
	LDRNE	R0,[R8,#w_format]
	LDREQ	R0,[R12,#opt_format]
	TST	R0,#bit_windowwrap
	BLEQ	Updatewindow
	ADR	R10,callallroutine$l
	BL	do_allwindow
	SWI	XHourglass_Off
	FNRTS
callallroutine$l
	FNJSR	"R0-R12"
	MOV	R0,#4
	BL	isthisaclonebase
	FNRTS	NE
	LDR	R14,[R8,#w_format]
	TST	R14,#bit_windowwrap	; ???
	BLNE	Updatewindow
	FNRTS


	DCD	&8017
Code_disasmtoggle			; global cases dealt with here...
	LDR	R6,[R0]			; gets word argument...
	CMP	R6,#&18
	BCS	backtonormal$l
	FNJSR
	MOV	R0,#4
	BL	isthisaclonebase
r$l	MOVNE	R0,#2			; in case R2=15
	FNRTS	NE			; return if not (a clone of) Code mode
	CMP	R2,#15
	MOVLO	R14,R0
	TEQ	R0,R14			; menu - right mode?
	BNE	r$l
	CMP	R8,#0
	ADDEQ	R11,R12,#opt_mode0
	ADDNE	R11,R8,#w_mode0
	LDR	R0,[R11,R0,LSL #2]!	; mode word
	MOV	R7,R0
	CMP	R2,#15
	BEQ	but_tickquery2		; R2=15 indicates a 'tickquery'
	MOV	R5,R7,LSR #28
	BL	getdisasmdata
	MOV	R7,R0,LSL #8
	BIC	R7,R7,#(&F << 28)
	ORR	R7,R7,R5,LSL #28
	MOV	R5,#0
	AND	R1,R6,#&FF
	BL	mode4_execute
	MOV	R1,R6,LSR #8
	AND	R1,R1,#&FF
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R1,R6,LSR #16
	AND	R1,R1,#&FF
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R1,R6,LSR #24
	TST	R1,#&80
	BLNE	mode4_execute
 [ NEW_DISASM = 0
	MOV	R1,R7,LSR #8
	BIC	R7,R7,#(&F << 20)
	BL	putdisasmdata
 |
	TEQ	R8,#0
	FNLDR	R2,opt_format,EQ
	LDRNE	R2,[R8,#w_format]
	TST	R2,#bit_windowwrap	; global?
	MOVNE	R0,#-1
	BICNE	R1,R7,#&F << 28
	MOVNE	R1,R1,LSR #8
	SWINE	XDebugger_Flags
 ]
	BL	redrawmostcodemodewindows
	FNRTS

specialcasestosdeal
	CMP	R6,#255
	BEQ	but_tickquery2
	CMP	R6,#254
	BEQ	but_tickquery3a
	CMP	R6,#253
	FNRTS	NE
	MOV	R0,#0			; clear nothing
	MOV	R1,#(1<<25)		; free click?
	BL	new_wind_format_set
	BIC	R0,R0,#2
	CMP	R2,#15
	FNRTS	EQ
	CMP	R8,#0
	BLNE	Updatewindow
	FNRTS

but_tickquery3a
	TEQ	R2,#15
	BEQ	but_tickquery3b
	TEQ	R8,#0
	LDRNEB	R0,[R8,#w_format]
	LDREQB	R0,[R12,#opt_format]
	CMP	R0,#4
	FNRTS	NE
	MOV	R0,#0			; clear nothing
	MOV	R1,#bit_windowwrap	; toggle softwrap
	BL	new_wind_format_set
	BL	redrawmostcodemodewindows
	FNRTS

but_tickquery3b
	MOV	R0,#0			; clear nothing
	MOV	R1,#bit_windowwrap	; toggle softwrap
	BL	new_wind_format_set
	FNRTS

 [ NEW_DISASM = 0
getdisasmdata
	MOV	R0,#0
	MOV	R1,#0
	SWI	XDebugger_63
	SUBVS	R1,R1,R1		; 0 on error...
	MOV	PC,R14

putdisasmdata
	MVN	R0,#0
	SWI	XDebugger_63
	SUBS	R0,R0,R0		; clv.
	MOV	PC,R14
 ]

but_sortwwout
	FNJSR "R1-R12"
	BL	save_window_status
	BL	new_window_status	; update the window
	BL	Updatewindow
	FNRTS

	DCD	&8017
CmdCODEflagstoggle
	TEQ	R8,#0
	LDREQ	R11,[R12,#opt_format]
	LDRNE	R11,[R8,#w_format]
	TST	R11,#bit_windowwrap	; global?
	BNE	Code_disasmtoggle	; yes...
backtonormal$l
	FNJSR
	LDR	R6,[R0]			; gets word argument...
	MOV	R0,#4
	BL	isthisaclonebase
	MOVNE	R0,#2			; in case R2=15
	FNRTS	NE			; return if not (a clone of) Code mode
	CMP	R2,#15
	MOVLO	R14,R0
	TEQ	R0,R14			; menu - right mode?
	BNE	r$l
	TST	R6,#&80
	BNE	specialcasestosdeal
	TEQ	R8,#0
	ADDEQ	R11,R12,#opt_mode0
	ADDNE	R11,R8,#w_mode0
	LDR	R0,[R11,R0,LSL #2]!
	MOV	R7,R0
	CMP	R2,#15
	MOVEQ	R14,R6
	BEQ	but_tickquery		; R2=15 indicates a 'tickquery'
	MOV	R5,#0
	AND	R1,R6,#&FF
	BL	mode4_execute
	MOV	R1,R6,LSR #8
	AND	R1,R1,#&FF
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R1,R6,LSR #16
	AND	R1,R1,#&FF
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R1,R6,LSR #24
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R0,R7
	STR	R0,[R11]
	CMP	R8,#0
	BLNE	but_sortwwout		; window redraw if needed...
	FNRTS

but_tickquery
	AND	R2,R6,#&1F
	MOV	R3,#1
	MOV	R3,R3,LSL R2
	TST	R7,R3 ; r7?
	MOVNE	R0,#1
	MOVEQ	R0,#0
	FNRTS

but_tickquery2
	CMP	R6,#255
	BEQ	skipd_codestf
	AND	R6,R6,#&1F
	CMP	R6,#&1C
	BCS	but_tickquery
	SUB	R6,R6,#8
	MOV	R7,#1
	MOV	R7,R7,LSL R6 ; ???
 [ NEW_DISASM = 0
	MOV	R0,#0
	MOV	R1,#0
	SWI	XDebugger_63
 |
	BL	getdisasmdata
 ]
	MOVVS	R7,#0
	TST	R0,R7
	MOVVC	R0,#0
	MOVVS	R0,#2
	ORRNE	R0,R0,#1
	FNRTVC
skipd_codestf
	MOV	R0,#0
	MOV	R1,#0
 [ NEW_DISASM = 0
	SWI	XDebugger_63
 |
	SWI	XDebugger_Flags
 ]
	MOVVS	R0,#2
	MOVVC	R0,#0
	FNRTVC



; \E R1 is bit to operate on (as WFLAGS_TOGGLE)
;     b0-b4 bit
;     b5-b6 0=toggle
;	    1=set
;	    2=clear
;     b7 may be set
;    R7 is the word value to operate on
; \X R7 is the word value result
mode4_execute
	AND	 R2,R1,#&1F
	MOV	 R3,#1
	MOV	 R3,R3,LSL R2
	MOV	 R2,#0
	MOV	 R4,#0
	MOV	 R1,R1,LSR #5
	AND	 R1,R1,#3
	CMP	 R1,#1
	MOVEQ	 R2,R3
	CMP	 R1,#2
	MOVEQ	 R4,R3
	BIC	 R7,R7,R2
	ORR	 R7,R7,R4
	EOR	 R7,R7,R3
	MOV	 PC,R14



; -------------- e_interrogate --------------

mode4_interrogate
	CMP	R0,#11
	MOVEQ	R0,#0
	MOVEQ	PC,R14
	;BNE	couldbeokormaybenot
	;LDR	R0,local_bgcol_please
	;TST	R0,#3<<12 ; &40000000
	;MOVNE	R0,#0
	;MOVEQ	R0,#11
	;MOV	PC,R14

couldbeokormaybenot
	CMP	R0,#14
	MOVEQ	R0,#1
	MOVEQ	PC,R14
	CMP	R0,#16
	BEQ	binarytest$l
	CMP	R0,#15
	BEQ	colourquery$l
	CMP	R0,#13			; SAYT
	CMPNE	R0,#5			; ConfineH
	CMPNE	R0,#6			; ConfineV
	CMPNE	R0,#7			; Free click
	CMPNE	R0,#8			; Smart cursors
	CMPNE	R0,#12			; Line Select
	CMPNE	R0,#23			; block editing?
	CMPNE	R0,#24			; auto-indent
	MOVEQ	R0,#0
	MOVEQ	PC,R14
	CMP	R0,#1
	CMPNE	R0,#2
	MVNEQ	R0,#0
	TEQ	R0,#einterrogate_TabStops
	MOVEQ	R0,#einterrogate_NoTabs
	MOV	PC,R14

binarytest$l
	FNJSR
	LDRB	R0,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDR	R0,[R14,R0,LSL #2]	; load in our mode word
	TST	R0,#mode4_BinaryOpcodes
	MOVNE	R0,#2
	MOVEQ	R0,#16
	FNRTS

colourquery$l
	CMP	R1,#26
	MOVNE	PC,R14
	LDR	R0,[R8,#w_format]
	TST	R0,#1 << 25			; is it BG
	MOVNE	R0,#2			; bit 0 clear if it is...
	MOVEQ	R0,#15
	MOV	PC,R14



; -------------- e_help ----------------

; e_help entry point, written by James (feel free to replace)
;
; \E r0 offset, r8/r9
; \X r0 = number of possibilities, r1 => block of pointers to possibilities
;  r2-r11 preserved
;
; Note: this can probably be written far better by someone else.
; In particular, it would be nice if branches could offer the symbolic
; function name as a possibility, if it exists. That's really Justin's
; area, though ...

buf$l EQU 50
mode4_help
	FNJSR "r2-r3"
	BIC	r0,r0,#3		; round down to a whole word
	MOV	r2,r0			; store for disassembly
	LDR	r1,[r9,#f_splito]
	CMP	r0,r1			; is it past split?
	LDRGT	r1,[r9,#f_splits]
	ADDGT	r0,r0,r1		; jump over split
	LDR	r1,[r9,#f_ptr]		; start of buffer
	ADD	r0,r0,r1		; address
	LDR	r0,[r0]			; get instruction word
	AND	r1,r0,#(15:SHL:24)	; SWI identifying fragment
	CMP	r1,#(15:SHL:24)
	BNE	notswi$l

	BIC	r2,r0,#(255:SHL:24)	; clear to SWI number
	MOV	r0,#buf$l
	BL	heap_claim
	FNRTS	VS
	MOV	r1,r0			; buffer
	MOV	r0,r2			; SWI number
	MOV	r2,#buf$l
	SWI	XOS_SWINumberToString
	FNRTS	VS

	MOV	r0,#8
	BL	heap_claim
	BVS	fail$l

	STR	r1,[r0,#0]		; first possibility
	MOV	r1,r0			; ready for return
	MOV	r0,#4
	BL	heap_claim
	BVS	fail2$l

	STR	r0,[r1,#4]		; second possibility
	LDR	r2,swi$l
	STR	r2,[r0]			; store "SWI\0"
	MOV	r0,#2			; two possibilities
	FNRTS

fail$l	MOV	r2,r0			; store error pointer
	MOV	r0,r1			; buffer to free
	BL	heap_free
	MOV	r0,r2			; restore error pointer
	FNRTS

fail2$l	MOV	r2,r0			; store error pointer
	LDR	r0,[r1,#0]		; get SWI name buffer
	BL	heap_free		; free it
	MOV	r0,r1			; get the other buffer
	BL	heap_free		; free it
	MOV	r0,r2			; restore error pointer
	FNRTS

swi$l	=	"SWI", 0

; /E r0 = instruction word, r2 = file offset
notswi$l
	LDR	r1,[r8,#w_addr]		; start address for file
	ADD	r1,r1,r2		; address the instruction "came from"
	BIC	r0,r0,#(15:SHL:28)	; clear condition code
	ORR	r0,r0,#(14:SHL:28)	; 'AL' (disassembled invisibly)
 [ NEW_DISASM = 0
	SWI XDebugger_Disassemble	; naked???
 |
	BL disassemble
 ]

	MOVVC	r0,r2			; length, including terminator
	BLVC	heap_claim		; \X r0 => block
	FNRTS	VS

	MOV	r2,r1			; source
	MOV	r1,r0			; destination
	MOV	r3,r0			; save it
	BL	strcopy			; copy it, including terminator

	MOV	r0,#4
	BL	heap_claim
	BVS	failnotswi$l

	STR	r3,[r0]			; store pointer to disassembly
	MOV	r1,r0			; into position for return

	; this, of course, isn't enough. We now have to find the first
	; lwsp byte and replace it with a NUL, so that lookup will only
	; be on the opcode itself (plus flags. Arg.)
loop$l	LDRB	r2,[r3],#1
	CMP	r2,#32
	BGT	loop$l
	MOV	r0,#0
	STRB	r0,[r3,#-1]

	MOV	r0,#1			; one possibility
	FNRTS

failnotswi$l
	MOV	r1,r0			; store error pointer
	MOV	r0,r3			; get block pointer
	BL	heap_free		; free it
	MOV	r0,r1			; restore error pointer
	FNRTS


	LOCAL


; ------------- e_click -------------

mode4_click
	CMP	R1,#2
	BLO	default_click	; simple drag, or single click
	TST	R4,#3		; multiple click + drag
	BNE	default_click
	TST	R1,#1
	BNE	select_buffer	; odd number of clicks -> select all
	FNJSR
	BL	find_offset
	MOV	R2,R0
	ADD	R3,R2,#4
	LDR	R14,[R9,#f_len]
	CMP	R3,R14
	MOVHS	R3,R14
	TEQ	R2,R3
	BNE	sel$l
	BL	clear_selection
	FNRTS
sel$l	BL	alter_selected_region
	FNRTS


mode4_aligncaret
	FNJSR
	LDRB	R14,[R8,#w_format]
	LDR	R0,[R10,#c_off]
	BIC	R0,R0,#3			; word align
	STR	R0,[R10,#c_off]
	FNLDR	R0,car_hex		; copy so can be recovered only
	FNSTR	R0,car_hexold		; by e_char entry point
	MOV	R0,#0
	FNSTR	R0,car_hex		; zero current value
	FNRTS

	LOCAL

mode4_copy
	TEQ	R0,#2
	MOVEQ	R0,#1
	MOVEQ	PC,R14			; enter the text automatically
	FNJSR	"R1,R4-R7"
	MOV	R2,R1			; save number of times
	LDRB	R14,[R8,#w_format]
	FNLDR	R0,wimp_kbdbuf		; output buffer
	ADD	R14,R8,R14,LSL #2
	LDR	R14,[R14,#w_mode0]
	MOV	R1,R2,LSL#2		; words
	BL	heap_ensure
	FNRTS	VS
	FNSTR	R0,wimp_kbdbuf
	MOV	R3,R0			; buffer
	MOV	R4,#0			; number typed
	LDR	R7,[R10,#c_off]		; file offset
	LDR	R6,[R9,#f_len]		; end of file
	LDR	R0,[R8,#w_format]
	PUSH	"R0"
	BIC	R0,R0,#format_BigEndian
	STR	R0,[R8,#w_format]
	LDRB	R14,[R8,#w_format]
	ADD	R14,R8,R14,LSL #2
	LDR	R14,[R14,#w_mode0]
	AND	R14,R14,#mode1_Type
co29$l	CMP	R7,R6
	BCS	co30$l
	MOV	R0,R7
	BL	cln_readw
	STR	R0,[R3,R4,LSL#2]	; word
	ADD	R7,R7,#4
	ADD	R4,R4,#1
	CMP	R4,R2
	BLT	co29$l
co30$l	PULL	"R0"
	MOV	R2,R4,LSL#2		; number actually typed
	STR	R7,[R10,#c_off]
	BL	reflect_caret
	FNRTS



 END
