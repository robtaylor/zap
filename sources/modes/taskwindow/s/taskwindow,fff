; Contains mode entry points for Taskwindow mode.
; $Id: taskwindow,fff,v 1.19 2003-09-16 10:48:04 christian Exp $
; -*- armasm -*-

 GET h.ZapTWHdr
 GET h.module
 GET h.brackets

 EXPORT twmode_table_start
 EXPORT TaskWindow
 EXPORT create_task_window
 EXPORT Cmdtaskwindowflagstoggle
 EXPORT TaskWindow_Control

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Taskwindow block						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The taskwindow block pointed to by f_source has the following format:
;
; #0 Task handle of child task
; #4 Cursor x coordinate
; #8 Cursor y coordinate
; #12 Height of emulated screen in characters
; #16 Emulated text window (VDU 28) min x
; #20 Emulated text window (VDU 28) min y
; #24 Emulated text window (VDU 28) max x
; #28 Emulated text window (VDU 28) max y
; #32 Number of bytes in the VDU queue
; #36 12 byte vdu queue
; #48 pointer to RMA word holding text window
; #52 Flags b0 Task suspended
;	    b1 Ignore start/end
;	    b2 Task unlinked
;	    b3 Task killed
;	    b4 Output suspended (VDU 21)
;	    b5 Filter registered
; #56 Line offset in window of start of emulated screen.
; #60 Reserved
;
; R8,#w_bpl = width of emulated screen in characters
;
; Window layout:
;
;		0			    w_bpl
;	      0 ---------------------------------
;		|				|
;		|				|
;		|				|
;	    #56 |-------------------------------| }
;		|				| }
;		|		#16	#24	| }
;		|	#20+#56 ---------	| }
;		|		|	|	| } Emulated screen
;		|		|	|	| }
;		|	#28+#56 ---------	| }
;		|				| }
;	#56+#12 |-------------------------------| }
;		|				|
;      w_height |-------------------------------|
;
; Scrolling causes the emulated screen to move down the buffer unless a
; text window is set when the contents of the window is physically moved!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Taskwindows							;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

twmode_table_start
	DCD	twmode_table_start
	DCD	twmode_title
	DCD	twmode_author
	DCD	0
	DCD	12 + 1<<9 + 1<<14	; want mode 12+taskwindow input + mode menu file
	DCD	twmode_init
	DCD	twmode_menu		; menu
	DCD	twmode_table_end-twmode_table_start

	DCD	0			; postload
	DCD	0			; presave
	DCD	0			; loading
	DCD	twmode_start		; start
	DCD	twmode_end		; end
	DCD	0			; width
	DCD	0			; linecol
	DCD	0			; lineoff
	DCD	0			; clnlog
	DCD	0			; clnphy
	DCD	0			; clnoff
	DCD	0			; nextline
	DCD	0			; minus
	DCD	0			; plus
	DCD	0			; sminus
	DCD	0			; splus
	DCD	0			; cminus
	DCD	0			; cplus
	DCD	twmode_redrawline	; redrawline
	DCD	0			; redrawlnum
	DCD	twmode_char		; char
	DCD	0			; delete
	DCD	0			; tab
	DCD	0			; return
	DCD	0			; renumber
	DCD	0			; saveandrun
	DCD	0			; linestart
	DCD	0			; lineend
	DCD	0			; linenext
	DCD	0			; lineprev
	DCD	twmode_copy		; copy
	DCD	0			; joinline
	DCD	0			; splitline
	DCD	0			; aligncaret
	DCD	twmode_command		; command
	DCD	0			; compile
	DCD	0			; formattext
	DCD	0			; run
	DCD	0			; runandquit
	DCD	0			; basic
	DCD	0			; search
	DCD	0			; replace
	DCD	0			; selection
	DCD	twmode_click		; click
	DCD	twmode_message		; message
	DCD	twmode_setwidth		; setwidth
	DCD	0			; listfns
	DCD	0			; prevline
	DCD	0			; openwindow
	DCD	twmode_interrogate	; interrogate
	;DCD	0			; returnword
	;DCD	0			; help
	;DCD	0			; stripspaces
twmode_table_end

twmode_title	=	"Taskwindow",0
twmode_author	=	"Dominic Symes",0
twmode_menu	=	"ZapTaskWindow:Menus",0
		ALIGN


	LOCAL

; ----------- e_init -----------

twmode_init
	CMP	R1,#7
	ADDLO	PC,PC,R1,LSL #2
	B	other$l
	B	dying$l			; Zap about to exit
	B	starting$l		; Starting mode
	B	started$l		; Started mode
	B	taskwindow_kill		; Deleting owned file
	MOV	PC,R14			; Saving owned file
	B	taskwindow_diesilently	; Deleting altered owned file
	B	cols$l			; Creating colours submenu

other$l	TEQ	R1,#18			; building title bar
	BEQ	title$l
	TEQ	R1,#15			; Reuest pathname
	MOVNE	PC,R14
	TEQ	R9,#0
	MOVEQ	PC,R14
	LDR	R0,[R9,#f_source]
	LDR	R0,[R0,#2]
	MOV	R0,R0,LSR #16		; lower 16 bits of task handle
	SWI	&6258A			; DDEUtils_ 10
	SUBVSS	R0,R0,R0		; R0 = 0 + clv
	MOV	PC,R14

cols$l	ADR	R1,twmode_cols
	MOV	PC,R14

; Zap is building the title bar
title$l	LDR	R1,[R9,#f_source]
	LDR	R1,[R1,#52]		; flags
	TST	R1,#1			; suspended
	ADRNE	R1,sus$l
	MOVEQ	R1,#18
	MOV	PC,R14

sus$l	=	"(Suspended)",0		; FIXME: i18n
	ALIGN

; Zap is deleting a file we own
taskwindow_diesilently
	FNJSR	"R0,R2-R11"
	BL	get_workspace
	FNLDR	R1,mode_taskwindow
	FNcall  Zap_GetModeWord
	ANDS	R1,R0,#mw_die_silently
	MOVNE	R1,#-1
	FNRTS

; Zap has started our mode
started$l
	FNJSR	"R3"
	ADR	R0,s6$l
	ADR	R3,s5$l
	BLVC	alias_general		; preserve the old one...
	ADR	R0,t$l			; use ZapBasic_Taskwindow in future
	ADR	R3,s4$l
	BLVC	alias_general
	BLVC	init_mode_word		; set up mode words if needed

	MOVVC	R0,#256
	FNcallc	Zap_Claim,VC,R1
	FNSTR	R0,buffer,VC
	FNRTS

; Zap is about to exit
dying$l	FNJSR	"R1,R2,R3,R4"
	ADR	R0,s7$l
	ADR	R3,s4$l
	BL	alias_general
	MOVVC	R0,#-1			; don't kill the module yet
	FNRTS

; Zap is telling us our mode number
starting$l
	FNSTR	R0,mode_taskwindow	; mode used by taskwindow
	MOV	PC,R14

s4$l	=	"Alias$Taskwindow",0
s5$l	=	|zap$|,"$Taskwindow",0
s6$l	=	"<Alias$Taskwindow>",0
s7$l	=	"<",|zap$|,"$Taskwindow>",0
t$l	=	|zap$|,"_TaskWindow ",0
	ALIGN

twmode_cols
	=	"*",0
	=	">",0
	=	0
	ALIGN


	LOCAL

;E R0=string to alias taskwindow command to
;  R3 = name of os_var to be set
;X command aliased #
alias_general
	FNJSR	"R1-R4"
	MOV	R1,R0			; var value
	BL	str_len
	MOV	R2,R0			; var length
	MOV	R0,R3
	MOV	R3,#0
	MOV	R4,#0			; macro string
	SWI	XOS_SetVarVal
	FNRTS

	LOCAL

twmode_start
	FNJSR	"R1-R3,R7"
	PUSH	"R0-R12"		; BUG!!!!!!!!!!!!!!!!!!!
	BL	loadlineeditor
	PULL	"R0-R12"
	FNLDR	R1,mode_taskwindow	; mode number of taskwindow mode
	MOV	R0,R1
	FNcall	Zap_RestoreModeWord,R1
	FNRTS	VS
	LDR	R0,[R9,#f_cmode]
	TEQ	R0,R1
	FNRTS	NE			; this is not an active taskwindow
	LDR	R7,[R9,#f_source]	; data buffer
	LDR	R0,[R7,#52]		; flags
	TST	R0,#2			; ignore? - never used...?
	FNRTS	NE
	TST	R0,#1			; task suspended?
	FNRTS	EQ
	BIC	R0,R0,#1
	STR	R0,[R7,#52]		; resume task
	FNLDR	R1,buffer
	MOV	R0,#20
	STR	R0,[R1]			; length
	MOV	R0,#0
	STR	R0,[R1,#12]		; your ref
	LDR	R0,resume$l
	STR	R0,[R1,#16]		; action
	MOV	R0,#17
	LDR	R2,[R7]
	SWI	XWimp_SendMessage	; resume task
	FNRTS

twmode_end
	FNJSR	"R1-R3,R7"
	FNLDR	R1,mode_taskwindow	; mode used by taskwindows
	MOV	R0,R1
	FNcall	Zap_SaveModeWord,R1
	FNRTS	VS
	LDR	R0,[R9,#f_cmode]
	TEQ	R0,R1
	FNRTS	NE
	LDR	R7,[R9,#f_source]
	LDR	R0,[R7,#52]		; flags
	TST	R0,#2			; ignore?
	FNRTS	NE
	TST	R0,#1			; already suspended?
	FNRTS	NE
	ORR	R0,R0,#1
	STR	R0,[R7,#52]
	FNLDR	R1,buffer
	MOV	R0,#20
	STR	R0,[R1]			; length
	MOV	R0,#0
	STR	R0,[R1,#12]		; your ref
	LDR	R0,suspend$l
	STR	R0,[R1,#16]		; action
	MOV	R0,#17
	LDR	R2,[R7]
	SWI	XWimp_SendMessage	; suspend task
	FNRTS


; ------------ TASKWINDOW_CONTROL command ------------

	DCD	7+(2<<3)+(1<<15)
TaskWindow_Control
	CMP	R8,#0
	BEQ	tickq0$l
	CMP	R9,#0
	BEQ	tickq0$l
	CMP	R0,#0
	MOVLE	PC,R14
	FNJSR	"R7,R10,R11"		; must match with later on pre_kill...!
	BL	get_workspace
	LDRB	R7,[R8,#w_format]
	FNLDR	R10,mode_taskwindow
	CMP	R10,R7
	BNE	tickq0a$l
	LDR	R10,[R0]
	LDR	R7,[R9,#f_source]
	CMP	R7,#0
	BLE	tickq6$l
	CMP	R10,#0
	BEQ	TaskWindowSuspend$l
	CMP	R10,#2
	BEQ	TaskWindowUnlink$l
	CMP	R10,#3
	BEQ	TaskWindowLink$l
	CMP	R10,#4
	BEQ	TaskWindowKill
	CMP	R10,#5
	BEQ	TaskWindowResurrect
	LDR	R14,[R7,#52]		; flags
	TEQ	R2,#15
	BEQ	tickq1$l
	TST	R14,#1			; task suspended?
	FNRTS	EQ
	BIC	R14,R14,#1
	STR	R14,[R7,#52]		; resume task

	ADR	R1,local_twmsgbuffer
	MOV	R0,#20
	STR	R0,[R1]			; length
	MOV	R0,#0
	STR	R0,[R1,#12]		; your ref
	LDR	R0,resume$l
	STR	R0,[R1,#16]		; action
	MOV	R0,#17
	LDR	R2,[R7]
	SWI	XWimp_SendMessage	; resume task

	FNcall	Zap_NewFileTitle,R0
	FNRTS

tickq0$l
	MOV	R0,#2
	MOV	PC,R14
tickq0a$l
	MOV	R0,#2
	FNRTS

tickq1$l
	TST	R14,#1			; task suspended?
	MOVEQ	R0,#2
	MOVNE	R0,#0
	TST	R14,#8			; task dead?
	MOVNE	R0,#2
	FNRTS

tickq2$l
	TST	R14,#9			; task suspended?
	MOVNE	R0,#2
	MOVEQ	R0,#0
	FNRTS

tickq3$l
	TST	R14,#4			; task linked?
	MOVEQ	R0,#2
	MOVNE	R0,#0
	TST	R14,#8			; task dead?
	MOVNE	R0,#2
	FNRTS

tickq4$l
	TST	R14,#12			; task linked?
	MOVNE	R0,#2
	MOVEQ	R0,#0
	FNRTS

tickq5$l
	TST	R14,#8			; task killed?
	MOVNE	R0,#2
	MOVEQ	R0,#0
	FNRTS

tickq6$l
	TST	R14,#8			; task killed?
	MOVEQ	R0,#2
	MOVNE	R0,#0
	FNRTS

local_twmsgbuffer
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0

TaskWindowSuspend$l
	LDR	R14,[R7,#52]		; flags
	TEQ	R2,#15
	BEQ	tickq2$l
	TST	R14,#1			; already suspended?
	FNRTS	NE
	ORR	R14,R14,#1
	STR	R14,[R7,#52]

	ADR	R1,local_twmsgbuffer
	MOV	R0,#20
	STR	R0,[R1]			; length
	MOV	R0,#0
	STR	R0,[R1,#12]		; your ref
	LDR	R0,suspend$l
	STR	R0,[R1,#16]		; action
	MOV	R0,#17
	LDR	R2,[R7]
	SWI	XWimp_SendMessage	; suspend task

	FNcall	Zap_NewFileTitle,R0
	FNRTS

suspend$l	DCD	&808C6			; TaskWindow_Suspend
morite$l	DCD	&808C4			; TaskWindow_Morite
resume$l	DCD	&808C7			; TaskWindow_Resume

TaskWindowLink$l
	LDR	R14,[R7,#52]		; flags
	TEQ	R2,#15
	BEQ	tickq3$l
	BIC	R14,R14,#6		; and ignore bit.
	STR	R14,[R7,#52]
	BL	register_filter		; register the filter again
	FNRTS

TaskWindowUnlink$l
	LDR	R14,[R7,#52]		; flags
	TEQ	R2,#15
	BEQ	tickq4$l
	ORR	R14,R14,#6		; and ignore bit.
	STR	R14,[R7,#52]
	BL	deregister_filter	; derigster filter, in case it gets permanently unlinked
	FNRTS

TaskWindowResurrect
	LDR	R14,[R7,#52]		; flags
	TEQ	R2,#15
	BEQ	tickq6$l
	BIC	R14,R14,#15
	STR	R14,[R7,#52]		; flags
	BL	get_workspace
	BL	resurrect_task_window
	LDR	R0,[R8,#w_bpl]
	BL	twmode_setwidth		; clear screen...?
	FNRTS

pre_TaskWindowKill
	FNJSR	"R7,R10,R11"		; must match...!
TaskWindowKill
	LDR	R14,[R7,#52]		; flags
	TEQ	R2,#15
	BEQ	tickq5$l
	PUSH	"R0-R2"
	ORR	R14,R14,#8
	STR	R14,[R7,#52]		; killed flag.
	ADR	R1,local_twmsgbuffer
	MOV	R0,#20
	STR	R0,[R1]			; length - no data.
	MOV	R0,#0
	STR	R0,[R1,#12]		; my ref
	LDR	R0,morite$l
	STR	R0,[R1,#16]		; message
	MOV	R0,#17
	LDR	R2,[R9,#f_source]	; buffer pointer
	LDR	R2,[R2]			; task handle
	SWI	XWimp_SendMessage	; kill the task
	PULL	"R0-R2"
	FNRTS


	LOCAL

;;;;;;;;;;;;;;;;;;;
; Kill TaskWindow ;
;;;;;;;;;;;;;;;;;;;

taskwindow_kill
	FNJSR	"R0-R12"
	MOV	R2,#0			; /could/ be important...!?
	LDR	R7,[R9,#f_source]

	LDR	R14,[R7,#52]		; flags
	TST	R14,#4			; unlinked
	BLEQ	pre_TaskWindowKill

	BL	deregister_filter	; ensure filter is dergistered

	MOV	r0, #7			; remove the RMA word
	MOV	r1, r2
	SWI	XOS_Module
	MOV	r0, #0
	STR	r0, [r7, #48]

	MVN	R14,#0
	STR	R14,[R9,#f_cmode]	; disown file
	MOV	R0,R7
	FNcall  Zap_Free,R10		; free the buffer
	FNRTS


; ----------- e_redrawline ------------

twmode_redrawline
	FNJSR	"R4,R12"

	SUB	R0,R7,R5		; file offset
	BL	get_line_type		; get colour

	LDR	R3,[R8,#w_txtw]		; width of cache
	LDR	R12,[R8,#w_bpl]
	MOV	R14,#0			; column

main$l	CMP	R7,R10
	BLO	sok$l
	LDR	R10,[R9,#f_len]
	ADD	R10,R10,R5
	CMP	R7,R10
	FNRTS	HS
	LDR	R1,[R9,#f_splits]
	ADD	R7,R7,R1
	ADD	R5,R5,R1
	ADD	R10,R10,R1
sok$l	TEQ	R14,R12                 ; check if reached window edge
	FNRTS	EQ

	LDRB	R0,[R7],#1

	TEQ	R0,#10			; if LF, inc line number and done
	ADDEQ	R11,R11,#1
	FNRTS	EQ

	MOV	R1,#c_bg		; store background colour
	STRB	R1,[R6,R3,LSL #1]
	STRB	R2,[R6,R3]		; foreground colour
	STRB	R0,[R6],#1		; char

	ADD	R14,R14,#1		; next column
	B	main$l


	LOCAL

; check the character at the SOL and return a colour number for the line
; E r0 = file offset in line
; X r2 = colour
; TODO: this could use the current text window
get_line_type
	FNJSR	"R0,R10,R11"
	MOV	R10,#0			; find the line start by calling Text mode
	MOV	R11,#e_linestart
	FNcall	Zap_CallGivenMode

	LDR	R10,[R9,#f_len]		; assume fg if off end
	CMP	R0,R10
	MOVHS	R2,#c_fg
	FNRTS	HS

	LDR	R10,[R9,#f_splito]	; hop over the split
	CMP	R0,R10
	LDRHS	R10,[R9,#f_splits]
	ADDHS	R0,R0,R10

	LDR	R10,[R9,#f_ptr]
	LDRB	R0,[R10,R0]		; load the char of the SOL

	MOV	R2,#c_fg		; set the colour
	TEQ	R0,#'*'
	MOVEQ	R2,#c_star
	TEQ	R0,#'>'
	MOVEQ	R2,#c_gt
	FNRTS


	LOCAL


; -------------- e_setwidth ---------------

twmode_setwidth
	FNJSR	"R1,R10"
	FNLDR	R10,mode_taskwindow
	MOV	R1,R0
	BL	set_width
	FNRTS	VS
	TEQ	R8,#0
	FNRTS	EQ
	CMP	R1,#0
	STRPL	R1,[R8,#w_bpl]
	BLPL	tw_newwidth
	FNRTS

	LOCAL

twmode_copy
	TEQ	R0,#2
	MOVEQ	PC,R14			; please call my e_chars
	TEQ	R0,#1
	MOVNE	PC,R14			; not collecting data
	FNJSR	"R1,R4-R7"		; R2 and R3 returned
	MOV	R6,R1			; R6=number of characters to get (saved)
	LDR	R0,[R9,#f_cmode]
	FNLDR	R7,mode_taskwindow
	TEQ	R0,R7
	MOVNE	R3,#0
	MOVNE	R2,#0
	FNRTS	NE			; not in a proper task window
	LDR	R7,[R9,#f_source]	; buffer
	FNLDR	R0,buf_insert
	FNcall  Zap_Ensure
	FNRTS	VS
	FNSTR	R0,buf_insert
	MOV	R5,R0			; R5=buffer
	LDR	R2,[R10,#c_col]		; cursor x
	LDR	R3,[R10,#c_line]	; cursor y
	LDR	R0,[R8,#w_margin]
	SUBS	R2,R2,R0
	MOVMI	R2,#0
	LDR	R0,[R7,#56]
	SUBS	R3,R3,R0
	MOVMI	R3,#0			; cursor x y on screen
	MOV	R4,R6			; width to get counter
loop$l
	CMP	R4,#0
	BLE	end$l			; finished
	BL	tw_getchar
	STRVCB  R0,[R5],#1
	BLVC	tw_increment
	SUBVC	R4,R4,#1		; done one more
	BVC	loop$l
	FNRTS
end$l
	BL	twc_to_xy_nopad
	STR	R2,[R10,#c_col]
	STR	R3,[R10,#c_line]	; cursor posn
	FNcall  Zap_FindOffset
	STRVC	R0,[R10,#c_off]
	STRVC	R1,[R10,#c_loff]
	FNLDR	R3,buf_insert,VC	; buffer
	MOVVC	R2,R6			; number of characters
	FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Vet the taskwindow command!				    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E As for a command. NB TaskWindow -Display is used by CTRL-F12
;  Uses .taskw_str to store the command

TaskWindow
	FNJSR	"R1-R12"
	LDR	R11,[R12]		; this module's workspace
	MOV	R3,R0			; save tail
	ADD	R1,R11,#taskw_str
	ADR	R2,ta_s0
	BL	strcpy			; copy in unaliased command
	MOV	R4,R1			; save start of arguments
	MOV	R2,R3
	BL	strcopy			; copy string accross
	SUB	R5,R1,#1		; save end of arguments
	LDRB	R0,[R4]
	CMP	R0,#'0'
	BCC	tota2
	CMP	R0,#'9'
	BCC	ta1
tota2
	MOV	R1,#0			; replying to startup message
ta2
	LDRB	R0,[R4],#1
	CMP	R0,#&20
	BCC	ta3			; -ctrl not found
	CMP	R0,#34			; "
	EOREQ	R1,R1,#1
	TST	R1,#1
	BNE	ta2
	TEQ	R0,#'-'
	BNE	ta2			; not the start of an option
	SUB	R2,R4,#1
	ADR	R1,ta_s1
	BL	strcmpstr
	BNE	ta2			; doesn't match
	B	ta1			; found a -ctrl
ta3
	MOV	R0,#&20
	STRB	R0,[R5]			; add space
	ADD	R1,R5,#1
	ADR	R2,ta_s1
	BL	strcopy			; copy in -CTRL option
ta1
	ADD	R0,R11,#taskw_str
	SWI	XOS_CLI
	FNRTS

ta_s0	FNS	("%TaskWindow ")
ta_s1	FNS	("-ctrl")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Taskwindow messages					     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

twmode_message
	TEQ	R3,#17
	MOVNE	PC,R14
	SUB	R0,R2,#&80000
	SUB	R0,R0,#&008C0
	CMP	R0,#6
	ADDLO	PC,PC,R0,LSL#2
	MOV	PC,R14			; unrecognised
	B	TaskWindow_Open		; sent by Zap to open task window
	B	TaskWindow_Output
	B	TaskWindow_Ego
	B	TaskWindow_Morio
	MOV	PC,R14
	B	TaskWindow_NewTask

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Taskwindow code					 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TaskWindow_Open
	FNJSR	"R10"
	MOV	R10,#0
	BL	create_task_window	; open the task window
	FNRTS

TaskWindow_NewTask
	FNJSR	"R1-R2,R10"		; please open a task window
	MOV	R10,R1			; wimp message
	LDR	R0,[R10,#8]
	STR	R0,[R10,#12]		; copy my ref
	MOV	R0,#19			; acknowledge
	MOV	R1,R10			; message
	LDR	R2,[R10,#4]		; task
	SWI	XWimp_SendMessage	; acknowledge
	ADDVC	R10,R10,#20		; command to use
	BLVC	create_task_window	; start up a task window
	FNRTS

;E R8/R9=0 for normal startup/address of command to use
;X Taskwindow file created DB #

resurrect_task_window
	FNJSR	"R1-R9"
	ADR	R0,tw_s0
	SWI	XOS_CLI			; check task window module ok
	MOVVC	R10,#0
	BVC	rude_tw_entry
	FNRTS

;E R10=0 for normal startup/address of command to use
;X Taskwindow file created DB #

create_task_window
	FNJSR	"R1-R9"
	ADR	R0,tw_s0
	SWI	XOS_CLI			; check task window module ok
	FNRTS	VS
	MOV	R0,#&F00
	ORR	R0,R0,#&FF
	MOV	R1,#1
	MOV	R2,#0			; no undo
	MOV	R3,#&FF
	ORR	R3,R3,#1<<31
	FNLDR	R4,mode_taskwindow	; taskwindow mode
	ORR	R4,R4,#1<<31
	FNcall  Zap_CreateFile		; create an empty R8/R9
	MOVVC	R0,#0
	FNcallc Zap_PutCaret,VC		; bung cursor in there
	FNRTS	VS
rude_tw_entry
	MOV	R6,#&20			; space
	FNLDR	R1,buffer		; place to put start command
	MOVS	R2,R10
	ADREQ	R2,tw_s1		; use default
	MOV	R0,#'%'
	STRB	R0,[R1],#1		; unaliased version
	BL	strcpy
	TEQ	R10,#0
	STRNEB  R6,[R1],#1		; add space
	PUSH	"R1"			; save string pointer
	MOV	R1,#4
	FNcall  Zap_ReadVar		; get zap's task handle
	PULL	"R1"
	FNRTS	VS
	MOV	R2,#16
	SWI	XOS_ConvertHex8		; insert task handle
	FNRTS	VS
	ADR	R2,tw_s2
	TEQ	R10,#0
	STRNEB  R6,[R1],#1		; add space
	BLEQ	strcpy			; add -txt
	FNcall  Zap_GetWindOff
	MOV	R2,#16
	SWI	XOS_ConvertHex8		; add in as my unique handle
	FNRTS	VS
	TEQ	R10,#0
	STRNEB  R6,[R1],#1		; add extra space on the end
	MOV	R0,#0
	STRB	R0,[R1]			; terminator
	FNLDR	R0,buffer
	SWI	XWimp_StartTask		; try and start up task
	FNRTS

tw_s0	FNS	("RMEnsure TaskWindow 0.29 RMLoad System:Modules.Task")
tw_s1	FNS	("TaskWindow -task &")
tw_s2	FNS	(" -ctrl -txt &")

	LOCAL

; Taskwindow is telling me its handle. I use its task handle to find out
; its name. Uses buffer.

TaskWindow_Ego
	FNJSR	"R1-R11"
	MOV	R10,R1
	LDR	R0,[R10,#20]		; my -txt handle for this
	FNcall  Zap_ConvWindOff		; R8/R9=file
	LDR	R0,[R9,#f_ptr]
	CMP	R0,#0
	FNRTS	LE			; problems!
	MOV	R0,#64
	FNcall  Zap_Claim		; claim buffer for taskwindow
	FNRTS	VS
	STR	R0,[R9,#f_source]
	MOV	R7,R0			; buffer
	FNLDR	R0,mode_taskwindow
	STR	R0,[R9,#f_cmode]	; a task window owned file
	LDR	R0,[R10,#4]		; tasks id
	STR	R0,[R7]			; fill it in
	MOV	R0,#0
	STR	R0,[R7,#32]		; zero queue
	STR	R0,[R7,#52]		; zero flags
	STR	R0,[R7,#56]		; screen image offset
	STR	R0,[R7,#48]

	MOV	r0, #6			; the text window has to be in RMA
	MOV	r3, #4
	SWI	XOS_Module
	STRVC	r2, [r7, #48]

	MOVVC	R0,#-1
	BLVC	taskwindow_mode		; find mode x,y
	STRVC	R3,[R7,#12]		; screen height
	BLVC	tw_restore_window
	FNRTS	VS
	FNcall  Zap_GetFileOff		; R0=file offset
	MOV	R6,R0			; save as the private word
	LDR	R0,mess$l		; Task Name Request Message + want reply
	FNLDR	R1,buffer		; message
	LDR	R14,[R7]		; task id
	STR	R14,[R1,#20]
	MOV	R2,#0			; broadcast
	MOV	R3,#24			; message length
	ADR	R5,sub$l		; reply sub
	FNcall  Zap_SendMessage		; ask for the task name

	BL	register_filter
	FNRTS

mess$l  DCD	&400C6+(1<<28)+(2<<30)

sub$l					; R1=message block R11=file offset
	FNJSR
	LDR	R0,mess2$l
	TEQ	R0,R2
	FNRTS	NE			; not the correct message
	MOV	R0,R11
	FNcall  Zap_ConvFileOff		; set up R9
	ADDVC	R0,R1,#28
	FNcallc Zap_NewFileName,VC	; change the file name to the task name
	FNcallc Zap_NewFileTitle,VC	; update the titlebars
	FNRTS
mess2$l DCD	&400C7			; Name is reply message


TaskWindow_Morio
	FNJSR	"R1-R11"

	LDR	R0,[R1,#4]		; child handle
	BL	find_task_window	; R9=taskwindow
	FNRTS	VS
	TEQ	R9,#0
	FNRTS	EQ			; not found

	LDR	R7,[R9,#f_source]	; data buffer
	LDR	R14,[R7,#52]		; flags
	ORR	R14,R14,#8		; killed flag.
	STR	R14,[R7,#52]

	BL	deregister_filter

	LDR	R0,[R9,#f_flags]
	BIC	R0,R0,#1<<3		; modified...?
	STR	R0,[R9,#f_flags]
	FNcall  Zap_NewFileTitle
	FNRTS

	LOCAL

; I have been sent some data to print

TaskWindow_Output
	FNJSR	"R1-R11"
	LDR	R0,[R1,#4]		; child handle
	BL	find_task_window	; R9=taskwindow
	FNRTS	VS
	TEQ	R9,#0			; found?
	FNRTS	EQ
	BL	tw_getinputcur
	FNRTS	VS
	PUSH	"R9"
	LDR	R0,[R10,#c_wind]
	FNcall  Zap_ConvWindOff		; get R8/R9 of input cursor
	MOV	R0,R9
	PULL	"R9"
	TEQ	R0,R9
	BEQ	window$l		; cursor is in a window onto this file
	FNcall  Zap_FindWindow		; find first window on this file
	FNRTS	VS
window$l				; found the correct window in R8
	LDR	R7,[R9,#f_source]	; pointer to buffer
	ADD	R4,R1,#24		; data
	LDR	R5,[R1,#20]		; data len
	LDR	R0,[R7,#32]		; number of bytes queued
	TEQ	R0,#0
	BEQ	start$l			; none queued
	CMP	R0,#9
	BHI	start$l			; ridiculous buffer
	SUB	R4,R4,R0
	ADD	R5,R5,R0
	ADD	R1,R7,#36		; queue
	MOV	R2,R4
	MOV	R3,R0
	FNcall  Zap_MoveBytes		; copy queue in over message
	MOV	R0,#0
	STR	R0,[R7,#32]		; zero queue
start$l					; R4=data R5=data len
	FNcall  Zap_StartOp		; do all in one go
	FNRTS	VS
	MOV	R1,#10
	FNcall  Zap_ReadVar		; read caret mode
	MOVVC	R10,R0			; save caret mode
	MOVVC	R0,#-2
	FNcallc Zap_WriteVar,VC		; pretend there are no carets
	BVS	end$l
loop$l					; R4=data R5=data len
	CMP	R5,#0
	BLE	end$l			; finished
	MOV	R3,R4			; save data start
	LDRB	R0,[R4],#1		; get next char
	SUB	R5,R5,#1
	BL	test_ctrl_char
	CMP	R1,#0
	BPL	ctrl$l			; control char
collect$l				; collect longest string of normal chars
	CMP	R5,#0			; before a ctrl char
	BLE	collected$l
	LDRB	R0,[R4]
	BL	test_ctrl_char
	CMP	R1,#0
	SUBMI	R5,R5,#1
	ADDMI	R4,R4,#1
	BMI	collect$l
collected$l
	SUB	R2,R4,R3		; num chars collected
	BL	taskwindow_output_char
	BVC	loop$l
	B	end$l
ctrl$l
	CMP	R5,R1
	BLT	tw16			; need to queue the data
	TEQ	R1,#0
	BNE	tw14			; don't try and buffer
tw17
	CMP	R5,#0
	BLE	tw14			; no more data
	LDRB	R14,[R4]
	TEQ	R0,R14
	ADDEQ	R4,R4,#1
	SUBEQ	R5,R5,#1
	BEQ	tw17			; absorb repetitions
tw14
	SUB	R2,R4,R3		; number of times
	BL	taskwindow_output_ctrl
	ADDVC	R4,R4,R1		; skip the params
	SUBVC	R5,R5,R1
	BVC	loop$l
	B	end$l
tw16
	MOV	R1,R3			; source
	ADD	R2,R7,#36		; queue
	ADD	R3,R5,#1		; number
	STR	R3,[R7,#32]		; number queued
	FNcall  Zap_MoveBytes		; fill queue
end$l					; end / error
	BL	tw_restore_car
	FNcall  Zap_StopOp		; finish the op
	BLVC	tw_showcursor		; make sure cursor visible etc
	FNRTS

tw_restore_car
	FNJSR	"R0-R1"
	MOV	R0,R10
	MOV	R1,#10
	FNcall  Zap_WriteVar		; restore the caret mode
	FNRTS

;X R10=cursor block of the input cursor

tw_getinputcur
	FNJSR	"R1"
	MOV	R1,#10
	FNcall  Zap_ReadVar		; get caret mode
	FNRTS	VS
	TEQ	R0,#2
	MOVNE	R1,#5			; cursor
	MOVEQ	R1,#6			; input
	FNcall  Zap_ReadVar		; find cursor posn
	MOVVC	R10,R0			; save cursor
	FNRTS

	LOCAL

;E R7=block R8/R9
;X If got cursor then posn updated and plotted
;  If not got cursor then pseudo posn made visable BD #

tw_showcursor
	FNJSR	"R1-R5,R10"
	BL	tw_getinputcur		; R10=input cursor
	FNRTS	VS
	FNcall  Zap_GetWindOff
	LDR	R1,[R10,#c_wind]
	TEQ	R0,R1
	BNE	nocur$l			; we haven't got the cursor
	BL	twc_buf_xy_nopad	; get cursor posn
	STRVC	R2,[R10,#c_col]
	STRVC	R3,[R10,#c_line]	; update cursor posn!?!?!
	FNcallc Zap_FindOffset,VC
	STRVC	R0,[R10,#c_off]
	STRVC	R1,[R10,#c_loff]
	FNcallc Zap_PlotCaret,VC
	FNcallc Zap_ShowCursor,VC
	FNRTS
nocur$l
	FNLDR	R10,buffer		; simulate cursor
	FNcall  Zap_GetWindOff
	STRVC	R0,[R10,#c_wind]
	STRVC	R0,[R10,#c_owind]
	MOVVC	R0,#0
	STRVC	R0,[R10,#c_off]
	STRVC	R0,[R10,#c_loff]
	MOVVC	R0,#1
	STRVC	R0,[R10,#c_width]
	STRVC	R0,[R10,#c_owidth]
	BLVC	twc_buf_xy_nopad	; get cursor posn
	STRVC	R2,[R10,#c_col]		; may use buffer if adding y's
	STRVC	R2,[R10,#c_ocol]
	STRVC	R3,[R10,#c_line]	; update cursor posn
	STRVC	R3,[R10,#c_oline]
	FNcallc Zap_GetWindState,VC
	FNcallc Zap_ShowCursor,VC
	FNRTS

	LOCAL

;E R0=vdu character
;X If R0 a normal printable character then R0 saved R1=-1
;  If R0 a ctrl char then R0 saved and R1=number of param bytes

test_ctrl_char
	TEQ	R0,#&7F
	MOVEQ	R1,#0
	MOVEQ	PC,R14
	CMP	R0,#&20
	MVNCS	R1,#0
	MOVCS	PC,R14
	ADR	R1,table$l
	LDRB	R1,[R1,R0]
	MOV	PC,R14
table$l
	DCD	&00000100		; VDU 0-7
	DCD	&00000000
	DCD	&00000000		; VDU 8-15
	DCD	&00000000
	DCD	&05020100		; VDU 16-23
	DCD	&09010000
	DCD	&00000508		; VDU 24-31
	DCD	&02000404

	LOCAL

;E R0=task handle of task window task
;X R9=pointer to associated file /0 if not found |

find_task_window
	FNJSR	"R1-R4"
	FNLDR	R4,mode_taskwindow
	MOV	R3,R0			; save task handle
	MOV	R1,#9
	FNcall  Zap_ReadVar
	FNRTS	VS
	MOV	R1,R0			; number of files
	MOV	R2,#0			; current file
loop$l
	CMP	R2,R1
	MOVCS	R9,#0			; run out of files so not found
	FNRTS	CS
	MOV	R0,R2
	FNcall  Zap_ConvFileOff		; find address of file block
	LDR	R14,[R9,#f_ptr]
	CMP	R14,#0
	BLE	next$l			; this file is empty/invalid
	LDR	R14,[R9,#f_cmode]
	TEQ	R14,R4
	BNE	next$l			; not a task window
	LDR	R14,[R9,#f_source]	; buffer pointer
	LDR	R14,[R14]		; task handle
	TEQ	R14,R3			; is it the correct one?
	FNRTS	EQ
next$l
	ADD	R2,R2,#1		; try next file
	B	loop$l

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Input to a taskwindow					  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

twmode_command
	FNJSR	"R1"
	AND	R0,R0,#7		; basic command number
	TEQ	R0,#1			; an insert?
	BNE	actively_ignore_input	; digit '1' to ctrl-1 etc. Taskwindow
	LDR	R14,[R9,#f_source]
	LDR	R14,[R14,#52]		; flags
	TST	R14,#15			; ignore / suspended / killed
	BNE	actively_ignore_input
a$l					; wait 'till ctrl key not pressed or
	BL	test_shiftctrl		; taskwindow module starts converting
	BVS	actively_ignore_input	; digit '1' to ctrl-1 etc. Taskwindow
	TST	R1,#2			; module is *BADLY* written. Beware!
	BNE	a$l			; control still pressed ; no multi-task :(
	MOV	R0,R3			; data address
	MOV	R1,R2			; data length
	BL	taskwindow_input
actively_ignore_input
	MOV	R2,#0
	FNRTS


twmode_char
	FNJSR
	LDR	R14,[R9,#f_source]
	LDR	R14,[R14,#52]		; flags
	TST	R14,#7			; ignore or suspended
	FNRTS	NE
	FNLDR	R1,mode_taskwindow
	BL	charchar
	MOV	R0,R7
	MOV	R1,R5
	BL	taskwindow_input
	FNRTS

	LOCAL

;E R0=data R1=length R8/R9=taskwindow (with valid source)
;X key data sent to taskwindow BD #

taskwindow_input
	FNJSR	"R1-R11"
	MOV	R7,R0			; save data
	MOV	R6,R1			; save len
	LDR	R0,local_claimed_wkspace ; is a paste-style op happening already?
	CMP	R0,#0
	FNRTS	NE
	LDR	R0,[R9,#f_cmode]
	FNLDR	R14,mode_taskwindow
	TEQ	R0,R14
	FNRTS	NE			; not an intiated task window
	MOV	R4,R6
	CMP	R4,#&3C
	BGT	large$l
	ADD	R5,R4,#24+3		; header size
	BIC	R5,R5,#3		; and word align for message size
	FNLDR	R0,buffer		; message buffer
	MOV	R1,R7
	ADD	R2,R0,#24
	MOV	R3,R4
	FNcall  Zap_MoveBytes		; copy data into message buffer
	FNLDR	R1,buffer
	STR	R5,[R1,#0]		; message size
	MOV	R0,#0
	STR	R0,[R1,#12]		; my ref
	LDR	R0,input$l
	STR	R0,[R1,#16]		; message
	STR	R4,[R1,#20]		; size of input data
	MOV	R0,#17
	LDR	R2,[R9,#f_source]	; buffer pointer
	LDR	R2,[R2]
	SWI	XWimp_SendMessage	; send the data
	FNRTS
input$l DCD	&808C0			; TaskWindow_Input
large$l					; R7=data R6=len (but not valid across
	FNcall  Zap_GetFileOff		; calls so can't be relied on)
	MOV	R3,R0
	ADD	R0,R4,#28
	FNcall  Zap_Claim
	FNRTS	VS
	STR	R0,local_claimed_wkspace
	STR	R6,[R0],#4
	MOV	R14,#20
	STR	R14,[R0],#4
	STR	R3,[R0],#4		; store file offset.
	STR	R11,[R0],#4		; store my wkspace ptr
	STR	R12,[R0],#4		; store zap's wkspace ptr
	MOV	R2,R0
	MOV	R1,R7
	MOV	R3,R6
	FNcall  Zap_MoveBytes		; copy data into the buffer
	MOV	R1,#-2
	ADR	R2,callback_tw_insert
	FNcall  Zap_CallBack
	FNRTS
local_claimed_wkspace
	DCD	0

callback_tw_insert
	FNJSR	"R0-R12"
	MOV	R0,#&70			; escape
	BL	test_forkey
	BCS	escaped$l
	LDR	R0,local_claimed_wkspace
	LDR	R6,[R0]
	CMP	R6,#0
	BLE	notagain$l
	LDR	R5,[R0,#4]
oninthere$l
	ADD	R7,R0,R5
	LDR	R11,[R0,#12]		; load my wkspace ptr
	LDR	R12,[R0,#16]		; load zap's wkspace ptr
	CMP	R6,#&3C
	MOVCS	R4,#&3C
	MOVCC	R4,R6
	SUB	R6,R6,R4
	STR	R6,[R0]			; new length.
	ADD	R5,R5,R4
	STR	R5,[R0,#4]		; remaining pointer...
	LDR	R0,[R0,#8]
	FNcall  Zap_ConvFileOff
	CMP	R9,#0
	BEQ	notagain$l
	ADD	R5,R4,#24+3		; header size
	BIC	R5,R5,#3		; and word align for message size
	FNLDR	R0,buffer		; message buffer
	MOV	R1,R7
	ADD	R2,R0,#24
	MOV	R3,R4
	FNcall  Zap_MoveBytes		; copy data into message buffer
	FNLDR	R1,buffer
	STR	R5,[R1,#0]		; message size
	MOV	R0,#0
	STR	R0,[R1,#12]		; my ref
	LDR	R0,input$l
	STR	R0,[R1,#16]		; message
	STR	R4,[R1,#20]		; size of input data
	MOV	R0,#17

	LDR	R2,[R9,#f_source]	; buffer pointer
	LDR	R2,[R2]
	SWI	XWimp_SendMessage	; send the data
	CMP	R6,#0
	BLE	notagain$l
	MOV	R1,#-2
	ADR	R2,callback_tw_insert
	FNcall  Zap_CallBack
	FNRTS
notagain$l
	LDR	R0,local_claimed_wkspace
	FNcall  Zap_Free
	MOV	R0,#0
	STR	R0,local_claimed_wkspace
	FNRTS

escaped$l
	LDR	R0,local_claimed_wkspace
	MOV	R6,#1
	MOV	R5,#20
	MOV	R14,#27
	STRB	R14,[R0,R5]
	B	oninthere$l

;E R9=task window file
;X file task killed DB #

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Output to a taskwindow screen				     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Internal R1=current line width		R2=cursor x
;	  R3=cursor y			R4=data
;	  R5=number of data bytes	R6=current offset
;	  R7=taskwindow buffer

;E R2=num R3=data R7=taskwidow buffer R8/R9
;X characters entered into file #

taskwindow_output_char
	LDR	R0,[R9,#f_source]
	LDR	R0,[R0,#52]
	TST	R0,#1<<4
	MOVNE	PC,R14
	FNJSR	"R1-R6"
	MOV	R4,R3			; save data
	MOV	R5,R2			; save num
	LDR	R2,[R7,#4]		; 'scn' cursor x
	LDR	R3,[R7,#8]		; 'scn' cursor y
ta10
	STR	R2,[R7,#4]
	STR	R3,[R7,#8]		; save cursor posn
	BL	twc_buf_xy_maybepad	; R2/R3=work x,y
	BLVC	tw_findoffset		; R6=start off R1=line len
	FNRTS	VS
	LDR	R2,[R7,#4]		; 'scn' cursor x
	LDR	R3,[R7,#8]		; 'scn' cursor y
	CMP	R1,R2
	BLLT	tw_padd_x		; add spaces to get column here
	FNRTS	VS
	CMP	R1,R2
	BLGT	tw_overwrite		; overwrite some chars
	BLVC	tw_add			; add remaining chars
	FNRTS	VS			; 'till reach txt window max
	CMP	R5,#0			; finished?
	BLE	ta11
	ADD	R3,R3,#1		; move to next line
	LDR	R2,[R7,#16]		; move to left hand edge
	LDR	R1,[R7,#28]		; y max
	CMP	R3,R1
	BLT	ta10			; still in window
	MOV	R0,#1
	BL	tw_scroll_up		; scroll the window up one line
	FNRTS	VS
	SUB	R3,R1,#1
	B	ta10			; carry on
ta11
	STR	R2,[R7,#4]
	STR	R3,[R7,#8]		; save cursor posn
	FNRTS

	LOCAL

;E R2/R3=work area x,y
;X R6=line offset start R1=line width #

tw_findoffset
	FNJSR	"R2-R3"
	LDR	R14,[R8,#w_height]
	CMP	R3,R14
	BCS	beyondend$l
	FNcall  Zap_FindOffset
	FNRTS	VS
	MOV	R6,R1			; line start
	MOV	R2,R0			; current offset
	LDR	R3,[R9,#f_len]
loop$l
	CMP	R2,R3
	SUBCS	R1,R2,R6
	FNRTS	CS
	MOV	R0,R2
	BL	cln_readc
	TEQ	R0,#&0A
	ADDNE	R2,R2,#1
	BNE	loop$l
	SUB	R1,R2,R6
	FNRTS

beyondend$l
	LDR	R6,[R9,#f_len]
	MOV	R1,#0
	FNRTS


;E R0=current window height R3=cusor y
;X file length padded #

tw_padd_y
	FNJSR	"R1-R3"
	SUB	R2,R3,R0
	ADD	R2,R2,#1		; number of lines to add in
	MOV	R0,#&0A			; char to add
	BL	tw_getblanks
	MOVVC	R0,#1			; insert
	LDRVC	R1,[R9,#f_len]		; at end
	FNcallc Zap_DoCommand,VC	; insert extra lines
	FNRTS

tw_padd_x
	FNJSR	"R1-R3"
	SUB	R2,R2,R1		; number of spaces to add in
	ADD	R1,R6,R1		; offset to add it at
	MOV	R0,#&20			; char to add
	BL	tw_getblanks
	FNRTS	VS
	MOV	R0,#1			; insert
	FNcall  Zap_DoCommand		; insert extra spaces
	FNRTS	VS
	FNPULL
	MOV	R1,R2			; now cursors matched
	MOV	PC,R14

;E R0=char R2=num
;X R3=buffer containg R2*char in R0 #

tw_getblanks
	FNJSR	"R1-R2"
	MOV	R3,R0			; save char
	FNLDR	R0,buffer
	MOV	R1,R2
	FNcall  Zap_Ensure
	FNRTS	VS
	FNSTR	R0,buffer
	MOV	R1,R0			; buffer
	MOV	R0,R3			; char
	MOV	R3,R1			; save buffer pointer
	BL	strstr
	FNRTS

tw_overwrite
	FNJSR	"R1-R3"
	SUB	R1,R1,R2		; num could be overwitten (>0)
	LDR	R0,[R7,#24]
	SUB	R0,R0,R2		; num cols left in text window
	CMP	R0,R1
	MOVGT	R0,R1			; num could print
	CMP	R0,R5
	MOVGT	R0,R5			; num can overwrite
	CMP	R0,#0			; any left?
	FNRTS	LE
	ADD	R1,R6,R2		; offset
	MOV	R2,R0			; number
	MOV	R3,R4			; data
	MOV	R0,#3			; replace
	FNcall  Zap_DoCommand
	FNRTS	VS
	MOV	R0,R2			; save number done
	FNPULL
	ADD	R4,R4,R0
	SUB	R5,R5,R0
	ADD	R2,R2,R0		; update vals
	MOV	PC,R14

tw_add
	FNJSR	"R1-R3"
	LDR	R0,[R7,#24]
	SUB	R0,R0,R2		; num cols left
	CMP	R0,R5
	MOVGT	R0,R5			; num can insert
	CMP	R0,#0
	FNRTS	LE
	ADD	R1,R6,R2		; offset
	MOV	R2,R0			; number
	MOV	R3,R4			; data
	MOV	R0,#1			; insert
	FNcall  Zap_DoCommand
	FNRTS	VS
	MOV	R0,R2			; save number done
	FNPULL
	ADD	R4,R4,R0
	SUB	R5,R5,R0
	ADD	R2,R2,R0
	MOV	PC,R14

;E R0=num of lines R7=buf R8/R9
;X window scrolled up by R0 lines #

tw_scroll_up
	FNJSR	"R1-R5"
	MOV	R1,R0			; save number of lines
	LDR	R14,[R7,#16]
	TEQ	R14,#0
	LDR	R14,[R7,#20]
	TEQEQ	R14,#0
	LDR	R14,[R7,#24]
	LDR	R0,[R8,#w_bpl]
	TEQEQ	R0,R14
	LDR	R14,[R7,#28]
	LDR	R0,[R7,#12]
	TEQEQ	R0,R14
	BNE	tw18			; window not full size
	LDR	R0,[R7,#56]
	ADD	R0,R0,R1
	STR	R0,[R7,#56]		; scroll whole screen
	FNRTS
tw18
	LDR	R2,[R7,#16]		; min x
	LDR	R3,[R7,#20]		; top line of window
	LDR	R4,[R7,#24]		; max x
	LDR	R5,[R7,#28]		; bottom
	SUB	R4,R4,R2		; width
tw27
	CMP	R3,R5			; finished?
	FNRTS	CS
	ADD	R3,R3,R1		; line to get from
	BL	tw_getline		; read line data
	SUBVC	R3,R3,R1		; line to write to
	BLVC	tw_putline		; write
	ADDVC	R3,R3,#1		; move to next line
	BVC	tw27
	FNRTS

;E R2=x off R3=y off R7=buffer R8/R9
;X R0=char at this posn

tw_getchar
	FNJSR	"R1-R6"
	MOV	R5,R2			; save x value
	BL	twc_to_xy_nopad		; get work xy
	BLVC	tw_findoffset		; R6=line start R1=line width
	FNRTS	VS
	CMP	R5,R1
	MOVCS	R0,#&20
	ADDCC	R0,R6,R5
	BLCC	cln_readc
	FNRTS

;E R2=x off R3=y off R7=buffer R8/R9
;X cursor incremented by 1 character with wrap

tw_increment
	ADD	R2,R2,#1
	LDR	R0,[R7,#24]
	CMP	R2,R0
	MOVCC	PC,R14
	LDR	R2,[R7,#16]
	ADD	R3,R3,#1
	LDR	R0,[R7,#28]
	CMP	R3,R0
	LDRCS	R3,[R7,#20]
	MOV	PC,R14

;E R2=x off R3=y off R4=width R7=buffer R8/R9
;X line data read to buffer ; blanks if outside window #

tw_getline
	LDR	R0,[R7,#20]		; min y
	CMP	R3,R0
	BLT	tw32
	LDR	R0,[R7,#28]		; max y
	CMP	R3,R0
	BGE	tw32
	FNJSR	"R1-R6"
	FNLDR	R0,buffer
	MOV	R1,R4
	FNcall  Zap_Ensure
	FNRTS	VS
	FNSTR	R0,buffer
	MOV	R5,R2			; save x val
	BL	twc_to_xy_nopad		; get work xy
	FNRTS	VS
	BL	tw_findoffset		; R6=line start R1=line width
	FNRTS	VS
	MOV	R2,R1			; save line width
	FNLDR	R3,buffer		; buffer
tw29
	CMP	R4,#0			; finished ?
	FNRTS	LE
	CMP	R5,R2
	MOVCS	R0,#&20
	ADDCC	R0,R6,R5
	BLCC	cln_readc
	STRB	R0,[R3],#1
	ADD	R5,R5,#1
	SUB	R4,R4,#1
	B	tw29
tw32
	FNJSR	"R1-R3"
	MOV	R0,#&20
	MOV	R2,R4
	BL	tw_getblanks		; fill buf with blanks -> R3
	FNRTS

;E R2=x off R3=y off R4=width R7=buffer R8/R9
;X line data written from buffer #

tw_putline
	FNJSR	"R1-R6"
	MOV	R5,R2			; save x val
	BL	twc_to_xy_nopad		; get work xy
	FNRTS	VS
	BL	tw_findoffset		; R6=line start R1=line width
	FNRTS	VS
	MOV	R2,R5			; restore x val
	MOV	R5,R4			; save length
	FNLDR	R4,buffer		; get data
	CMP	R1,R2
	BLLT	tw_padd_x
	FNRTS	VS
	CMP	R1,R2
	BLGT	tw_overwrite
	BLVC	tw_add
	FNRTS

;E R0=num of lines R7=buf R8/R9
;X window scrolled down by R0 lines #

tw_scroll_down
	FNJSR	"R1-R5"
	MOV	R1,R0			; save number of lines
	LDR	R14,[R7,#16]
	TEQ	R14,#0
	LDR	R14,[R7,#20]
	TEQEQ	R14,#0
	LDR	R14,[R7,#24]
	LDR	R0,[R8,#w_bpl]
	TEQEQ	R0,R14
	LDR	R14,[R7,#28]
	LDR	R0,[R7,#12]
	TEQEQ	R0,R14
	BNE	tw22			; window not full size
	LDR	R0,[R7,#56]
	SUBS	R0,R0,R1
	MOVMI	R0,#0
	STR	R0,[R7,#56]		; scroll whole screen
	FNRTS
tw22
	LDR	R2,[R7,#16]		; min x
	LDR	R5,[R7,#20]		; top line of window
	LDR	R4,[R7,#24]		; max x
	LDR	R3,[R7,#28]		; bottom
	SUB	R4,R4,R2		; width
	SUB	R3,R3,#1		; first line to write
tw28
	CMP	R3,R5			; finished?
	FNRTS	LT
	SUB	R3,R3,R1		; line to get from
	BL	tw_getline		; read line data
	ADDVC	R3,R3,R1		; line to write to
	BLVC	tw_putline		; write
	SUBVC	R3,R3,#1		; move to next line
	BVC	tw28
	FNRTS

;E R7=taskwindow buffer R8/R9
;X R2=work x R3=work y of cursor with file padded #

twc_buf_xy_maybepad
	FNJSR
	LDR	R3,[R7,#56]		; screen image offset
	LDR	R0,[R7,#8]		; cursor y
	ADD	R3,R3,R0		; work area y
	LDR	R2,[R7,#4]		; cursor x
	LDR	R0,[R8,#w_margin]
	ADD	R2,R2,R0
	LDR	R0,[R8,#w_height]	; height in lines
	CMP	R3,R0
	FNRTS	CC
	BL	seeifneedpad$l
	BEQ	notneeded$l
	BL	tw_padd_y		; CS
	FNRTS

notneeded$l
	PUSH	"R1-R3"
; SWI &107
	BL	tw_padd_y		; CS
	LDR	R1,[R9,#f_len]		; at end
	SUB	R1,R1,#1
	MOV	R0,#2			; delete
	MOV	R2,#1
	FNcall  Zap_DoCommand
	PULL	"R1-R3"
	ADD	R3,R3,#1
	MOV	R2,#0
	FNRTS

specialcase2$l
	LDR	R0,[R8,#w_margin]
	ADD	R2,R2,R0
	LDR	R0,[R8,#w_height]	; height in lines
	SUB	R0,R0,#1
	FNRTS

specialcase3$l
	LDR	R0,[R8,#w_margin]
	ADD	R2,R2,R0
	FNRTS

seeifneedpad$l
	FNJSR	"R0-R3"
	LDR	R0,[R9,#f_len]		; at end
	SUB	R0,R0,#1
	FNcall  Zap_OffLineCol		; R2 = col inc margin...
	LDR	R14,[R8,#w_bpl]
	SUB	R14,R14,#1
	LDR	R0,[R8,#w_margin]
	ADD	R14,R14,R0
	CMP	R2,R14
	FNRTS	CC
	MOVS	R14,#0
	FNRTS

;E R7=taskwindow buffer R8/R9
;X R2=work x R3=work y of cursor with file padded #

twc_buf_xy_nopad
	FNJSR
	LDR	R3,[R7,#56]		; screen image offset
	LDR	R0,[R7,#8]		; cursor y
	ADD	R3,R3,R0		; work area y
	LDR	R2,[R7,#4]		; cursor x
	LDR	R14,[R8,#w_bpl]
	CMP	R2,R14
	LDR	R0,[R8,#w_margin]
	ADD	R2,R2,R0
	FNRTS

;E R2/R3=posn on screen R7=buffer R8/R9
;X R2=work x R3=work y of cursor with file padded #

twc_to_xy_nopad
	FNJSR
	LDR	R0,[R7,#56]		; screen image offset
	ADD	R3,R3,R0
	LDR	R0,[R8,#w_margin]
	ADD	R2,R2,R0
	FNRTS

;E R0=char R1=num params R2=num R4=params R7=buffer R8/R9
;X ctrl action taken #

taskwindow_output_ctrl
	TEQ	R0,#6
	BEQ	skip_suspend_test
	PUSH	"R0"
	LDR	R0,[R9,#f_source]
	LDR	R0,[R0,#52]
	TST	R0,#1<<4
	PULL	"R0"
	MOVNE	PC,R14
skip_suspend_test
	TEQ	R0,#&7F
	BEQ	tw_delete
	SUB	R0,R0,#6
	CMP	R0,#32-6
	ADDLO	PC,PC,R0,LSL #2
	MOV	PC,R14			; unrecognised
	B	tw_show_output
	B	tw_bell
	B	tw_backspace
	B	tw_forspace
	B	tw_lf
	B	tw_upline
	B	tw_cls
	B	tw_cr
	MOV	PC,R14			; 14
	MOV	PC,R14			; 15
	MOV	PC,R14			; 16
	MOV	PC,R14			; 17
	MOV	PC,R14			; 18
	MOV	PC,R14			; 19
	MOV	PC,R14			; 20
	B	tw_hide_output
	B	tw_mode
	B	tw_vdu23
	MOV	PC,R14			; 24
	MOV	PC,R14			; 25
	B	tw_restore_window
	MOV	PC,R14			; 27
	B	tw_define
	MOV	PC,R14			; 29
	MOV	PC,R14			; 30
	B	tw_tab
	MOV	PC,R14			; not recognised

tw_hide_output
	FNJSR
	LDR	R14,[R9,#f_source]
	LDR	R0,[R14,#52]
	ORR	R0,R0,#1<<4
	STR	R0,[R14,#52]
	FNRTS

tw_show_output
	FNJSR
	LDR	R14,[R9,#f_source]
	LDR	R0,[R14,#52]
	BIC	R0,R0,#1<<4
	STR	R0,[R14,#52]
	FNRTS

tw_vdu23
	FNJSR	"R1-R11"
	LDRB	R0,[R4],#1		; get reason code
	TEQ	R0,#7
	FNRTS	NE

tw_scrollwindow
	LDRB	R0,[R4],#1		; extent (window/screen)
	LDRB	R0,[R4],#1		; direction
	CMP	R0,#4
	SUBCS	R0,R0,#4
	TEQ	R0,#3
	BEQ	tws_up
	TEQ	R0,#2
	FNRTS	NE
tws_down
	MOV	R0,#1
	BL	tw_scroll_down
	FNRTS
tws_up
	MOV	R0,#1
	BL	tw_scroll_up
	FNRTS

tw_mode
	FNJSR	"R1-R3"
	MOV	R0,#&12			; delete
	MOV	R1,#0
	LDR	R2,[R9,#f_len]
	FNcall  Zap_DoCommand		; whole file
	FNcallc Zap_StopOp,VC		; stop operation
	FNRTS	VS
	LDRB	R0,[R4]			; proposed mode
	BL	taskwindow_mode		; R2/R3=x,y
	STRVC	R3,[R7,#12]		; new screen height
	FNcallc Zap_SaveWinStatus,VC	; NOT NOW IN AN OP
	FNRTS	VS
	FNLDR	R0,mode_taskwindow
	ADD	R14,R8,#w_mode0
	LDR	R0,[R14,R0,LSL#2]!
	MOV	R0,R0,LSR#16
	ADD	R0,R2,R0,LSL#16
	STR	R0,[R14]		; bung in new width
	FNcall  Zap_NewWinStatus	; reopen the window
	BLVC	tw_restore_window
	FNcallc Zap_StartOp,VC		; restart operations
	FNRTS

;E R8,#w_bpl is new proposed width R9
;X Screen cleared and taskwindow block initialised for new width #

tw_newwidth
	FNJSR	"R1-R11"
	FNLDR	R14,mode_taskwindow
	LDR	R0,[R9,#f_cmode]
	TEQ	R0,R14
	FNRTS	NE
	LDR	R7,[R9,#f_source]
	MOV	R0,#0
	STR	R0,[R7,#56]		; emul screen offset
	MOV	R0,#&12			; delete
	MOV	R1,#0
	LDR	R2,[R9,#f_len]
	FNcall  Zap_DoCommand		; whole file
	BLVC	tw_restore_window
	FNRTS

tw_define
	FNJSR	"R1-R3"
	LDRB	R2,[R4]			; min x
	LDRB	R3,[R4,#3]		; min y
	LDRB	R0,[R4,#2]
	ADD	R0,R0,#1		; max x
	LDRB	R1,[R4,#1]
	ADD	R1,R1,#1		; max y
	CMP	R2,R0
	CMPLT	R3,R1
	FNRTS	GE
	LDR	R14,[R7,#12]		; screen height
	CMP	R1,R14
	FNRTS	GT
	LDR	R14,[R8,#w_bpl]
	CMP	R0,R14
	FNRTS	GT
	STR	R2,[R7,#16]
	STR	R3,[R7,#20]
	STR	R0,[R7,#24]
	STR	R1,[R7,#28]		; set window defn
	STR	R2,[R7,#4]
	STR	R3,[R7,#8]		; and put cursor at top left

	; construct the new text window
	AND	r2, r2, #255		; xmin
	AND	r1, r1, #255		; ymin (lowest on screen, max y here}
	ORR	r2, r2, r1, LSL#8
	AND	r0, r0, #255		; xmax
	SUB	r0, r0, #1
	ORR	r2, r2, r0, LSL#16
	AND	r3, r3, #255		; ymax (highest on screen , min y here)
	SUB	r3, r3, #1
	ORR	r2, r2, r3, LSL#24
	LDR	r0, [r7, #48]
	STR	r2, [r0]		; and save it
	FNRTS

tw_tab
	FNJSR	"R2-R3"
	LDRB	R0,[R4]			; tab x
	LDR	R2,[R7,#16]		; min x
	LDR	R14,[R7,#24]
	SUB	R14,R14,R2		; width x
	CMP	R0,R14
	FNRTS	CS
	ADD	R2,R2,R0
	LDRB	R0,[R4,#1]
	LDR	R3,[R7,#20]		; min y
	LDR	R14,[R7,#28]
	SUB	R14,R14,R3		; height y
	CMP	R0,R14
	FNRTS	CS
	ADD	R3,R3,R0
	STR	R2,[R7,#4]
	STR	R3,[R7,#8]		; cursor x,y
	FNRTS

tw_cls
	FNJSR	"R1-R4"
	LDR	R1,[R7,#16]		; min x
	LDR	R2,[R7,#24]		; max x
	SUB	R2,R2,R1		; width
	MOV	R4,R2			; save width
	MOV	R0,#&20			; char
	BL	tw_getblanks		; R3=buf detoken
	FNRTS	VS
	MOV	R2,R1			; min x
	LDR	R3,[R7,#20]		; min y
	STR	R2,[R7,#4]
	STR	R3,[R7,#8]		; reset cursor
	LDR	R1,[R7,#28]		; max y
tw30
	CMP	R3,R1
	FNRTS	CS			; finished
	BL	tw_putline		; blank that line
	ADDVC	R3,R3,#1
	BVC	tw30
	FNRTS

tw_cr
	LDR	R0,[R7,#16]		; window minx
	STR	R0,[R7,#4]		; cursor x
	MOV	PC,R14

tw_forspace
	FNJSR	"R1-R2"
	LDR	R1,[R7,#4]		; x coord
	ADD	R1,R1,R2		; new column
	MOV	R2,#0			; num lines to move down
	LDR	R0,[R7,#24]		; maxx
	LDR	R14,[R7,#16]		; minx
	SUB	R14,R0,R14		; width
tw20
	CMP	R1,R0
	ADDGE	R2,R2,#1
	SUBGE	R1,R1,R14		; move down a line
	BGE	tw20
	STR	R1,[R7,#4]		; new column
	CMP	R2,#0
	BLGT	tw_lf			; move down some rows
	FNRTS

tw_lf
	FNJSR	"R1"
	BL	tw_insertlinefeeds	; insert some LFs...
	LDR	R0,[R7,#8]
	ADD	R0,R0,R2		; move down R2 lines
	LDR	R1,[R7,#28]		; max y
	CMP	R0,R1
	STRLT	R0,[R7,#8]
	BLT	noscrollupneeded$l
	SUB	R0,R0,R1
	ADD	R0,R0,#1		; number of lines to scroll
	BL	tw_scroll_up
	SUBVC	R0,R1,#1
	STRVC	R0,[R7,#8]		; new y
noscrollupneeded$l
	BLVC	tw_showcursor		; make sure cursor visible etc....????
	FNRTS

tw_backspace
	FNJSR	"R1-R2"
	LDR	R1,[R7,#4]		; x coord
	SUB	R1,R1,R2		; new column
	MOV	R2,#0			; num lines to move up
	LDR	R14,[R7,#24]		; maxx
	LDR	R0,[R7,#16]		; minx
	SUB	R14,R14,R0		; width
tw23
	CMP	R1,R0
	ADDLT	R2,R2,#1
	ADDLT	R1,R1,R14		; move down a line
	BLT	tw23
	STR	R1,[R7,#4]		; new column
	CMP	R2,#0
	BLGT	tw_upline		; move up some rows
	FNRTS

tw_upline
	FNJSR	"R1"
	LDR	R0,[R7,#8]
	SUB	R0,R0,R2		; move down R2 lines
	LDR	R1,[R7,#20]		; min y
	CMP	R0,R1
	STRGE	R0,[R7,#8]
	FNRTS	GE
	SUB	R0,R1,R0		; num lines to scroll down
	BL	tw_scroll_down
	FNRTS	VS
	MOV	R0,R1
	STR	R0,[R7,#8]		; new y
	FNRTS

tw_bell
	FNJSR
	SWI	&20107
	FNRTS

tw_restore_window
	FNJSR	"R1"
	MOV	R0,#0
	STR	R0,[R7,#4]		; cursor x
	STR	R0,[R7,#8]		; cursor y
	STR	R0,[R7,#16]		; min x
	STR	R0,[R7,#20]		; min y
	LDR	R0,[R8,#w_bpl]
	STR	R0,[R7,#24]		; max x
	LDR	R0,[R7,#12]
	STR	R0,[R7,#28]		; max y

	LDRB	r0, [r8, #w_bpl]	; construct the initial text window
	SUB	r0, r0, #1
	MOV	r0, r0, LSL#16
	LDR	r1, [r7, #48]
	TEQ	r1, #0
	STRNE	r0, [r1]		; and save it
	FNRTS

tw_delete
	FNJSR	"R1-R6"
	MOV	R5,R2			; save num
	LDR	R2,[R7,#4]
	LDR	R3,[R7,#8]
tw19
	STR	R2,[R7,#4]
	STR	R3,[R7,#8]
	BL	twc_buf_xy_nopad	; R2/R3=work x,y
	BLVC	tw_findoffset		; R6=start off R1=line len
	FNRTS	VS
	LDR	R2,[R7,#4]		; scn x
	LDR	R3,[R7,#8]		; scn y
	CMP	R1,R2
	BLLT	tw_unpadd_x
	FNRTS	VS
	CMP	R1,R2
	BLGT	tw_blank
	FNRTS	VS
	CMP	R1,R2
	BLEQ	tw_delchar
	FNRTS	VS
	CMP	R5,#0			; finished
	BLE	tw21			; yes
	SUB	R3,R3,#1		; move to previous line
	LDR	R2,[R7,#24]		; move to rhs edge
	LDR	R1,[R7,#20]		; y min
	CMP	R3,R1
	BGE	tw19			; do next line
	MOV	R0,#1
	BL	tw_scroll_down
	MOVVC	R3,R1
	BVC	tw19
	FNRTS
tw21
	STR	R2,[R7,#4]
	STR	R3,[R7,#8]		; save cursor posn
	FNRTS

tw_unpadd_x
	FNJSR
	SUB	R0,R2,R1		; num chars to unpadd>0
	LDR	R14,[R7,#16]		; window lhs
	SUB	R14,R2,R14
	CMP	R0,R14
	MOVGT	R0,R14			; num could unpadd
	CMP	R0,R5
	MOVGT	R0,R5			; num want to unpadd
	CMP	R0,#0
	SUBGT	R5,R5,R0
	SUBGT	R2,R2,R0
	FNRTS

tw_blank
	FNJSR	"R1-R3"
	LDR	R14,[R7,#16]		; window lhs
	SUB	R0,R2,R14		; number could blank
	CMP	R0,R5
	MOVGT	R0,R5			; num want to blank
	CMP	R0,#0
	FNRTS	LE
	ADD	R1,R6,R2		; current offset
	MOV	R2,R0			; num
	SUB	R1,R1,R2		; offset to blank at
	MOV	R0,#&20			; blank with spaces
	BL	tw_getblanks
	MOVVC	R0,#3			; replace
	FNcallc Zap_DoCommand,VC
	MOVVC	R0,R2			; save number blanked
	FNPULL
	SUBVC	R2,R2,R0
	SUBVC	R5,R5,R0
	MOV	PC,R14

;\E R2 = column?
;   R5 = max value which could be deleted?
tw_delchar
	FNJSR	"R1-R5"
	LDR	R14,[R7,#16]		; window lhs
	SUB	R0,R2,R14		; number could delete
	CMP	R0,R5
	MOVGT	R0,R5			; num want to delete
	CMP	R0,#0
	FNRTS	LE			; um error...?
	ADD	R1,R6,R2		; current offset
	MOV	R2,R0			; num
	SUB	R1,R1,R2		; offset to delete at
	MOV	R0,#2			; delete
	FNcall  Zap_DoCommand
	MOVVC	R0,R2			; save number deleted
	FNPULL
	SUBVC	R2,R2,R0
	SUBVC	R5,R5,R0
	SUBVC	R1,R1,R0
	MOV	PC,R14

tw_insertlinefeeds
	FNJSR	"R1-R11"
	FNcall  Zap_FindInput
	FNRTS	VS
	MOV	R7,R0
	LDR	R0,[R9,#f_len]
	PUSH	"R9"
	FNLDR	R9,mode_taskwindow
	MOV	R11,#e_linestart
	FNcall  Zap_BaseMode
	PULL	"R9"
	FNRTS	VS
	CMP	R7,R0
	FNRTS	CC
; SWI &107
	CMP	R2,#7
	MOVCS	R2,#7
	LDR	R1,[R9,#f_len]
	ADR	R3,eighttens$l
	MOV	R0,#1
	FNcall  Zap_DoCommand
	FNRTS
eighttens$l
	DCD	&0A0A0A0A
	DCD	&0A0A0A0A

;E R0=mode number/-1 for current
;X R2=screen width R3=screen height in chars #

taskwindow_mode
	FNJSR	"R1,R4"
	MOV	R4,R0			; save mode
	MOV	R1,#2
	SWI	XOS_ReadModeVariable
	ADDVC	R3,R2,#1		; height
	MOVVC	R0,R4
	MOVVC	R1,#1
	SWIVC	XOS_ReadModeVariable
	ADDVC	R2,R2,#1		; width
	FNRTS



; ---------- TASKWINDOW_FLAGSTOGGLE command -----------

	DCD	&8017
Cmdtaskwindowflagstoggle
	FNJSR	"R1-R4,R11"
	BL	get_workspace
	MOV	R4,R0

	FNLDR	R1,mode_taskwindow
	FNcall  Zap_GetModeWord,R0

	MOV	R3,R0
	LDR	R0,[R4]
	BL	calculate_masks

	TEQ	R2,#15
	BNE	set$l
	AND	R3,R3,R1		; check tick state
	TEQ	R3,R1			; all set?
	MOVEQ	R0,#1			; yes so tick
	MOVNE	R0,#0
	FNRTS

set$l	BIC	R0,R3,R0		; set new options
	EOR	R0,R0,R1

	FNLDR	R1,mode_taskwindow	; save them
	FNcall	Zap_PutModeWord
	FNRTS


;E R0 = 4 x 8 bit instruction blocks. Each block has format:
;	b0-b4 = 0-31 number of bit in the word to toggle
;	b5/b6 = 00 => toggle the bit
;		01 => set the bit
;		10 => clear the bit
;		11 => reserved
;	b7    = must be set to show this block active (except lowest byte
;		where its unused by this sub - others may use it)
;X R0 = BIC mask  R1 = eor to accomplish this
calculate_masks
	FNJSR	"R2-R3"
	ORR	R2,R0,#1<<7		; lowest byte always contains a block
	MOV	R0,#0
	MOV	R1,#0			; default mask/eor (does nothing)
a$l	TST	R2,#1<<7		; active block?
	FNRTS	EQ			; no - finished
	AND	R3,R2,#&1F		; bit number
	MOV	R14,#1
	MOV	R14,R14,LSL R3		; bit mask
	ANDS	R3,R2,#&60		; action
	ORREQ	R1,R1,R14		; toggle
	TEQ	R3,#&20
	ORREQ	R0,R0,R14
	ORREQ	R1,R1,R14		; set the bit
	TEQ	R3,#&40
	ORREQ	R0,R0,R14		; clear the bit
	MOV	R2,R2,LSR#8
	B	a$l

	LOCAL


local_stored_cur_posn
	DCD	-1
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0


; ------------ e_click ------------

twmode_click
	FNJSR	"R1-R7"
	TST	R4,#9			; Adjust or drag?
	MOVNE	R0,#0
	BNE	adjordrag$l

	PUSH	"R1-R10"
	MOV	R1,#10
	FNcall  Zap_ReadVar
	TEQ	R0,#1			; cursor mode not 1?
	MOVNE	R0,#21			; if so, force Ctrl and callback
	BNE	store$l
					; test to see if on previous logical line...
	MOV	R1,#6			; car_input
	FNcall  Zap_ReadVar		; get Zap's R10 cursor pointer
	MOV	R1,R0
	FNcall  Zap_GetWindOff
	LDR	R14,[R1,#c_wind]
	TEQ	R0,R14			; cursor in different window?
	MOVNE	R0,#0			; 1<<31		; if so, no forced Ctrl but call back
	BNE	store$l
	LDR	R4,[R1,#c_col]
	LDR	R5,[R1,#c_line]
	BL	chkvalidity$l
	MOVEQ	R0,#21+(1<<31)
	MOVNE	R0,#0
store$l
	PULL	"R1-R10"
adjordrag$l
	STR	R0,local_stored_cur_posn + 24

	LDR	R14,local_stored_cur_posn
	CMP	R14,#-1
	BNE	in_progress_clk
	BL	z_d_clk
	MOV	R1,#10			; car_mode
	FNcall  Zap_ReadVar
	CMP	R0,#1
	FNRTS	NE
	LDR	R1,[R9,#f_source]
	LDR	R2,[R1,#4]		; #4 Cursor x coordinate
	LDR	R3,[R1,#8]		; #8 Cursor y coordinate
	LDR	R14,[R1,#56]		; #8 y coordinate start of screen
	ADD	R3,R3,R14

	ADR	R14,local_stored_cur_posn
	LDR	R4,[R14,#24]
	BICS	R4,R4,#&FF
	STMEQIA R14,{R2,R3,R8,R9,R11,R12}
; set up a callback to reposition the cursor when buttons are released :-/
	BLEQ	callback_cur_posn

	FNRTS

in_progress_clk
	BL	z_d_clk
	FNRTS

z_d_clk
	FNJSR	"R9,R10,R11"
	FNLDR	R9,mode_taskwindow
	MOV	R11,#e_click
	FNcall  Zap_BaseMode
	FNRTS

callback_cur_posn
	FNJSR	"R0-R12"
	LDR	R11,local_stored_cur_posn + 16
	LDR	R12,local_stored_cur_posn + 20
	FNLDR	R1,buffer		; scrap... :/
	SWI	XWimp_GetPointerInfo
	LDR	R1,[R1,#8]
	CMP	R1,#0
	BEQ	at_the_end_so_pos
	MOV	R1,#-2
	ADR	R2,callback_cur_posn
	FNcall  Zap_CallBack
	FNRTS

at_the_end_so_pos
					; LDR R0,local_stored_cur_posn
	LDR	R8,local_stored_cur_posn + 8
	LDR	R9,local_stored_cur_posn + 12
	MOV	R1,#5			; car_cursor
	FNcall  Zap_ReadVar		; get Zap's R10 cursor pointer
	MOV	R10,R0
	LDR	R4,[R10,#c_col]
	LDR	R5,[R10,#c_line]
	LDR	R2,local_stored_cur_posn + 0
	LDR	R3,local_stored_cur_posn + 4
	MOV	R14,#-1
	STR	R14,local_stored_cur_posn
	BL	maybe_adjust		; returns EQ of done everything.
	FNRTS	EQ			; all ok and done: some movement happened...
	FNcall  Zap_FindOffset
	FNcall  Zap_JumptoOffset
	FNRTS

; this needs to be done in a callback to prevent TW module messups!

;E R2,R3,R4,R5,R8,R9
maybe_adjust
	FNJSR				; not needed "R2,R3,R6"
	BL	chkvalidity$l
	BLEQ	in_maybe_adjust
	FNRTS

in_maybe_adjust
	FNJSR	"R0-R11"
	LDR	R7,[R9,#f_source]
	LDR	R6,[R7,#16]		; #16 Emulated text window (VDU 28) min x
	LDR	R14,[R7,#24]		; #24 Emulated text window (VDU 28) max x
	SUB	R6,R14,R6		; 'real' width
	SUB	R5,R3,R5
	MUL	R5,R6,R5
					; r5 now used :/
	SUBS	R6,R2,R4
	ADDS	R5,R5,R6
	BEQ	endnoteq$l

	BLPL	checktoseeifinprompt
	BPL	endnoteq$l		; endeq$l

	CMP	R5,#0
	MOVPL	R3,#&8C00
	MOVMI	R3,#&8D00
	RSBMI	R5,R5,#0

	ORR	R3,R3,R3,LSL #16
	MOV	R0,R5,LSL#1		; total length
	ADD	R0,R0,#12
	FNcall  Zap_Claim		; reserve memory
	FNRTS	VS
	MOV	R7,R0
	MOV	R5,R5,LSL #1
	ADD	R2,R5,#7
	BIC	R2,R2,#3
loop$l
	STR	R3,[R7,R2]
	SUBS	R2,R2,#4
	BPL	loop$l
	BL	twmode_char
	MOV	R0,R7
	FNcall  Zap_Free
endeq$l
	MOVS	R0,#0			; EQ...
	FNRTS

endnoteq$l
	MVNS	R0,#0			; NE...
	FNRTS

; returns PL if in prompt
checktoseeifinprompt
	FNJSR	"R0,R1"
	LDR	R0,[R7]			; #16 Task handle
	SWI	XLineEditor_ReadInfo	; R0 LL - R1 cur pos.
	BVS	unklineedit$l
	CMP	R0,#0
	BMI	unklineedit$l
	CMP	R5,R1
	BGT	inprompt$l
unklineedit$l
	MOVS	R14,#-1
	FNRTS
inprompt$l
	SUBS	R14,R14,R14
	FNRTS

;E 2,3 /4,5
;X NE if not on same logical line.
chkvalidity$l
	FNJSR	"R0-R3,R7"
	BL	foandretr0
	MOV	R7,R0			; one...
	MOV	R2,R4
	MOV	R3,R5
	BL	foandretr0
	CMP	R0,R7
	FNRTS

foandretr0
	FNJSR	"R1,R4"			; ???
	FNcall  Zap_FindOffset
	FNcall  Zap_OffsetLine
	MOV	R0,R2
	FNRTS

twmode_interrogate
	CMP	R0,#11
	MOVEQ	PC,R14
	CMP	R0,#1
	CMPNE	R0,#2
	CMPNE	R0,#7
	CMPNE	R0,#13			; sayt
	CMPNE	R0,#22			; confine?
	CMPNE	R0,#23			; confine?
	CMPNE	R0,#24			; confine?
	MOVEQ	R0,#0
	MOVEQ	PC,R14
	CMP	R0,#21			; drags are ctrl-drags...?
	LDREQB  R0,local_stored_cur_posn + 24
	MOVEQ	PC,R14
	CMP	R0,#14			; what mode type?
	MOVEQ	R0,#3			; TW
	MOVEQ	PC,R14
	CMP	R0,#0
	CMPNE	R0,#3
	MOVNE	PC,R14
	MOV	R0,R1
	MOV	PC,R14


; ------------ filter code ------------

; register the width setting filter on a child
; E r7 = f_source
; X
register_filter
	FNJSR	"R0-R4"
	LDR	R0,[R7,#52]
	TST	R0,#1<<5		; already registered
	FNRTS	NE

	ADRL	r0, twmode_title	; register the post filter
	ADRL	r1, twmode_postfilter
	LDR	r2, [r7, #48]
	LDR	r3, [r7]
	MOV	r4, #0
	SWI	XFilter_RegisterPostFilter

	LDRVC	R0,[R7,#52]		; if OK, set the 'registered' flag
	ORRVC	R0,R0,#1<<5
	STRVC	R0,[R7,#52]
	FNRTVC				; ignore errors

; deregister the width filter
; E r7 = f_source
; X
deregister_filter
	FNJSR	"R0-R4"
	LDR	R0,[R7,#52]		; check if it's registered
	TST	R0,#1<<5
	FNRTS	EQ

	BIC	R0,R0,#1<<5
	STR	R0,[R7,#52]

	ADRL	r0, twmode_title	; deregister the filter
	ADRL	r1, twmode_postfilter
	LDR	r2, [r7, #48]
	LDR	r3, [r7]
	MOV	r4, #0
	SWI	XFilter_DeRegisterPostFilter
	FNRTVC				; ignore errors


tw_prepare
	DCB 	4			; VDU 4
	DCB	23,1,0,0,0,0,0,0,0,0	; turn cursor off
tw_endprepare
	ALIGN

twmode_postfilter
	FNJSR	"R0,R1,R12"
	SWI	XOS_WriteI + 28
	MOV	r0, r12			; r12 is a pointer to the text window
	MOV	r1, #4
	SWI	XOS_WriteN

	ADR	r0, tw_prepare		; text mode, no cursor
	MOV	r1, #tw_endprepare - tw_prepare
	SWI	XOS_WriteN
	FNRTS




 END
